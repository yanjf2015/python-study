<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=big5">
<title>MySQL中文參考手冊- 7 MySQL 語言參考</title>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"2db29842af5756bf509b2c75a2721481",petok:"9155329c21d8425699f308a07fb3b3630688d8f5-1479574673-1800",zone:"twpug.net",rocket:"0",apps:{"ga_key":{"ua":"UA-11633811-1","ga_bs":"2"}}}];!function(a,b){a=document.createElement("script"),b=document.getElementsByTagName("script")[0],a.async=!0,a.src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=088620b277/cloudflare.min.js",b.parentNode.insertBefore(a,b)}()}}catch(e){};
//]]>
</script>
<style type="text/css">
<!--
.p14{font-size:14.8px;font-family:宋體;line-height:14pt;}
a:hover{color:red;}
a.t1:visited{color:red;}
-->
</style>
<script type="text/javascript">
/* <![CDATA[ */
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-11633811-1']);
_gaq.push(['_trackPageview']);

(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

(function(b){(function(a){"__CF"in b&&"DJS"in b.__CF?b.__CF.DJS.push(a):"addEventListener"in b?b.addEventListener("load",a,!1):b.attachEvent("onload",a)})(function(){"FB"in b&&"Event"in FB&&"subscribe"in FB.Event&&(FB.Event.subscribe("edge.create",function(a){_gaq.push(["_trackSocial","facebook","like",a])}),FB.Event.subscribe("edge.remove",function(a){_gaq.push(["_trackSocial","facebook","unlike",a])}),FB.Event.subscribe("message.send",function(a){_gaq.push(["_trackSocial","facebook","send",a])}));"twttr"in b&&"events"in twttr&&"bind"in twttr.events&&twttr.events.bind("tweet",function(a){if(a){var b;if(a.target&&a.target.nodeName=="IFRAME")a:{if(a=a.target.src){a=a.split("#")[0].match(/[^?=&]+=([^&]*)?/g);b=0;for(var c;c=a[b];++b)if(c.indexOf("url")===0){b=unescape(c.split("=")[1]);break a}}b=void 0}_gaq.push(["_trackSocial","twitter","tweet",b])}})})})(window);
/* ]]> */
</script>
</head>

<body BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#101090" VLINK="#7030B0" class="p4">

<h1><img src="Img/mysql-logo.gif" alt="mysql-logo.gif (3082 bytes)" WIDTH="127" HEIGHT="60"><font color="#FF0000">MySQL中文參考手冊</font></h1>

<p>譯者：晏子 <a href="/cdn-cgi/l/email-protection#f7df949b8e9699b784989f82d994989a">(<span class="__cf_email__" data-cfemail="791a15001817390a16110c571a1614">[email&#160;protected]</span><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></a>） 
&nbsp;&nbsp;&nbsp;&nbsp; 主頁：<a href="http://linuxdb.yeah.net">http://linuxdb.yeah.net</a></p>

<p>譯者：晏子 <a href="/cdn-cgi/l/email-protection#4c642f20352d220c3f232439622f2321">(<span class="__cf_email__" data-cfemail="7417180d151a34071b1c015a171b19">[email&#160;protected]</span><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></a>）<br>
GB 碼主頁：<a href="http://linuxdb.yeah.net">http://linuxdb.yeah.net</a></p>

<p>Big5 轉碼者：statue <a href="/cdn-cgi/l/email-protection#ed9e998c999888c38f8f9ead8f8f9ec3949798c3888998c3999a">
(<span class="__cf_email__" data-cfemail="7c0f081d0809193c1e1e0f520506095219180952080b">[email&#160;protected]</span><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></a>） <br>
詞彙轉換：彭武興 (<a href="/cdn-cgi/l/email-protection#5126383d223e3f113c30383d333e297f323e3c7f2526"><span class="__cf_email__" data-cfemail="5f2836332c30311f323e36333d3027713c3032712b28">[email&#160;protected]</span><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></a>)<br>
Big5 碼主頁：
<a href="http://cnpa.yzu.edu.tw/~cfc/docs/mysqldoc_big5/manual_toc.html">
http://cnpa.yzu.edu.tw/~cfc/docs/mysqldoc_big5/manual_toc.html</a><br>
Big5 碼分站：
<a href="http://php.wilson.gs/mysqldoc/big5/manual_toc.html">
http://php.wilson.gs/mysqldoc/big5/manual_toc.html
</p>

<hr>

<p><a HREF="manual_Introduction.html">第一章</a>, <a HREF="manual_Privilege_system.html">前一章</a>, <a HREF="manual_Tutorial.html">下一章</a>, 
<a HREF="manual_Concept_Index.html">最後一章</a>，<a HREF="manual_toc.html">目錄</a>. 
</p>

<hr>

<h1><a NAME="Reference" HREF="manual_toc.html#Reference">7 MySQL語言參考</a></h1>

<p><a NAME="IDX153"></a> <a NAME="IDX154"></a> </p>

<h2><a NAME="Literals" HREF="manual_toc.html#Literals">7.1 
文字：怎麼寫字符串和數字</a></h2>

<h3><a NAME="String_syntax" HREF="manual_toc.html#String_syntax">7.1.1 字符串</a></h3>

<p>一個字符串是一個字符序列，由單引號(<samp>“'”</samp>)或雙引號(<samp>“&quot;”</samp>)字符(後者只有你不在ANSI模式運行)包圍。例如：</p>

<pre>'a string'
&quot;another string&quot;
</pre>

<p>在字符串內，某個順序有特殊的意義。這些順序的每一個以一條反斜線(<samp>“\”</samp>)開始，稱為<em>轉義字符</em>。<strong>MySQL</strong>識別下列轉義字符： 

<dl compact>
  <dt><code>\0</code> </dt>
  <dd><a name="IDX155"></a>一個ASCII 0 (<code>NUL</code>)字符。 <a name="IDX157"></a><a name="IDX158"></a> </dd>
  <dt><code>\n</code> </dt>
  <dd>一個新行符。 <a name="IDX159"></a><a name="IDX160"></a> </dd>
  <dt><code>\t</code> </dt>
  <dd>一個定位符。 <a name="IDX161"></a><a name="IDX162"></a><a name="IDX163"></a> </dd>
  <dt><code>\r</code> </dt>
  <dd>一個回車符。 <a name="IDX164"></a><a name="IDX165"></a> </dd>
  <dt><code>\b</code> </dt>
  <dd>一個退格符。 <a name="IDX166"></a><a name="IDX167"></a> </dd>
  <dt><code>\'</code> </dt>
  <dd>一個單引號(<samp>“'”</samp>)符。 <a name="IDX168"></a><a name="IDX169"></a> </dd>
  <dt><code>\&quot;</code> </dt>
  <dd>一個雙引號(<samp>“&quot;”</samp>)符。 <a name="IDX170"></a><a name="IDX171"></a> 
  </dd>
  <dt><code>\\</code> </dt>
  <dd>一個反斜線(<samp>“\”</samp>)符。 <a name="IDX172"></a><a name="IDX173"></a> </dd>
  <dt><code>\%</code> </dt>
  <dd>一個“<samp>%”</samp>符。它用於在正文中搜索“%”的文字實例，否則這裡“%”將解釋為一個通配符。 
    <a name="IDX174"></a><a name="IDX175"></a> </dd>
  <dt><code>\_</code> </dt>
  <dd>一個“<samp>_”</samp>符。它用於在正文中搜索“_”的文字實例，否則這裡“_”將解釋為一個通配符。</dd>
</dl>

<p>注意，如果你在某些正文環境中使用<samp>“\%”</samp>或<samp>“\%_”</samp>，這些將返回字符串<samp>“\%”</samp>和<samp>“\_”</samp>而不是<samp>“%”</samp>和<samp>“_”</samp>。 
</p>

<p>有幾種方法在一個字符串內包括引號： 

<ul>
  <li>一個字符串內用“'”加引號的“'”可以被寫作為<samp>“''”</samp>。 
  </li>
  <li>一個字符串內用<samp>“&quot;”加引號</samp>的<samp>“&quot;”</samp>可以被寫作為<samp>“&quot;&quot;”</samp>。 
  </li>
  <li>你可以把一個轉義字符（“\”）放在引號前面。 </li>
  <li>一個字符串內用<samp>“&quot;”</samp>加引號<samp>的“'”</samp>不需要特殊對待而且不必被重複或轉義。同理，<samp>一個字符串內用“'”加引號的</samp>與<samp>“&quot;”</samp>也不需要特殊對待。 
  </li>
</ul>

<p>下面顯示的<code>SELECT</code>演示引號和轉義如何工作： </p>

<pre>mysql&gt; SELECT 'hello', '&quot;hello&quot;', '&quot;&quot;hello&quot;&quot;', 'hel''lo', '\'hello';
+-------+---------+-----------+--------+--------+
| hello | &quot;hello&quot; | &quot;&quot;hello&quot;&quot; | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+

mysql&gt; SELECT &quot;hello&quot;, &quot;'hello'&quot;, &quot;''hello''&quot;, &quot;hel&quot;&quot;lo&quot;, &quot;\&quot;hello&quot;;
+-------+---------+-----------+--------+--------+
| hello | 'hello' | ''hello'' | hel&quot;lo | &quot;hello |
+-------+---------+-----------+--------+--------+

mysql&gt; SELECT &quot;This\nIs\nFour\nlines&quot;;
+--------------------+
| This
Is
Four
lines |
+--------------------+
<a NAME="IDX176"></a> </pre>

<p>如果你想要把二進制數據插入到一個<code>BLOB</code>列，下列字符必須由轉義序列表示： 

<dl compact>
  <dt><code>NUL</code></dt>
  <dd>ASCII 0。你應該用'\0'（一個反斜線和一個ASCII '0'）表示它。 </dd>
  <dt><code>\</code> </dt>
  <dd>ASCII 92，反斜線。用'\\'表示。 </dd>
  <dt><code>'</code> </dt>
  <dd>ASCII 39，單引號。用“\'”表示。 </dd>
  <dt><code>&quot;</code> </dt>
  <dd>ASCII 34，雙引號。用“\&quot;”表示。 </dd>
</dl>

<p><a NAME="IDX177"></a>如果你寫C代碼，你可以使用C API函數<code>mysql_escape_string()</code>來為<code>INSERT</code>語句轉義字符。見<a HREF="manual_Clients.html#C_API_function_overview">20.3 C API 函數概述</a>。在 Perl中，你可以使用<code>DBI</code>包中的<code>quote</code>方法變換特殊的字符到正確的轉義序列。見<a HREF="manual_Clients.html#Perl_DBI_Class">20.5.2 <code>DBI</code>介面</a>。 </p>

<p>你應該在任何可能包含上述任何特殊字符的字符串上使用轉義函數！ 
</p>

<h3><a NAME="Number_syntax" HREF="manual_toc.html#Number_syntax">7.1.2 數字</a></h3>

<p>整數表示為一個數字順序。浮點數使用<samp>“.”</samp>作為一個十進制分隔符。這兩種類型的數字可以前置<samp>“-”</samp>表明一個負值。 
</p>

<p>有效整數的例子： </p>

<pre>
1221
0
-32
</pre>

<p>有效浮點數的例子： </p>

<pre>
294.42
-32032.6809e+10
148.00
</pre>

<p>一個整數可以在浮點上下文使用﹔它解釋為等值的浮點數。 </p>

<h3><a NAME="Hexadecimal_values" HREF="manual_toc.html#Hexadecimal_values">7.1.3 
十六進制值</a></h3>

<p><strong>MySQL</strong>支援十六進制值。在數字上下文，它們表現類似於一個整數(64位精度)。在字符串上下文，它們表現類似於一個二進制字符串，這裡每一對十六進制數字被變換為一個字符。 
</p>

<pre>mysql&gt; SELECT 0xa+0
       -&gt; 10
mysql&gt; select 0x5061756c;
       -&gt; Paul
</pre>

<p>十六進制字符串經常被ODBC使用，給出BLOB列的值。 </p>

<h3><a NAME="NULL_values" HREF="manual_toc.html#NULL_values">7.1.4<code> NULL</code>值</a></h3>

<p><code>NULL</code>值意味著“無數據”並且不同於例如數字類型的<code>0</code>為或字符串類型的空字符串。見<a HREF="manual_Problems.html#Problems_with_NULL">18.15 <code>NULL</code>值問題</a>。 </p>

<p>當使用文本文件導入或導出格式(<code>LOAD DATA INFILE</code>, <code>SELECT 
... INTO OUTFILE</code>)<code>時，NULL</code>可以用<code>\N</code>表示。見<a HREF="manual_Reference.html#LOAD_DATA">7.16<code> LOAD DATA INFILE</code>句法</a>。</p>

<h3><a NAME="Legal_names" HREF="manual_toc.html#Legal_names">7.1.5 
資料庫、表、索引、列和別名的命名</a></h3>

<p>資料庫、表、索引、列和別名的名字都遵守<strong>MySQL</strong>同樣的規則: 
</p>

<p><a NAME="IDX183"></a><a NAME="IDX185"></a>注意，從<strong>MySQL</strong>3.23.6開始規則改變了，此時我們引入了用'引用的標識符(資料庫、表和列命名)（如果你以ANSI模式運行，&quot;也將用於引用標識符）。 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>標識符</strong> </td>
    <td><strong>最大長度</strong> </td>
    <td><strong>允許的字符</strong> </td>
  </tr>
  <tr>
    <td>資料庫</td>
    <td>64</td>
    <td>在一個目錄名允許的任何字符，除了<code>/</code>. </td>
  </tr>
  <tr>
    <td>表</td>
    <td>64</td>
    <td>在文件名中允許的任何字符，除了<code>/</code>或<code>.</code> </td>
  </tr>
  <tr>
    <td>列</td>
    <td>64</td>
    <td>所有字符</td>
  </tr>
  <tr>
    <td>別名</td>
    <td>255</td>
    <td>所有字符</td>
  </tr>
</table>

<p>注意，除了以上，你在一個標識符中不能有ASCII(0)或ASCII(255)。 </p>

<p>注意，如果標識符是一個限制詞或包含特殊字符，當你使用它時，你必須總是用<code>`</code>引用它： 
</p>

<pre>SELECT * from `select` where `select`.id &gt; 100; 
</pre>

<p>在 MySQL的先前版本，命名規則如下： 

<ul>
  <li>一個名字可以包含來自當前字符集的數字字母的字符和<samp>“_”</samp>和<samp>“$”</samp>。預設字符集是ISO-8859-1 
    Latin1﹔這可以通過重新編譯<strong>MySQL</strong>來改變。見<a HREF="manual_Server.html#Character_sets">9.1.1 用於數據和排序的字符集</a>。</li>
  <li>一個名字可以以在一個名字中合法的任何字符開始。特別地，一個名字可以以一個數字開始(這不同於許多其他的資料庫系統!)。然而，一個名字不能<em>僅僅</em>由數字組成。 
  </li>
  <li>你不能在名字中使用<samp>“.”</samp>，因為它被用來擴充格式，你能用它引用列(見下面)。 
  </li>
</ul>

<p>建議你不使用像<code>1e</code>這樣的名字，因為一個表達式如<code>1e+1</code>是二義性的。它可以解釋為表達式<code>1e 
+ 1</code>或數字<code>1e+1</code>。 </p>

<p>在<strong>MySQL</strong>中，你能使用下列表格的任何一種引用列： </p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>列引用</strong> </td>
    <td><strong>含義</strong> </td>
  </tr>
  <tr>
    <td><code>col_name</code> </td>
    <td>來自於任意表的列<code>col_name</code>，用於包含該表的一個列的查詢中</td>
  </tr>
  <tr>
    <td><code>tbl_name.col_name</code> </td>
    <td>來自當前的資料庫的表<code>tbl_name</code>的列<code>col_name</code></td>
  </tr>
  <tr>
    <td><code>db_name.tbl_name.col_name</code> </td>
    <td>行列<code>col_name</code>從表格<code>tbl_name</code>資料庫<code>db_name</code>。這個形式在<strong>MySQL</strong>3.22或以後版本可用。 
    </td>
  </tr>
  <tr>
    <td><code>`column_name`</code> </td>
    <td>是一個關鍵詞或包含特殊字符的列。 </td>
  </tr>
</table>

<p>在一條語句的列引用中，你不必指定一個<code>tbl_name</code>或<code>db_name.tbl_name</code>前綴，除非引用會有二義性。例如，假定表<code>t1</code>和<code>t2</code>，每個均包含列<code>c</code>，並且你用一個使用<code>t1</code>和<code>t2</code>的<code>SELECT</code>語句檢索<code>c</code>。在這種情況下，<code>c</code>有二義性，因為它在使用表的語句中不是唯一的，因此你必須通過寫出<code>t1.c</code>或<code>t2.c</code>來指明你想要哪個表。同樣，如果你從資料庫<code>db1</code>中一個表<code>t</code>和在資料庫<code>db2</code>的一個表<code>t</code>檢索，你必須用<code>db1.t.col_name</code>和<code>db2.t.col_name</code>引用這些數據表的列。 
</p>

<p><a NAME="IDX186"></a>句法<code>.tbl_name</code>意味著在當前的資料庫中的表<code>tbl_name</code>，該句法為了ODBC的兼容性被接受，因為一些ODBC程式用一個<samp>“.”</samp>字符作為資料庫表名的前綴。 
</p>

<h4><a NAME="Name_case_sensitivity" HREF="manual_toc.html#Name_case_sensitivity">7.1.5.1 
名字的大小寫敏感性</a><a NAME="IDX190"></a> <a NAME="IDX191"></a> <a NAME="IDX192"></a> <a NAME="IDX193"></a> <a NAME="IDX194"></a> <a NAME="IDX195"></a> </h4>

<p>在<strong>MySQL</strong>中，資料庫和表對應於在那些目錄下的目錄和文件，因而，內在的作業系統的敏感性決定資料庫和表命名的大小寫敏感性。這意味著資料庫和表名在Unix上是區分大小寫的，而在Win32上忽略大小寫。 
</p>

<p><strong>注意：</strong>在Win32上，盡管資料庫和表名是忽略大小寫的，你不應該在同一個查詢中使用不同的大小寫來引用一個給定的資料庫和表。下列查詢將不工作，因為它作為<code>my_table</code>和作為<code>MY_TABLE</code>引用一個表：</p>

<pre>mysql&gt; SELECT * FROM my_table WHERE MY_TABLE.col=1;
</pre>

<p>列名在所有情況下都是忽略大小寫的。 </p>

<p>表的別名是區分大小寫的。下列查詢將不工作<code>，</code>: 
因為它用<code>a</code>和<code>A</code>引用別名：</p>

<pre>mysql&gt; SELECT col_name FROM tbl_name AS a
           WHERE a.col_name = 1 OR A.col_name = 2;
</pre>

<p>列的別名是忽略大小寫的。 </p>

<h2><a NAME="Variables" HREF="manual_toc.html#Variables">7.2 用戶變數</a></h2>

<p><strong>MySQL</strong>支援執行緒特定的變數，用<code>@variablename</code>句法。一個變數名可以由當前字符集的數字字母字符和<samp>“_”</samp>、<samp>“$”</samp>和<samp>“.”</samp>組成。預設字符集是ISO-8859-1 
Latin1﹔這可以通過重新編譯<strong>MySQL</strong>改變。見<a HREF="manual_Server.html#Character_sets">9.1.1 用於數據和排序的字符集</a>。 </p>

<p>變數不必被初始化。預設地，他們包含NULL並能儲存整數、實數或一個字符串值。當執行緒退出時，對於一個執行緒的所有變數自動地被釋放。 
</p>

<p>你可以用<code>SET</code>句法設置一個變數： </p>

<pre>SET @variable= { integer expression | real expression | string expression }
[,@variable= ...].
</pre>

<p>你也可以用<code>@variable:=expr</code>句法在一個表達式中設置一個變數： 
</p>

<pre>select @t1:=(@t2:=1)<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="1932596d2a">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>:=4,@t1,@t2,@t3;
+----------------------+------+------+------+
| @t1:=(@t2:=1)<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="5873182c6b">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>:=4 | @t1  | @t2  | @t3  |
+----------------------+------+------+------+
|                    5 |    5 |    1 |    4 |
+----------------------+------+------+------+
</pre>

<p>（這裡，我們不得不使用<code>:=</code>句法，因為<code>=</code>是為比較保留的）</p>

<h2><a NAME="Column_types" HREF="manual_toc.html#Column_types">7.3 列類型</a></h2>

<p><strong>MySQL</strong>支援大量的列類型，它可以被分為3類：數字類型、日期和時間類型以及字符串(字符)類型。本節首先給出可用類型的一個概述，並且總結每個列類型的儲存需求，然後提供每個類中的類型性質的更詳細的描述。概述有意簡化，更詳細的說明應該考慮到有關特定列類型的附加資訊，例如你能為其指定值的允許格式。 
</p>

<p>由<strong>MySQL</strong>支援的列類型列在下面。下列代碼字母用於描述中： 

<dl COMPACT="Column_types">
  <dt><code>M</code> </dt>
  <dd>指出最大的顯示尺寸。最大的合法的顯示尺寸是 255 。 </dd>
  <dt><code>D</code> </dt>
  <dd>適用於浮點類型並且指出跟隨在十進制小數點後的數碼的數量。最大可能的值是30，但是應該不大於<code>M</code>-2。 
  </dd>
</dl>

<p>方括號(<samp>“[”</samp>和<samp>“]”</samp>)指出可選的類型修飾符的部分。 
</p>

<p>注意，如果你指定一個了為<code>ZEROFILL</code>，<strong>MySQL</strong>將為該列自動地增加<code>UNSIGNED</code>屬性。 

<dl COMPACT="IDX196">
  <dt><code>TINYINT[(M)] [UNSIGNED] [ZEROFILL]</code> </dt>
  <dd><a NAME="IDX197"></a>一個很小的整數。有符號的範圍是<code>-128</code>到<code>127</code>，無符號的範圍是<code>0</code>到<code>255</code>。 
    <a NAME="IDX198"></a> </dd>
  <dt><code>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]</code> </dt>
  <dd>一個小整數。有符號的範圍是<code>-32768</code>到<code>32767</code>，無符號的範圍是<code>0</code>到<code>65535</code>。 
    <a NAME="IDX199"></a> </dd>
  <dt><code>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]</code> </dt>
  <dd>一個中等大小整數。有符號的範圍是<code>-8388608</code>到<code>8388607</code>，無符號的範圍是<code>0</code>到<code>16777215</code>。 
    <a NAME="IDX200"></a> </dd>
  <dt><code>INT[(M)] [UNSIGNED] [ZEROFILL]</code> </dt>
  <dd>一個正常大小整數。有符號的範圍是<code>-2147483648</code>到<code>2147483647</code>，無符號的範圍是<code>0</code>到<code>4294967295</code>。 
    <a NAME="IDX201"></a> </dd>
  <dt><code>INTEGER[(M)] [UNSIGNED] [ZEROFILL]</code> </dt>
  <dd>這是<code>INT</code>的一個同義詞。 <a NAME="IDX202"></a> </dd>
  <dt><code>BIGINT[(M)] [UNSIGNED] [ZEROFILL]</code> </dt>
  <dd>一個大整數。有符號的範圍是<code>-9223372036854775808</code>到<code>9223372036854775807</code>，無符號的範圍是<code>0</code>到<code>18446744073709551615</code>。注意，所有算術運算用有符號的<code>BIGINT</code>或<code>DOUBLE</code>值完成，因此你不應該使用大於<code>9223372036854775807</code>（63位)的有符號大整數，除了位函數！注意，當兩個參數是<code>INTEGER</code>值時，<code>-</code>、<code>+</code>和<code>*</code>將使用<code>BIGINT</code>運算！這意味著如果你乘2個大整數(或來自於返回整數的函數)，如果結果大於<code>9223372036854775807</code>，你可以得到意外的結果。<a NAME="IDX204"></a>一個浮點數字，不能是無符號的，對一個單精度浮點數，<code>其精度可以</code>是<code>&lt;=24</code>，對一個雙精度浮點數，是在25 
    和53之間，這些類型如<code>FLOAT</code>和<code>DOUBLE</code>類型馬上在下面描述。<code>FLOAT(X)</code>有對應的<code>FLOAT</code>和<code>DOUBLE</code>相同的範圍，但是顯示尺寸和小數位數是未定義的。在<strong>MySQL</strong>3.23中，這是一個真正的浮點值。在更早的<strong>MySQL</strong>版本中，<code>FLOAT(precision)</code>總是有2位小數。該句法為了ODBC兼容性而提供。 
    <a NAME="IDX207"></a> <a NAME="IDX208"></a> <a NAME="IDX209"></a> </dd>
  <dt><code>FLOAT[(M,D)] [ZEROFILL]</code> </dt>
  <dd>一個小(單精密)浮點數字。不能無符號。允許的值是<code>-3.402823466E+38</code>到<code>-1.175494351E-38</code>，<code>0</code> 
    和<code>1.175494351E-38</code>到<code>3.402823466E+38</code>。M是顯示寬度而D是小數的位數。沒有參數的<code>FLOAT</code>或有&lt;24 
    的一個參數表示一個單精密浮點數字。<a NAME="IDX210"></a> <a NAME="IDX211"></a> 
  </dd>
  <dt><code>DOUBLE[(M,D)] [ZEROFILL]</code> </dt>
  <dd>一個正常大小(雙精密)浮點數字。不能無符號。允許的值是<code>-1.7976931348623157E+308</code>到<code>-2.2250738585072014E-308</code>、 
    <code>0</code>和<code>2.2250738585072014E-308</code>到<code>1.7976931348623157E+308</code>。M是顯示寬度而D是小數位數。沒有一個參數的<code>DOUBLE</code>或<code>FLOAT(X)</code>（25 
    &lt; = X &lt; = 53）代表一個雙精密浮點數字。 <a NAME="IDX212"></a> <a NAME="IDX213"></a> </dd>
  <dt><code>DOUBLE PRECISION[(M,D)] [ZEROFILL]</code> </dt>
  <dd>　</dd>
  <dt><code>REAL[(M,D)] [ZEROFILL]</code> </dt>
  <dd>這些是<code>DOUBLE</code>同義詞。 <a NAME="IDX214"></a> </dd>
  <dt><code>DECIMAL[(M[,D])] [ZEROFILL]</code> </dt>
  <dd>一個未壓縮(unpack)的浮點數字。不能無符號。行為如同一個<code>CHAR</code>列：“未壓縮”意味著數字作為一個字符串被儲存，值的每一位使用一個字符。小數點，並且對於負數，<samp>“-”</samp>符號不在M中計算。如果<code>D</code>是0，值將沒有小數點或小數部分。<code>DECIMAL</code>值的最大範圍與<code>DOUBLE</code>相同，但是對一個給定的<code>DECIMAL</code>列，實際的範圍可以通過<code>M</code>和<code>D</code>的選擇被限制。如果<code>D</code>被省略，它被設置為0。如果<code>M</code>被省掉，它被設置為10。注意，在<strong>MySQL</strong>3.22裡，<code>M</code>參數包括符號和小數點。 
    <a NAME="IDX215"></a> </dd>
  <dt><code>NUMERIC(M,D) [ZEROFILL]</code> </dt>
  <dd>這是<code>DECIMAL</code>的一個同義詞。 <a NAME="IDX216"></a> </dd>
  <dt><code>DATE</code> </dt>
  <dd>一個日期。支援的範圍是<code>'1000-01-01'</code>到<code>'9999-12-31'</code>。<strong>MySQL</strong>以<code>'YYYY-MM-DD'</code>格式來顯示<code>DATE</code>值，但是允許你使用字符串或數字把值賦給<code>DATE</code>列。 
    <a NAME="IDX217"></a> </dd>
  <dt><code>DATETIME</code> </dt>
  <dd>一個日期和時間組合。支援的範圍是<code>'1000-01-01 00:00:00'</code>到<code>'9999-12-31 
    23:59:59'</code>。<strong>MySQL</strong>以<code>'YYYY-MM-DD HH:MM:SS'</code>格式來顯示<code>DATETIME</code>值，但是允許你使用字符串或數字把值賦給<code>DATETIME</code>的列。 
    <a NAME="IDX218"></a> </dd>
  <dt><code>TIMESTAMP[(M)]</code> </dt>
  <dd>一個時間戳記。範圍是<code>'1970-01-01 00:00:00'</code>到<code>2037</code>年的某時。<strong>MySQL</strong>以<code>YYYYMMDDHHMMSS</code>、<code>YYMMDDHHMMSS</code>、<code>YYYYMMDD</code>或<code>YYMMDD</code>格式來顯示<code>TIMESTAMP</code>值，取決於是否<code>M</code>是<code>14</code>（或省略)、<code>12</code>、<code>8</code>或<code>6</code>，但是允許你使用字符串或數字把值賦給<code>TIMESTAMP</code>列。一個<code>TIMESTAMP</code>列對於記錄一個<code>INSERT</code>或<code>UPDATE</code>操作的日期和時間是有用的，因為如果你不自己給它賦值，它自動地被設置為最近操作的日期和時間。你以可以通過賦給它一個<code>NULL</code>值設置它為當前的日期和時間。見<a HREF="manual_Reference.html#Date_and_time_types">7.3.6 日期和時間類型</a>。 <a NAME="IDX219"></a> </dd>
  <dt><code>TIME</code> </dt>
  <dd>一個時間。範圍是<code>'-838:59:59'</code>到<code>'838:59:59'</code>。<strong>MySQL</strong>以<code>'HH:MM:SS'</code>格式來顯示<code>TIME</code>值，但是允許你使用字符串或數字把值賦給<code>TIME</code>列。 
    <a NAME="IDX220"></a> </dd>
  <dt><code>YEAR[(2|4)]</code> </dt>
  <dd>一個2或4位數字格式的年(預設是4位)。允許的值是<code>1901</code>到<code>2155</code>，和<code>0000</code>（4位年格式），如果你使用2位，1970-2069( 
    70-69)。<strong>MySQL</strong>以<code>YYYY</code>格式來顯示<code>YEAR</code>值，但是允許你把使用字符串或數字值賦給<code>YEAR</code>列。（<code>YEAR</code>類型在<strong>MySQL</strong>3.22中是新類型。）<a NAME="IDX221"></a> <a NAME="IDX222"></a> <a NAME="IDX223"></a> <a NAME="IDX224"></a> </dd>
  <dt><code>CHAR(M) [BINARY]</code> </dt>
  <dd>一個定長字符串，當儲存時，總是是用空格填滿右邊到指定的長度。<code>M</code>的範圍是1 
    ∼ 255個字符。當值被檢索時，空格尾部被刪除。<code>CHAR</code>值根據預設字符集以大小寫不區分的方式排序和比較，除非<code>給出BINARY</code>關鍵詞。<code>NATIONAL 
    CHAR</code>（短形式<code>NCHAR</code>)是ANSI SQL的方式來定義CHAR列應該使用預設字符集。這是<code>MySQL</code>的預設。<code>CHAR</code>是<code>CHARACTER</code>的一個縮寫。 
    <a NAME="IDX225"></a> <a NAME="IDX226"></a> <a NAME="IDX227"></a> </dd>
  <dt><code>[NATIONAL] VARCHAR(M) [BINARY]</code> </dt>
  <dd>一個變長字符串。注意：當值被儲存時，尾部的空格被刪除(這不同於ANSI 
    SQL規範)。M的範圍是1 ∼ 255個字符。 <code>VARCHAR</code>值根據預設字符集以大小寫不區分的方式排序和比較，除非<code>給出BINARY</code>關鍵詞值。見<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱式列指定變化</a>。 <code>VARCHAR</code>是<code>CHARACTER 
    VARYING</code>一個縮寫。 <a NAME="IDX228"></a> <a NAME="IDX229"></a> </dd>
  <dt><code>TINYBLOB</code> </dt>
  <dd>　</dd>
  <dt><code>TINYTEXT</code> </dt>
  <dd>一個<code>BLOB</code>或<code>TEXT</code>列，最大長度為255(2^8-1)個字符。見<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱式列指定變化</a>。 <a NAME="IDX230"></a> <a NAME="IDX231"></a> </dd>
  <dt><code>BLOB</code> </dt>
  <dd>　</dd>
  <dt><code>TEXT</code> </dt>
  <dd>一個<code>BLOB</code>或<code>TEXT</code>列，最大長度為65535(2^16-1)個字符。見<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱式列指定變化</a>。 <a NAME="IDX232"></a> <a NAME="IDX233"></a> </dd>
  <dt><code>MEDIUMBLOB</code> </dt>
  <dd>　</dd>
  <dt><code>MEDIUMTEXT</code> </dt>
  <dd>一個<code>BLOB</code>或<code>TEXT</code>列，最大長度為16777215(2^24-1)個字符。見<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱式列指定變化</a>。 <a NAME="IDX234"></a> <a NAME="IDX235"></a> </dd>
  <dt><code>LONGBLOB</code> </dt>
  <dd>　</dd>
  <dt><code>LONGTEXT</code> </dt>
  <dd>一個<code>BLOB</code>或<code>TEXT</code>列，最大長度為4294967295(2^32-1)個字符。見<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱式列指定變化</a> <a NAME="IDX236"></a> </dd>
  <dt><code>ENUM('value1','value2',...)</code> </dt>
  <dd>枚舉。一個僅有一個值的字符串對像，這個值式選自與值列表<code>'value1'</code>、<code>'value2'</code>, 
    <code>...</code>,或<code>NULL</code>。一個<code>ENUM</code>最多能有65535不同的值。 
    <a NAME="IDX237"></a> </dd>
  <dt><code>SET('value1','value2',...)</code> </dt>
  <dd>一個集合。能有零個或多個值的一個字符串對像，其中每一個必須從值列表<code>'value1'</code>, 
    <code>'value2'</code>, <code>...</code>選出。一個<code>SET</code>最多能有64個成員。 
  </dd>
</dl>

<h3><a NAME="Storage_requirements" HREF="manual_toc.html#Storage_requirements">7.3.1 
列類型儲存需求</a></h3>

<p>對於每個由<strong>MySQL</strong>支援的列類型的儲存需求在下面按類列出。 
</p>

<h3>7.3.2 數字類型</h3>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>列類型</strong> </td>
    <td><strong>需要的儲存量</strong> </td>
  </tr>
  <tr>
    <td><code>TINYINT</code> </td>
    <td>1 字節</td>
  </tr>
  <tr>
    <td><code>SMALLINT</code> </td>
    <td>2 個字節</td>
  </tr>
  <tr>
    <td><code>MEDIUMINT</code> </td>
    <td>3 個字節</td>
  </tr>
  <tr>
    <td><code>INT</code> </td>
    <td>4 個字節</td>
  </tr>
  <tr>
    <td><code>INTEGER</code> </td>
    <td>4 個字節</td>
  </tr>
  <tr>
    <td><code>BIGINT</code> </td>
    <td>8 個字節</td>
  </tr>
  <tr>
    <td><code>FLOAT(X)</code> </td>
    <td>4 如果 X &lt; = 24 或 8 如果 25 &lt; = X &lt; = 53</td>
  </tr>
  <tr>
    <td><code>FLOAT</code> </td>
    <td>4 個字節</td>
  </tr>
  <tr>
    <td><code>DOUBLE</code> </td>
    <td>8 個字節</td>
  </tr>
  <tr>
    <td><code>DOUBLE PRECISION</code> </td>
    <td>8 個字節</td>
  </tr>
  <tr>
    <td><code>REAL</code> </td>
    <td>8 個字節</td>
  </tr>
  <tr>
    <td><code>DECIMAL(M,D)</code> </td>
    <td><code>M</code>字節(<code>D</code>+2 , 如果<code>M &lt; D</code>) </td>
  </tr>
  <tr>
    <td><code>NUMERIC(M,D)</code> </td>
    <td><code>M</code>字節(<code>D</code>+2 , 如果<code>M &lt; D</code>) </td>
  </tr>
</table>

<h3>7.3.3 日期和時間類型</h3>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>列類型</strong> </td>
    <td><strong>需要的儲存量</strong> </td>
  </tr>
  <tr>
    <td><code>DATE</code> </td>
    <td>3 個字節</td>
  </tr>
  <tr>
    <td><code>DATETIME</code> </td>
    <td>8 個字節</td>
  </tr>
  <tr>
    <td><code>TIMESTAMP</code> </td>
    <td>4 個字節</td>
  </tr>
  <tr>
    <td><code>TIME</code> </td>
    <td>3 個字節</td>
  </tr>
  <tr>
    <td><code>YEAR</code> </td>
    <td>1 字節</td>
  </tr>
</table>

<h3>7.3.4 串類型</h3>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>列類型</strong> </td>
    <td><strong>需要的儲存量</strong> </td>
  </tr>
  <tr>
    <td><code>CHAR(M)</code> </td>
    <td><code>M</code>字節，<code>1 &lt;= M &lt;= 255</code> </td>
  </tr>
  <tr>
    <td><code>VARCHAR(M)</code> </td>
    <td><code>L</code>+1 字節, 在此<code>L &lt;= M</code>和<code>1 &lt;= M &lt;= 255</code> 
    </td>
  </tr>
  <tr>
    <td><code>TINYBLOB</code>, <code>TINYTEXT</code> </td>
    <td><code>L</code>+1 字節, 在此<code>L</code>&lt; 2 ^ 8</td>
  </tr>
  <tr>
    <td><code>BLOB</code>, <code>TEXT</code> </td>
    <td><code>L</code>+2 字節, 在此<code>L</code>&lt; 2 ^ 16</td>
  </tr>
  <tr>
    <td><code>MEDIUMBLOB</code>, <code>MEDIUMTEXT</code> </td>
    <td><code>L</code>+3 字節, 在此<code>L</code>&lt; 2 ^ 24</td>
  </tr>
  <tr>
    <td><code>LONGBLOB</code>, <code>LONGTEXT</code> </td>
    <td><code>L</code>+4 字節, 在此<code>L</code>&lt; 2 ^ 32</td>
  </tr>
  <tr>
    <td><code>ENUM('value1','value2',...)</code> </td>
    <td>1 或 2 個字節, 取決於枚舉值的數目(最大值65535）</td>
  </tr>
  <tr>
    <td><code>SET('value1','value2',...)</code> </td>
    <td>1，2，3，4或8個字節, 取決於集合成員的數量(最多64個成員）</td>
  </tr>
</table>

<p><code>VARCHAR</code>和<code>BLOB</code>和<code>TEXT</code>類型是變長類型，對於其儲存需求取決於列值的實際長度(在前面的表格以 <code>L</code>表示)，而不是取決於類型的最大可能尺寸。例如，一個<code>VARCHAR(10)</code>列能保存最大長度為10個字符的一個字符串，實際的儲存需要是字符串的長度(<code>L</code>)，加上1個字節以記錄字符串的長度。對於字符串<code>'abcd'</code>，<code>L</code>是4而儲存要求是5個字節。 
</p>

<p><code>BLOB</code>和<code>TEXT</code>類型需要1，2，3或4個字節來記錄列值的長度，這取決於類型的最大可能長度。 
</p>

<p>如果一個表包括任何變長的列類型，記錄格式將也是變長的。注意，當一個表被創建時，<strong>MySQL</strong>可能在某些條件下將一個列從一個變長類型改變為一個定長類型或相反。見<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱式列指定變化</a>。 </p>

<p>一個<code>ENUM</code>對像的大小由不同枚舉值的數量決定。1字節被用於枚舉，最大到255個可能的值﹔2個字節用於枚舉，最大到65535 
值。 </p>

<p>一個<code>SET</code>對像的大小由不同的集合成員的數量決定。如果集合大小是<code>N</code>，對像占據<code>(N+7)/8</code>個字節，四捨五入為1，2，3，4或8 
個字節。一個<code>SET</code>最多能有64個成員。 </p>

<h3><a NAME="Numeric_types" HREF="manual_toc.html#Numeric_types">7.3.5 數字類型</a></h3>

<p><strong>MySQL</strong>支援所有的ANSI/ISO SQL92的數字類型。這些類型包括準確數字的數據類型(<code>NUMERIC</code>, 
<code>DECIMAL</code>, <code>INTEGER</code>,和<code>SMALLINT</code>)，也包括近似數字的數據類型(<code>FLOAT</code>, 
<code>REAL</code>,和<code>DOUBLE PRECISION</code>)。關鍵詞<code>INT</code>是<code>INTEGER</code>的一個同義詞，而關鍵詞<code>DEC</code>是<code>DECIMAL</code>一個同義詞。 
</p>

<p><code>NUMERIC</code>和<code>DECIMAL</code>類型被<strong>MySQL</strong>實現為同樣的類型，這在SQL92標準允許。他們被用於保存值，該值的準確精度是極其重要的值，例如與金錢有關的數據。當聲明一個類是這些類型之一時，精度和規模的能被(並且通常是)指定﹔例如：</p>

<pre>salary DECIMAL(9,2) </pre>

<p>在這個例子中，<code>9</code>(<code>precision</code>)代表將被用於儲存值的總的小數位數，而<code>2</code>(<code>scale</code>)代表將被用於儲存小數點後的位數。因此，在這種情況下，能被儲存在<code>salary</code>列中的值的範圍是從<code>-9999999.99</code>到<code>9999999.99</code>。在ANSI/ISO 
SQL92中，句法<code>DECIMAL(p)</code>等價於<code>DECIMAL(p,0)</code>。同樣，句法<code>DECIMAL</code>等價於<code>DECIMAL(p,0)</code>，這裡實現被允許決定值<code>p</code>。<strong>MySQL</strong>當前不支援<code>DECIMAL</code>/<code>NUMERIC</code>數據類型的這些變種形式的任一種。這一般說來不是一個嚴重的問題，因為這些類型的主要益處得自於明顯地控制精度和規模的能力。 
</p>

<p><code>DECIMAL</code>和<code>NUMERIC</code>值作為字符串儲存，而不是作為二進制浮點數，以便保存那些值的小數精度。一個字符用於值的每一位、小數點(如果<code>scale</code>&gt;0)和<samp>“-”</samp>符號(對於負值)。如果<code>scale</code>是0，<code>DECIMAL</code>和<code>NUMERIC</code>值不包含小數點或小數部分。 
</p>

<p><code>DECIMAL</code>和<code>NUMERIC</code>值得最大的範圍與<code>DOUBLE</code>一樣，但是對於一個給定的<code>DECIMAL</code>或<code>NUMERIC</code>列，實際的範圍可由制由給定列的<code>precision</code>或<code>scale</code>限制。當這樣的列賦給了小數點後面的位超過指定<code>scale</code>所允許的位的值，該值根據<code>scale</code>四捨五入。當一個<code>DECIMAL</code>或<code>NUMERIC</code>列被賦給了其大小超過指定(或預設的）<code>precision</code>和<code>scale</code>隱含的範圍的值，<strong>MySQL</strong>儲存表示那個範圍的相應的端點值。 
</p>

<p>作為對ANSI/ISO SQL92標準的擴展，<strong>MySQL</strong>也支援上表所列的整型類型<code>TINYINT</code>、MEDIUMINT和<code>BIGINT</code>。另一個擴展是<strong>MySQL</strong>支援可選地指定一個整型值顯示的寬度，用括號跟在基本關鍵詞之後(例如，<code>INT(4)</code>)。這個可選的寬度指定被用於其寬度小於列指定寬度的值得左填補顯示，但是不限制能在列中被儲存的值的範圍，也不限制值將被顯示的位數，其寬度超過列指定的寬度。當與可選的擴展屬性<code>ZEROFILL</code>一起使用時，預設的空格填補用零代替。例如，對於聲明為<code>INT(5) 
ZEROFILL</code>的列，一個為4的值作為<code>00004</code>被檢索。注意，如果你在一個整型列儲存超過顯示寬度的更大值，當<strong>MySQL</strong>對於某些複雜的聯結(join)產生臨時表時，你可能會遇到問題，因為在這些情況下，<strong>MySQL</strong>相信數據確實適合原來的列寬度。 
</p>

<p>所有的整型類型可以有一個可選(非標準的)屬性<code>UNSIGNED</code>。當你想要在列中僅允許正數並且你需要一個稍大一點的列範圍，可以使用無符號值。 
</p>

<p><code>FLOAT</code>類型被用來標示近似數字的數據類型。ANSI/ISO SQL92標準允許一個可選的精度說明(但不是指數的範圍)，跟在關鍵詞<code>FLOAT</code>後面的括號內位數。<strong>MySQL</strong>實現也支援這個可選的精度說明。當關鍵詞<code>FLOAT</code>被用於一個列類型而沒有精度說明時，<strong>MySQL</strong>使用4個字節儲存值。一個變種的句法也被支援，在<code>FLOAT</code>關鍵詞後面的括號給出2個數字。用這個選項，第一個數字繼續表示在字節計算的值儲存需求，而第二個數字指定要被儲存的和顯示跟隨小數點後的位數(就像<code>DECIMAL</code>和<code>NUMERIC</code>)。當<strong>MySQL</strong>要求為這樣一個列，一個小數點後的小數位超過列指定的值，儲存值時，該值被四捨五入，去掉額外的位。 
</p>

<p><code>REAL</code>和<code>DOUBLE PRECISION</code>類型不接受精度說明。作為對 
ANSI/ISO SQL92 標準的擴展，<strong>MySQL</strong>識別出<code>DOUBLE</code>作為<code>DOUBLE 
PRECISION</code>類型的一個同義詞。與<code>REAL</code>精度比用於<code>DOUBLE 
PRECISION</code>的更小的標準要求相反，<strong>MySQL</strong>實現了兩種，作為8字節雙精度浮點值(當運行不是“Ansi模式”時)。為了最大的移植性，近似數字的數據值的儲存所需代碼應該使用沒有精度或小數位數說明的<code>FLOAT</code>或<code>DOUBLE 
PRECISION</code>。 </p>

<p>當要求在數字的列儲存超出該列類型允許的範圍的值時，<strong>MySQL</strong>剪切該值到範圍內的正確端點值並且儲存剪切後的結果值。 
</p>

<p>例如，一個<code>INT</code>列的範圍是<code>-2147483648</code>到<code>2147483647</code>。如果你試圖插入<code>-9999999999</code>到一個<code>INT</code>列中，值被剪切到範圍的低部端點，並儲存<code>-2147483648</code>。同樣，如果你試圖插入<code>9999999999</code>，<code>2147483647</code>被儲存。 
</p>

<p>如果<code>INT</code>列是<code>UNSIGNED</code>，列的範圍的大小是相同的，但是它的端點移到<code>了0</code>和<code>4294967295</code>。如果你試圖儲存<code>-9999999999</code>和<code>9999999999</code>，在列被儲存的值變為<code>0</code>和<code>4294967296</code>。 
</p>

<p>對於<code>ALTER TABLE</code>、<code>LOAD DATA INFILE</code>、<code>UPDATE</code>和多行<code>INSERT</code>語句，由於剪切所發生的變換作為“警告”被報告。 
</p>

<h3><a NAME="Date_and_time_types" HREF="manual_toc.html#Date_and_time_types">7.3.6 
日期和時間類型</a></h3>

<p>日期和時間類型是<code>DATETIME</code>、<code>DATE</code>、<code>TIMESTAMP</code>、<code>TIME</code>和<code>YEAR</code>。這些的每一個都有合法值的一個範圍，而“零”當你指定確實不合法的值時被使用。注意，MySQL允許你儲存某個“不嚴格地”合法的日期值，例如<code>1999-11-31</code>，原因我們認為它是應用程式的責任來處理日期檢查，而不是SQL伺服器。為了使日期檢查更“快”，<strong>MySQL</strong>僅檢查月份在0-12的範圍，天在0-31的範圍。上述範圍這樣被定義是因為<strong>MySQL</strong>允許你在一個<code>DATE</code>或<code>DATETIME</code>列中儲存日期，這裡的天或月是零。這對儲存你不知道準確的日期的一個生日的應用程式來說是極其有用的，在這種情況下，你簡單地儲存日期像<code>1999-00-00</code>或<code>1999-01-00</code>。（當然你不能期望從函數如<code>DATE_SUB()</code>或<code>DATE_ADD()</code>得到類似以這些日期的正確值)。 
</p>

<p>當用日期和時間工作時，這裡是的一些要記住的一般考慮： 

<ul>
  <li><strong>MySQL</strong>對一個給定的日期或時間類型以標準的格式檢索，但是它試圖為你提供的值解釋成許多格式(例如，當你指定一個值被賦給或與比較一個日期或時間類型時)，但是只支援有在下列小節描述的格式。期望你提供合法的值，並且如果你以其他格式使用這些值，可能造成無法預料的結果。 
  </li>
  <li>盡管<strong>MySQL</strong>試圖以多種格式解釋值，但它總是期望日期值的年份部分在最左面，日期必須以年-月-日的順序給出(例如，<code>'98-09-04'</code>)，而不是以其他地方常用的月-日-年或日-月-年的次序(例如，<code>'09-04-98'</code>、'04-09-98')。 
  </li>
  <li>如果一個值在數字的上下文環境中被使用，<strong>MySQL</strong>自動變換一個日期或時間類型值到一個數字，反過來也如此。 
  </li>
  <li>當<strong>MySQL</strong>遇到一個日期或時間類型的值超出範圍或對給類型不合法(見本節的開始)時，它將該類型的值變換到“零”值。（例外的是超出範圍的<code>TIME</code>值被剪切為適當的<code>TIME</code>範圍端點值。)下表顯示對每種類型的“零”值的格式： 
    <table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
      <tr>
        <td><strong>列類型</strong> </td>
        <td><strong>“零”值</strong> </td>
      </tr>
      <tr>
        <td><code>DATETIME</code> </td>
        <td><code>'0000-00-00 00:00:00'</code> </td>
      </tr>
      <tr>
        <td><code>DATE</code> </td>
        <td><code>'0000-00-00'</code> </td>
      </tr>
      <tr>
        <td><code>TIMESTAMP</code> </td>
        <td><code>00000000000000</code>（長度取決於顯示尺寸）</td>
      </tr>
      <tr>
        <td><code>TIME</code> </td>
        <td><code>'00:00:00'</code> </td>
      </tr>
      <tr>
        <td><code>YEAR</code> </td>
        <td><code>0000</code> </td>
      </tr>
    </table>
  </li>
  <li>“零”值是特殊的，但是你能使用在表中顯示的值來明顯地儲存或引用他們。你也可以使用值<code>'0'</code>或<code>0</code>做到, 
    這更容易寫。 </li>
  <li>在<strong>MyODBC</strong> 2.50.12和以上版本中，由<strong>MyODBC</strong>使用的“零”日期或時間值被自動變換到<code>NULL</code>，因為ODBC不能處理這樣的值。 
  </li>
</ul>

<h4><a NAME="Y2K_issues" HREF="manual_toc.html#Y2K_issues">7.3.6.1 Y2K問題和日期類型</a></h4>

<p><strong>MySQL</strong>本身Y2K安全的(見<a HREF="manual_Introduction.html#Year_2000_compliance">1.6 2000年一致性</a>)，但是呈交給<strong>MySQL</strong>的輸入值可能不是。一個包含2位年份值的任何輸入是由二義性的，因為世紀是未知的。這樣的值必須被解釋成4位形式，因為<strong>MySQL</strong>內部使用4位儲存年份。 
</p>

<p>對於<code>DATETIME</code>, <code>DATE</code>, <code>TIMESTAMP</code>和<code>YEAR</code>類型，<strong>MySQL</strong>使用下列規則的解釋二義性的年份值： 

<ul>
  <li>在範圍<code>00-69</code>的年值被變換到<code>2000-2069</code>。 </li>
  <li>在範圍<code>70-99</code>的年值被變換到<code>1970-1999</code>。</li>
</ul>

<p>記得這些規則僅僅提供對於你數據的含義的合理猜測。如果<strong>MySQL</strong>使用的啟發規則不產生正確的值，你應該提供無二義的包含4位年值的輸入。 
</p>

<h4><a NAME="DATETIME" HREF="manual_toc.html#DATETIME">7.3.6.2 <code>DATETIME</code>, <code>DATE</code>和<code>TIMESTAMP</code>類型</a></h4>

<p><code>DATETIME</code>, <code>DATE</code>和<code>TIMESTAMP</code>類型是相關的。本節描述他們的特徵，他們是如何類似的而又不同的。 
</p>

<p><code>DATETIME</code>類型用在你需要同時包含日期和時間資訊的值時。<strong>MySQL</strong>檢索並且以<code>'YYYY-MM-DD 
HH:MM:SS'</code>格式顯示<code>DATETIME</code>值，支援的範圍是<code>'1000-01-01 
00:00:00'</code>到<code>'9999-12-31 23:59:59'</code>。（“支援”意味著盡管更早的值可能工作，但不能保証他們可以。）</p>

<p><code>DATE</code>類型用在你僅需要日期值時，沒有時間部分。<strong>MySQL</strong>檢索並且以<code>'YYYY-MM-DD'</code>格式顯示<code>DATE</code>值，支援的範圍是<code>'1000-01-01'</code>到<code>'9999-12-31'</code>。 
</p>

<p><code>TIMESTAMP</code>列類型提供一種類型，你可以使用它自動地用當前的日期和時間標記<code>INSERT</code>或<code>UPDATE</code>的操作。如果你有多個<code>TIMESTAMP</code>列，只有第一個自動更新。 
</p>

<p>自動更新第一個<code>TIMESTAMP</code>列在下列任何條件下發生： 

<ul>
  <li>列沒有明確地在一個<code>INSERT</code>或<code>LOAD DATA INFILE</code>語句中指定。 
  </li>
  <li>列沒有明確地在一個<code>UPDATE</code>語句中指定且一些另外的列改變值。（注意一個<code>UPDATE</code>設置一個列為它已經有的值，這將不引起<code>TIMESTAMP</code>列被更新，因為如果你設置一個列為它當前的值，<strong>MySQL</strong>為了效率而忽略更改。）</li>
  <li>你明確地設定<code>TIMESTAMP</code>列為<code>NULL</code>. </li>
</ul>

<p>除第一個以外的<code>TIMESTAMP</code>列也可以設置到當前的日期和時間，只要將列設為<code>NULL</code>，或<code>NOW()</code>。 
</p>

<p>通過明確地設置希望的值，你可以設置任何<code>TIMESTAMP</code>列為不同於當前日期和時間的值，即使對第一個<code>TIMESTAMP</code>列也是這樣。例如，如果，當你創建一個行時，你想要一個<code>TIMESTAMP</code>被設置到當前的日期和時間，但在以後無論何時行被更新時都不改變，你可以使用這個屬性： 

<ul>
  <li>讓<strong>MySQL</strong>在行被創建時設置列，這將初始化它為當前的日期和時間。 
  </li>
  <li>當你執行隨後的對該行中其他列的更改時，明確設定<code>TIMESTAMP</code>列為它的當前值。 
  </li>
</ul>

<p>另一方面，你可能發現，當行被創建並且遠離隨後的更改時，很容易用一個你用<code>NOW()</code>初始化的<code>DATETIME</code>列。 
</p>

<p><code>TIMESTAMP</code>值可以從1970的某時的開始一直到2037年，精度為一秒，其值作為數字顯示。 
</p>

<p>在<strong>MySQL</strong>檢索並且顯示<code>TIMESTAMP</code>值取決於顯示尺寸的格式如下表。“完整”<code>TIMESTAMP</code>格式是14位，但是<code>TIMESTAMP</code>列可以用更短的顯示尺寸創造： 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>列類型</strong> </td>
    <td><strong>顯示格式</strong> </td>
  </tr>
  <tr>
    <td><code>TIMESTAMP(14)</code> </td>
    <td><code>YYYYMMDDHHMMSS</code> </td>
  </tr>
  <tr>
    <td><code>TIMESTAMP(12)</code> </td>
    <td><code>YYMMDDHHMMSS</code> </td>
  </tr>
  <tr>
    <td><code>TIMESTAMP(10)</code> </td>
    <td><code>YYMMDDHHMM</code> </td>
  </tr>
  <tr>
    <td><code>TIMESTAMP(8)</code> </td>
    <td><code>YYYYMMDD</code> </td>
  </tr>
  <tr>
    <td><code>TIMESTAMP(6)</code> </td>
    <td><code>YYMMDD</code> </td>
  </tr>
  <tr>
    <td><code>TIMESTAMP(4)</code> </td>
    <td><code>YYMM</code> </td>
  </tr>
  <tr>
    <td><code>TIMESTAMP(2)</code> </td>
    <td><code>YY</code> </td>
  </tr>
</table>

<p>所有的<code>TIMESTAMP</code>列都有同樣的儲存大小，不考慮顯示尺寸。最常見的顯示尺寸是6、8、12、和14。你可以在表創建時間指定一個任意的顯示尺寸，但是值0或比14大被強制到14。在從1∼13範圍的奇數值尺寸被強制為下一個更大的偶數。 
</p>

<p>使用一個常用的格式集的任何一個，你可以指定<code>DATETIME</code>、<code>DATE</code>和<code>TIMESTAMP</code>值： 

<ul>
  <li><code>'YYYY-MM-DD HH:MM:SS'</code>或<code>'YY-MM-DD HH:MM:SS'</code>格式的一個字符串。允許一種“寬松”的語法--任何標點可用作在日期部分和時間部分之間的分隔符。例如，<code>'98-12-31 
    11:30:45'</code>、<code>'98.12.31 11+30+45'</code>、<code>'98/12/31 11*30*45'</code>和<code><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="ac8b9594ec9d9e">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>@31 
    11^30^45'</code>是等價的。 </li>
  <li><code>'YYYY-MM-DD'</code>或<code>'YY-MM-DD'</code>格式的一個字符串。允許一種“寬松”的語法。例如，<code>'98-12-31'</code>, 
    <code>'98.12.31'</code>, <code>'98/12/31'</code>和<code><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="8bacb2b3cbbab9">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>@31'</code>是等價的。 </li>
  <li><code>'YYYYMMDDHHMMSS'</code>或<code>'YYMMDDHHMMSS'</code>格式的沒有任何分隔符的一個字符串，例如，<code>'19970523091528'</code>和<code>'970523091528'</code>被解釋為<code>'1997-05-23 
    09:15:28'</code>，但是<code>'971122459015'</code>是不合法的(它有毫無意義的分鐘部分)且變成<code>'0000-00-00 
    00:00:00'</code>。 </li>
  <li><code>'YYYYMMDD'</code>或<code>'YYMMDD'</code>格式的沒有任何分隔符的一個字符串，如果字符串認為是一個日期。例如，<code>'19970523'</code>和<code>'970523'</code>被解釋作為<code>'1997-05-23'</code>，但是<code>'971332'</code>是不合法的( 
    它有無意義的月和天部分)且變成<code>'0000-00-00'</code>。 </li>
  <li><code>YYYYMMDDHHMMSS</code>或<code>YYMMDDHHMMSS</code>格式的一個數字，如果數字認為是一個日期。例如，<code>19830905132800</code>和<code>830905132800</code>被解釋作為<code>'1983-09-05 
    13:28:00'</code>。 </li>
  <li><code>YYYYMMDD</code>或<code>YYMMDD</code>格式的一個數字，如果數字認為是一個日期。例如，<code>19830905</code>和<code>830905</code>被解釋作為<code>'1983-09-05'</code>。 
  </li>
  <li>一個返回值可以在一個<code>DATETIME</code>, <code>DATE</code>或<code>TIMESTAMP</code>上下文環境中接受的函數，例如<code>NOW()</code>或<code>CURRENT_DATE</code>。 
  </li>
</ul>

<p>不合法<code>DATETIME</code>, <code>DATE</code>或<code>TIMESTAMP</code>值被變換到適當類型的“零”值(<code>'0000-00-00 
00:00:00'</code>, <code>'0000-00-00'</code>或<code>00000000000000</code>)。 </p>

<p>對於包括的日期部分分隔符的指定為字符串的值，不必要為小於<code>10</code>的月或天的值指定2位數字，<code>'1979-6-9'</code>與<code>'1979-06-09'</code>是一樣的。同樣, 
對於包括的時間部分分隔符的指定為字符串的值，不必為小於<code>10</code>的小時、月或秒指定2位數字，<code>'1979-10-30 
1:2:3'</code>與<code>'1979-10-30 01:02:03'</code>是一樣的。 </p>

<p>指定為數字應該是6、8、12或14位長。如果數字是8或14位長，它被假定以<code>YYYYMMDD</code>或<code>YYYYMMDDHHMMSS</code>格式並且年份由頭4位數字給出。如果數字是6或12位長，它被假定是以<code>YYMMDD</code>或<code>YYMMDDHHMMSS</code>格式且年份由頭2位數字給出。不是這些長度之一的數字通過填補前頭的零到最接近的長度來解釋。 
</p>

<p>指定為無分隔符的字符串用它們給定的長度來解釋。如果字符串長度是8或14個字符，年份被假定頭4個字符給出，否則年份被假定由頭2個字符給出。對於字符串中呈現的多個部分，字符串從左到右邊被解釋，以找出年、月、日、小時、分鐘和秒值，這意味著，你不應該使用少於 
6 個字符的字符串。例如，如果你指定<code>'9903'</code>，認為將代表1999年3月，你會發現<strong>MySQL</strong>把一個“零”日期插入到你的表中，這是因為年份和月份值<code>99</code>和<code>03</code>，但是日期部分丟失(零)，因此該值不是一個合法的日期。 
</p>

<p><code>TIMESTAMP</code>列使用被指定的值的完整精度的儲存合法的值，不考慮顯示大小。這有幾個含意： 

<ul>
  <li>總是指定年，月，和日，即使你的列類型是<code>TIMESTAMP(4)</code>或<code>TIMESTAMP(2)</code>。否則，值將不是一個合法的日期並且<code>0</code>將被儲存。 
  </li>
  <li>如果你使用<code>ALTER TABLE</code>拓寬一個狹窄的<code>TIMESTAMP</code>列，以前被“隱蔽”的資訊將被顯示。 
  </li>
  <li>同樣，縮小一個<code>TIMESTAMP</code>列不會導致資訊失去，除了感覺上值在顯示時，較少的資訊被顯示出。 
  </li>
  <li>盡管<code>TIMESTAMP</code>值被儲存為完整精度，直接操作儲存值的唯一函數是<code>UNIX_TIMESTAMP()</code>，其他函數操作在格式化了的檢索的值上，這意味著你不能使用函數例如<code>HOUR()</code>或<code>SECOND()</code>，除非<code>TIMESTAMP</code>值的相關部分被包含在格式化的值中。例如，一個<code>TIMESTAMP</code>列的<code>HH</code>部分部被顯示，除非顯示大小至少是10，因此在更短的<code>TIMESTAMP</code>值上試試使用<code>HOUR()</code>產生一個無意義的結果。 
  </li>
</ul>

<p>在某種程度上，你可以把一種日期類型的值賦給一個不同的日期類型的對像。然而，這可能值有一些改變或資訊的損失： 

<ul>
  <li>如果你將一個<code>DATE</code>值賦給一個<code>DATETIME</code>或<code>TIMESTAMP</code>對像，結果值的時間部分被設置為<code>'00:00:00'</code>，因為<code>DATE</code>值不包含時間資訊。 
  </li>
  <li>如果你將一個<code>DATETIME</code>或<code>TIMESTAMP</code>值賦給一個<code>DATE</code>對像，結果值的時間部分被刪除，因為<code>DATE</code>類型不儲存時間資訊。 
  </li>
  <li>記住，盡管<code>DATETIME</code>, <code>DATE</code>和<code>TIMESTAMP</code>值全都可以用同樣的格式集來指定，但所有類型不都有同樣的值範圍。例如，<code>TIMESTAMP</code>值不能比<code>1970</code>早或比<code>2037</code>網晚，這意味著，一個日期例如<code>'1968-01-01'</code>，當作為一個<code>DATETIME</code>或<code>DATE</code>值合法時，它不是一個正確<code>TIMESTAMP</code>值，並且如果賦值給這樣一個對像，它將被變換到<code>0</code>。 
  </li>
</ul>

<p>當指定日期值時，當心某些缺陷： 

<ul>
  <li>允許作為字符串指定值的寬松格式能被欺騙。例如，值例如<code>'10:11:12'</code>可能看起來像時間值，因為<samp>“:”</samp>分隔符，但是如果在一個日期中使用，上下文將作為年份被解釋成<code>'2010-11-12'</code>。值<code>'10:45:15'</code>將被變換到<code>'0000-00-00'</code>，因為<code>'45'</code>不是一個合法的月份。 
  </li>
  <li>以2位數字指定的年值是模糊的，因為世紀是未知的。<strong>MySQL</strong>使用下列規則解釋2位年值： 
    <ul>
      <li>在<code>00-69</code>範圍的年值被變換到<code>2000-2069</code>。 </li>
      <li>在范<code>70-99</code>圍的年值被變換到<code>1970-1999</code>。 </li>
    </ul>
  </li>
</ul>

<h4><a NAME="TIME" HREF="manual_toc.html#TIME">7.3.6.3 <code>TIME</code>類型</a></h4>

<p><strong>MySQL</strong>檢索並以<code>'HH:MM:SS'</code>格式顯示<code>TIME</code>值(或對大小時值，<code>'HHH:MM:SS'</code>格式)。<code>TIME</code>值的範圍可以從<code>'-838:59:59'</code>到<code>'838:59:59'</code>。小時部分可能很大的的原因是<code>TIME</code>類型不僅可以被使用在表示一天的時間(它必須是不到24個小時)，而且用在表示在2個事件之間經過的時間或時間間隔(它可以是比24個小時大些，或甚至是負值)。 
</p>

<p>你能用多中格式指定<code>TIME</code>值： 

<ul>
  <li>作為<code>'HH:MM:SS'</code>格式的一個字符串。“寬松”的語法被允許--任何標點符號可用作時間部分的分隔符，例如，<code>'10:11:12'</code>和<code>'10.11.12'</code>是等價的。 
  </li>
  <li>作為沒有分隔符的<code>'HHMMSS'</code>格式的一個字符串，如果它作為一個時間解釋。例如，<code>'101112'</code>被理解為<code>'10:11:12'</code>，但是<code>'109712'</code>是不合法的(它有無意義的分鐘部分)並變成<code>'00:00:00'</code>。 
  </li>
  <li>作為<code>HHMMSS</code>格式的一個數字，如果它能解釋為一個時間。例如，<code>101112</code>被理解為<code>'10:11:12'</code>。 
  </li>
  <li>返回值可在一個<code>TIME</code>上下文接受的函數，例如<code>CURRENT_TIME</code>。 
  </li>
</ul>

<p>對於作為包括一個時間分隔符的字符串被指定的<code>TIME</code>值，不必為小於<code>10</code>的小時、分鐘或秒值指定2位數字，<code>'8:3:2'</code>與<code>'08:03:02'</code>是一樣的。 
</p>

<p>將“短的”<code>TIME</code>值賦值給一個<code>TIME</code>行列是要格外小心。<strong>MySQL</strong>使用最右位代表秒的假設來解釋值。(<strong>MySQL</strong>將<code>TIME</code>值解釋為經過的時間，而非作為一天的時間 
)例如，你可能想到<code>'11:12'</code>、<code>'1112'</code>和<code>1112</code>意味著<code>'11:12:00'</code>（11點12分)，但是<strong>MySQL</strong>解釋他們為<code>'00:11:12'</code>（11分12秒)。同樣，<code>'12'</code>和<code>12</code>被解釋為<code>'00:00:12'</code>。 
</p>

<p>但是超出<code>TIME</code>範圍之外的值是樣合法的，它被剪切到範圍適當的端點值。例如，<code>'-850:00:00'</code>和<code>'850:00:00'</code>被變換到<code>'-838:59:59'</code>和<code>'838:59:59'</code>。 
</p>

<p>不合法的<code>TIME</code>值被變換到<code>'00:00:00'</code>。注意，既然<code>'00:00:00'</code>本身是一個合法的<code>TIME</code>值，沒有其他方法區分表中儲存的一個<code>'00:00:00'</code>值，原來的值是否被指定為<code>'00:00:00'</code>或它是否是不合法的。 
</p>

<h4><a NAME="YEAR" HREF="manual_toc.html#YEAR">7.3.6.4 <code>YEAR</code>類型</a></h4>

<p><code>YEAR</code>類型是一個 1 字節類型用於表示年份。 </p>

<p><strong>MySQL</strong>檢索並且以<code>YYYY</code>格式顯示<code>YEAR</code>值，其範圍是<code>1901</code>到<code>2155</code>。 
</p>

<p>你能用多種格式指定<code>YEAR</code>值： 

<ul>
  <li>作為在<code>'1901'</code>到<code>'2155'</code>範圍的一個4位字符串。 </li>
  <li>作為在<code>1901</code>到<code>2155</code>範圍的一個4位數字。 </li>
  <li>作為在<code>'00'</code>到<code>'99'</code>範圍的一個2位字符串.在<code>'00'</code>到<code>'69'</code>和<code>'70'</code>到<code>'99'</code>範圍的值被變換到在<code>2000</code>到<code>2069</code>範圍和<code>1970</code>到<code>1999</code>的<code>YEAR</code>值。</li>
  <li>作為在<code>1</code>到<code>99</code>範圍的一個2位數字。在範圍<code>1</code>到<code>69</code>和<code>70</code>到<code>99</code>的值被變換到在範圍<code>2001</code>到<code>2069</code>和<code>1970</code>到<code>1999</code>的<code>YEAR</code>的值。注意對於2位數字的範圍略微不同於2位數字字符串的範圍，因為你不能直接指定零作為一個數字並且把它解釋為<code>2000</code>。你<em>必須</em>作為一個字符串<code>'0'</code>或<code>'00'</code>指定它，它將被解釋為<code>0000</code>。 
  </li>
  <li>其返回值可在一個<code>YEAR</code>上下文環境中接受的函數，例如<code>NOW()</code>。 
  </li>
</ul>

<p>不合法<code>YEAR</code>值被變換到<code>0000</code>。 </p>

<h3><a NAME="String_types" HREF="manual_toc.html#String_types">7.3.7 字符串類型</a></h3>

<p>字符串類型是<code>CHAR</code>、<code>VARCHAR</code>、<code>BLOB</code>、<code>TEXT</code>、<code>ENUM</code>和<code>SET</code>。 
</p>

<h4><a NAME="CHAR" HREF="manual_toc.html#CHAR">7.3.7.1 <code>CHAR</code>和<code>VARCHAR</code>類型</a></h4>

<p><code>CHAR</code>和<code>VARCHAR</code>類型是類似的，但是在他們被儲存和檢索的方式不同。 
</p>

<p>一個<code>CHAR</code>列的長度被修正為在你創造表時你所聲明的長度。長度可以是1和255之間的任何值。（在MySQL 
3.23中，<code>CHAR</code>長度可以是0∼255。) 當<code>CHAR</code>值被儲存時，他們被用空格在右邊填補到指定的長度。當<code>CHAR</code>值被檢索時，拖後的空格被刪去。 
</p>

<p>在<code>VARCHAR</code>列中的值是變長字符串。你可以聲明一個<code>VARCHAR</code>列是在1和255之間的任何長度，就像對<code>CHAR</code>列。然而，與<code>CHAR</code>相反，<code>VARCHAR</code>值只儲存所需的字符，外加一個字節記錄長度，值不被填補﹔相反，當值被儲存時，拖後的空格被刪去。（這個空格刪除不同於ANSI 
SQL規範。）</p>

<p>如果你把一個超過列最大長度的值賦給一個<code>CHAR</code>或<code>VARCHAR</code>列，值被截斷以適合它。 
</p>

<p>下表顯示了兩種類型的列的不同，通過演示儲存變長字符串值到<code>CHAR(4)</code>和<code>VARCHAR(4)</code>列： 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>值</strong> </td>
    <td><code>CHAR(4)</code> </td>
    <td><strong>儲存需求</strong> </td>
    <td><code>VARCHAR(4)</code> </td>
    <td><strong>儲存需求</strong> </td>
  </tr>
  <tr>
    <td><code>''</code> </td>
    <td><code>' '</code> </td>
    <td>4 個字節</td>
    <td><code>''</code> </td>
    <td>1 字節</td>
  </tr>
  <tr>
    <td><code>'ab'</code> </td>
    <td><code>'ab '</code> </td>
    <td>4 個字節</td>
    <td><code>'ab'</code> </td>
    <td>3 個字節</td>
  </tr>
  <tr>
    <td><code>'abcd'</code> </td>
    <td><code>'abcd'</code> </td>
    <td>4 個字節</td>
    <td><code>'abcd'</code> </td>
    <td>5 個字節</td>
  </tr>
  <tr>
    <td><code>'abcdefgh'</code> </td>
    <td><code>'abcd'</code> </td>
    <td>4 個字節</td>
    <td><code>'abcd'</code> </td>
    <td>5 個字節</td>
  </tr>
</table>

<p>從<code>CHAR(4)</code>和<code>VARCHAR(4)</code>列檢索的值在每種情況下都是一樣的，因為拖後的空格從檢索的<code>CHAR</code>列上被刪除。 
</p>

<p>在<code>CHAR</code>和<code>VARCHAR</code>列中儲存和比較值是以大小寫不區分的方式進行的，除非當桌子被創建時，<code>BINARY</code>屬性被指定。<code>BINARY</code>屬性意味著該列的值根據<strong>MySQL</strong>伺服器正在運行的機器的ASCII順序以大小寫區分的方式儲存和比較。 
</p>

<p><code>BINARY</code>屬性是“粘性”的。這意味著，如果標記了<code>BINARY</code>的列用於一個表達式中，整個的表達式作為一個<code>BINARY</code>值被比較。 
</p>

<p><strong>MySQL</strong>在表創建時可以隱含地改變一個<code>CHAR</code>或<code>VARCHAR</code>列的類型。見<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱含的的列說明改變</a>。 
</p>

<h4><a NAME="BLOB" HREF="manual_toc.html#BLOB">7.3.7.2 <code>BLOB</code>和<code>TEXT</code>類型</a></h4>

<p>一個<code>BLOB</code>是一個能保存可變數量的數據的二進制的大對像。4個<code>BLOB</code>類型<code>TINYBLOB</code>、<code>BLOB</code>、<code>MEDIUMBLOB</code>和<code>LONGBLOB</code>僅僅在他們能保存值的最大長度方面有所不同。見<a HREF="manual_Reference.html#Storage_requirements">7.3.1 列類型儲存需求</a>。 </p>

<p>4個<code>TEXT</code>類型<code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>和<code>LONGTEXT</code>對應於4個<code>BLOB</code>類型，並且有同樣的最大長度和儲存需求。在<code>BLOB</code>和<code>TEXT</code>類型之間的唯一差別是對<code>BLOB</code>值的排序和比較以大小寫敏感方式執行，而對<code>TEXT</code>值是大小寫不敏感的。換句話說，一個<code>TEXT</code>是一個大小寫不敏感的<code>BLOB</code>。 
</p>

<p>如果你把一個超過列類型最大長度的值賦給一個<code>BLOB</code>或<code>TEXT</code>列，值被截斷以適合它。 
</p>

<p>在大多數方面，你可以認為一個<code>TEXT</code>行列是你所希望大的一個<code>VARCHAR</code>列。同樣，你可以認為一個<code>BLOB</code>列是一個<code>VARCHAR 
BINARY</code>列。差別是： 

<ul>
  <li>用<strong>MySQL</strong>版本3.23.2和更新，你能在<code>BLOB</code>和<code>TEXT</code>列上索引。更舊的<strong>MySQL</strong>版本不支援這個。 
  </li>
  <li>當值被儲存時，對<code>BLOB</code>和<code>TEXT</code>列沒有拖後空格的刪除，因為對<code>VARCHAR</code>列有刪除。 
  </li>
  <li><a NAME="IDX251"></a><code>BLOB</code>和<code>TEXT</code>列不能有<code>DEFAULT</code>值。 
  </li>
</ul>

<p><strong>MyODBC</strong>定義<code>BLOB</code>為<code>LONGVARBINARY</code>，<code>TEXT</code>值為<code>LONGVARCHAR</code>。 
</p>

<p>因為<code>BLOB</code>和<code>TEXT</code>值可以是非常長的，當使用他們時，你可能遇到一些限制： 

<ul>
  <li>如果你想要在一個<code>BLOB</code>或<code>TEXT</code>列上使用<code>GROUP BY</code>或<code>ORDER 
    BY</code>，你必須將列值變換成一個定長對像。這樣做的標準方法是用<code>SUBSTRING</code>函數。例如： 
    <pre>mysql&gt; select comment from tbl_name,substring(comment,20) as substr ORDER BY substr;
</pre>
    <p>如果你不這樣做，在排序時，只有列的首<code>max_sort_length</code>個字節被使用，預設的<code>max_sort_length</code>是1024﹔這個值能在啟動<code>mysqld</code>伺服器時使用<code>-O</code>選擇改變。你可以在包含<code>BLOB</code>或<code>TEXT</code>值得一個表達式上分組(group)，通過指定列的位置或使用一個別名： 
    </p>
    <pre>mysql&gt; select id,substring(blob_col,1,100) from tbl_name
           GROUP BY 2;
mysql&gt; select id,substring(blob_col,1,100) as b from tbl_name
           GROUP BY b;
</pre>
  </li>
  <li>一個<code>BLOB</code>或<code>TEXT</code>對像的最大尺寸由其類型決定，但是你能在客戶與伺服器之間是實際傳輸的最大值由可用的內存數量和通訊緩衝區的大小來決定。你能改變消息緩衝區大小，但是你必須在伺服器和客戶兩端做。見<a HREF="manual_Performance.html#Server_parameters">10.2.3 調節伺服器參數</a>。 </li>
</ul>

<p>注意，每個<code>BLOB</code>或<code>TEXT</code>值內部由一個獨立分配的對像表示。這與所有的其他列類型相反，它們是在打開表時，按列被分配一次儲存。 
</p>

<h4><a NAME="ENUM" HREF="manual_toc.html#ENUM">7.3.7.3 <code>ENUM</code>類型</a></h4>

<p>一個<code>ENUM</code>是一個字符對像，其值通常從一個在表創建時明確被列舉的允許值的一張表中選擇。 
</p>

<p>在下列的某個情形下，值也可以空字符串(<code>&quot;&quot;</code>)或<code>NULL</code>： 

<ul>
  <li>如果你把一個無效值插入到一個<code>ENUM</code>（即，一個不在允許的值列表中的字符串)，空字符串作為一個特殊錯誤的值被插入。 
  </li>
  <li>如果一個<code>ENUM</code>被聲明為<code>NULL</code>，<code>NULL</code>也是列的合法值，並且預設值是<code>NULL</code>。如果一個<code>ENUM</code>被聲明為<code>NOT 
    NULL</code>，預設值是允許值的列表的第一成員。 </li>
</ul>

<p>每枚舉值有一個編號： 

<ul>
  <li>在列說明中來自允許成員值列表值用從1開始編號。 </li>
  <li>空字符串錯誤值的編號值是0。這意味著，你能使用下列<code>SELECT</code>語句找出被賦給無效<code>ENUM</code>值的行： 
    <pre>mysql&gt; SELECT * FROM tbl_name WHERE enum_col=0;
</pre>
  </li>
  <li><code>NULL</code>值的編號是<code>NULL</code>。 </li>
</ul>

<p>例如，指定為<code>ENUM(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</code>的列可以有顯示在下面的值的任何一個。每個值的編號也被顯示： 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>值</strong> </td>
    <td><strong>編號</strong></td>
  </tr>
  <tr>
    <td><code>NULL</code> </td>
    <td><code>NULL</code> </td>
  </tr>
  <tr>
    <td><code>&quot;&quot;</code> </td>
    <td>0 </td>
  </tr>
  <tr>
    <td><code>&quot;one&quot;</code> </td>
    <td>1 </td>
  </tr>
  <tr>
    <td><code>&quot;two&quot;</code> </td>
    <td>2 </td>
  </tr>
  <tr>
    <td><code>&quot;three&quot;</code> </td>
    <td>3 </td>
  </tr>
</table>

<p>枚舉可以有最大65535個成員。 </p>

<p>當你把值賦給一個<code>ENUM</code>列時，字母的大小寫是無關緊要的。然而，以後從列中檢索的值大小寫匹配在表創建時用來指定允許值的值的大小寫。 
</p>

<p>如果你在一個數字的上下文環境中檢索一個<code>ENUM</code>，列值的編號被返回。如果你儲存一個數字到一個<code>ENUM</code>中，數字被當作一個標號，並且儲存的值是該編號的枚舉成員。 
</p>

<p><code>ENUM</code>值根據列說明列舉的枚舉成員的次序被排序。（換句話說，<code>ENUM</code>值根據他們的編號數字被排序) 
例如，對<code>ENUM(&quot;a&quot;, &quot;b&quot;)，&quot;a&quot;</code>排在<code>&quot;b&quot;</code>前面，但是對<code>ENUM(&quot;b&quot;, 
&quot;a&quot;)，&quot;b&quot;</code>排在<code>&quot;a&quot;</code>前面。空字符串排序非空字符串之前，並且<code>NULL</code>排在所有其他枚舉值之前。 
</p>

<p>如果你想要得到一個<code>ENUM</code>列的所有可能的值，你應該使用：<code>SHOW 
COLUMNS FROM table_name LIKE enum_column_name</code>並且分析在第二列的<code>ENUM</code>定義。 
</p>

<h4><a NAME="SET" HREF="manual_toc.html#SET">7.3.7.4 <code>SET</code>類型</a></h4>

<p>一個<code>SET</code>是可以有零或多個值的一個字符串對像，其每一個必須從表創建造被指定了的允許值的一張列表中被選擇。由多個集合成員組成的<code>SET</code>列通過由由逗號分隔(<samp>“,”</samp>)的成員被指定，其推論是該<code>SET</code>成員值不能包含逗號本身。 
</p>

<p>例如, 一個指定為<code>SET(&quot;one&quot;, &quot;two&quot;) NOT NULL</code>的列可以有這些值的任何一個： 
</p>

<pre>&quot;&quot; 
&quot;one&quot; 
&quot;two&quot; 
&quot;one,two&quot;

一個<code>SET</code>能有最多64個不同的成員。 </pre>

<p><strong>MySQL</strong>用數字值儲存<code>SET</code>值，儲存值的低階位對應於第一個集合成員。如果你在數字上下文中檢索一個<code>SET</code>值，檢索的值把位設置位對應組成列值的集合成員。如果一個數字被儲存進一個<code>SET</code>列，在數字的二進制表示中設置的位決定了在列中的集合成員。假定一個列被指定為<code>SET(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)</code>，那麼成員有下列位值： 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><code>SET</code> <strong>成員</strong> </td>
    <td><strong>十進制的值</strong> </td>
    <td><strong>二進制的值</strong> </td>
  </tr>
  <tr>
    <td><code>a</code> </td>
    <td><code>1</code> </td>
    <td><code>0001</code> </td>
  </tr>
  <tr>
    <td><code>b</code> </td>
    <td><code>2</code> </td>
    <td><code>0010</code> </td>
  </tr>
  <tr>
    <td><code>c</code> </td>
    <td><code>4</code> </td>
    <td><code>0100</code> </td>
  </tr>
  <tr>
    <td><code>d</code> </td>
    <td><code>8</code> </td>
    <td><code>1000</code> </td>
  </tr>
</table>

<p>如果你給該列賦值<code>9</code>，即二進制的<code>1001</code>，這樣第一個和第四個<code>SET</code>值成員<code>&quot;a&quot;</code>和<code>&quot;d&quot;</code>被選擇並且結果值是<code>&quot;a,d&quot;</code>。 
</p>

<p>對於包含超過一個<code>SET</code>成員的值，當你插入值時，無所謂以什麼順序列舉值，也無所謂給定的值列舉了多少次。當以後檢索值時，在值中的每個成員將出現一次，根據他們在表創建時被指定的順序列出成員。例如，如果列指定為<code>SET(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)</code>，那麼<code>&quot;a,d&quot;</code>、<code>&quot;d,a&quot;</code>和<code>&quot;d,a,a,d,d&quot;</code>在檢索時將均作為<code>&quot;a,d&quot;</code>出現。 
</p>

<p><code>SET</code>值以數字次序被排序。<code>NULL</code>指排在非<code>NULL</code> 
<code>SET</code>值之前。 </p>

<p>通常，你使用<code>LIKE</code>操作符或<code>FIND_IN_SET()</code>函數執行在一個<code>SET</code>上的一個<code>SELECT</code>： 
</p>

<pre>mysql&gt; SELECT * FROM tbl_name WHERE set_col LIKE '%value%';
mysql&gt; SELECT * FROM tbl_name WHERE FIND_IN_SET('value',set_col)&gt;0;
</pre>

<p>但是下列也會工作： </p>

<pre>mysql&gt; SELECT * FROM tbl_name WHERE set_col = 'val1,val2';
mysql&gt; SELECT * FROM tbl_name WHERE set_col &amp; 1;
</pre>

<p>這些語句的第一個語句尋找一個精確的匹配。第二個尋找包含第一個集合成員的值。 
</p>

<p>如果你想要得到一個<code>SET</code>列的所有可能的值，你應該使用：<code>SHOW 
COLUMNS FROM table_name LIKE set_column_name</code>並且分析在第二列的<code>SET</code>定義。 
</p>

<h3><a NAME="Choosing_types" HREF="manual_toc.html#Choosing_types">7.3.8 
為列選擇正確的類型</a></h3>

<p>為了最有效地使用儲存空間，試著在所有的情況下使用最精確的類型。例如，如果一個整數列被用於在之間<code>1</code>和<code>99999</code>的值， 
<code>MEDIUMINT UNSIGNED</code>是最好的類型。 </p>

<p>貨幣值的精確表示是一個常見的問題。在<strong>MySQL</strong>，你應該使用<code>DECIMAL</code>類型，它作為一個字符串被儲存，不會發生精確性的損失。如果精確性不是太重要，<code>DOUBLE</code>類型也是足夠好的。 
</p>

<p>對高精度，你總是能變換到以一個<code>BIGINT</code>儲存的定點類型。這允許你用整數做所有的計算，並且僅在必要時將結果轉換回浮點值。見<a HREF="manual_Performance.html#Choosing_table_type">10.6 選擇一個表類型</a>。 </p>

<h3><a NAME="Indexes" HREF="manual_toc.html#Indexes">7.3.9 列索引</a></h3>

<p>所有的<strong>MySQL</strong>列類型能被索引。在相關的列上的使用索引是改進<code>SELECT</code>操作性能的最好方法。 
</p>

<p>一個表最多可有16個索引。最大索引長度是256個字節，盡管這可以在編譯<strong>MySQL</strong>時被改變。 
</p>

<p>對於<code>CHAR</code>和<code>VARCHAR</code>列，你可以索引列的前綴。這更快並且比索引整個列需要較少的磁碟空間。在<code>CREATE 
TABLE</code>語句中索引列前綴的語法看起來像這樣： </p>

<pre>KEY index_name (col_name(length)) </pre>

<p>下面的例子為<code>name</code>列的頭10個字符創建一個索引： </p>

<pre>mysql&gt; CREATE TABLE test (
           name CHAR(200) NOT NULL,
           KEY index_name (name(10)));
</pre>

<p>對於<code>BLOB</code>和<code>TEXT</code>列，你必須索引列的前綴，你不能索引列的全部。 
</p>

<h3><a NAME="Multiple-column_indexes" HREF="manual_toc.html#Multiple-column_indexes">7.3.10 
多列索引</a></h3>

<p><strong>MySQL</strong>能在多個列上創建索引。一個索引可以由最多15個列組成。（在<code>CHAR</code>和<code>VARCHAR</code>列上，你也可以使用列的前綴作為一個索引的部分)。 
</p>

<p>一個多重列索引可以認為是包含通過合並(concatenate)索引列值創建的值的一個排序數組。 
</p>

<p>當你為在一個<code>WHERE</code>子句索引的第一列指定已知的數量時，<strong>MySQL</strong>以這種方式使用多重列索引使得查詢非常快速，即使你不為其他列指定值。 
</p>

<p>假定一張表使用下列說明創建： </p>

<pre>mysql&gt; CREATE TABLE test (
           id INT NOT NULL,
           last_name CHAR(30) NOT NULL,
           first_name CHAR(30) NOT NULL,
           PRIMARY KEY (id),
           INDEX name (last_name,first_name));
</pre>

<p>那麼索引<code>name</code>是一個在<code>last_name</code>和<code>first_name</code>上的索引，這個索引將被用於在<code>last_name</code>或<code>last_name</code>和<code>first_name</code>的一個已知範圍內指定值的查詢，因此，<code>name</code>索引將使用在下列查詢中： 
</p>

<pre>mysql&gt; SELECT * FROM test WHERE last_name=&quot;Widenius&quot;;

mysql&gt; SELECT * FROM test WHERE last_name=&quot;Widenius&quot;
                          AND first_name=&quot;Michael&quot;;

mysql&gt; SELECT * FROM test WHERE last_name=&quot;Widenius&quot;
                          AND (first_name=&quot;Michael&quot; OR first_name=&quot;Monty&quot;);

mysql&gt; SELECT * FROM test WHERE last_name=&quot;Widenius&quot;
                          AND first_name &gt;=&quot;M&quot; AND first_name &lt; &quot;N&quot;;
</pre>

<p>然而，<code>name</code>索引將不用在下列詢問中： </p>

<pre>mysql&gt; SELECT * FROM test WHERE first_name=&quot;Michael&quot;;

mysql&gt; SELECT * FROM test WHERE last_name=&quot;Widenius&quot;
                          OR first_name=&quot;Michael&quot;;
</pre>

<p>關於<strong>MySQL</strong>使用索引改進性能的方式的更多的資訊，見<a HREF="manual_Performance.html#MySQL_indexes">10.4 使用MySQL索引</a>。 </p>

<h3><a NAME="Other-vendor_column_types" HREF="manual_toc.html#Other-vendor_column_types">7.3.11 
使用來自其他資料庫引擎的列類型</a></h3>

<p>為了跟容易地使用為其他供應商的SQL實現編寫的代碼，下表顯示了<strong>MySQL</strong>映射的列類型。這些映射使得從其他資料庫引擎移動表定義到<strong>MySQL</strong>更容易： 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>其他供應商類型</strong> </td>
    <td><strong>MySQL類型</strong> </td>
  </tr>
  <tr>
    <td><code>BINARY(NUM)</code> </td>
    <td><code>CHAR(NUM) BINARY</code> </td>
  </tr>
  <tr>
    <td><code>CHAR VARYING(NUM)</code> </td>
    <td><code>VARCHAR(NUM)</code> </td>
  </tr>
  <tr>
    <td><code>FLOAT4</code> </td>
    <td><code>FLOAT</code> </td>
  </tr>
  <tr>
    <td><code>FLOAT8</code> </td>
    <td><code>DOUBLE</code> </td>
  </tr>
  <tr>
    <td><code>INT1</code> </td>
    <td><code>TINYINT</code> </td>
  </tr>
  <tr>
    <td><code>INT2</code> </td>
    <td><code>SMALLINT</code> </td>
  </tr>
  <tr>
    <td><code>INT3</code> </td>
    <td><code>MEDIUMINT</code> </td>
  </tr>
  <tr>
    <td><code>INT4</code> </td>
    <td><code>INT</code> </td>
  </tr>
  <tr>
    <td><code>INT8</code> </td>
    <td><code>BIGINT</code> </td>
  </tr>
  <tr>
    <td><code>LONG VARBINARY</code> </td>
    <td><code>MEDIUMBLOB</code> </td>
  </tr>
  <tr>
    <td><code>LONG VARCHAR</code> </td>
    <td><code>MEDIUMTEXT</code> </td>
  </tr>
  <tr>
    <td><code>MIDDLEINT</code> </td>
    <td><code>MEDIUMINT</code> </td>
  </tr>
  <tr>
    <td><code>VARBINARY(NUM)</code> </td>
    <td><code>VARCHAR(NUM) BINARY</code> </td>
  </tr>
</table>

<p>列類型映射發生在表創建時。如果你用其他供應商使用的類型創建表，那麼發出一個<code>DESCRIBE 
tbl_name</code>語句，<strong>MySQL</strong>使用等價的<strong>MySQL</strong>類型報告表結構。 
</p>

<h2><a NAME="Functions" HREF="manual_toc.html#Functions">7.4 用在<code>SELECT</code>和<code>WHERE</code>子句中的函數</a></h2>

<p>在一個SQL語句中的<code>select_expression</code>或<code>where_definition</code>可由使用下面描述的函數的任何表達式組成。 
</p>

<p>包含<code>NULL</code>的一個表達式總是產生一個<code>NULL</code>值，否則除非表達式所包含的操作符和函數在文檔中說明。 
</p>

<p><strong>注意：</strong>在一個函數名和跟隨它的括號之間不許沒有空格。這幫助<strong>MySQL</strong>分析器區分函數調用和具有相同名字的對表或列的引用，盡管允許在參數周圍有空格。 
</p>

<p>為了簡潔，例子以縮寫形式顯示從<code>mysql</code>程式輸出。因此： 
</p>

<pre>
mysql&gt; select MOD(29,9); 
1 rows in set (0.00 sec) 

+-----------+
| mod(29,9) |
+-----------+
|         2 |
+-----------+
</pre>

<p>被顯示為這樣： </p>

<pre>mysql&gt; select MOD(29,9);
        -&gt; 2
</pre>

<h3><a NAME="Grouping_functions" HREF="manual_toc.html#Grouping_functions">7.4.1 
分組函數</a><a NAME="IDX262"></a> </h3>

<dl COMPACT="IDX262">
  <dt><code>( ... )</code> </dt>
  <dd><a NAME="IDX263"></a> <a NAME="IDX264"></a>括號。使用它們來強制在一個表達式的計算順序。 
    <pre>mysql&gt; select 1+2*3;
        -&gt; 7
mysql&gt; select (1+2)*3;
        -&gt; 9
</pre>
  </dd>
</dl>

<h3><a NAME="Arithmetic_functions" HREF="manual_toc.html#Arithmetic_functions">7.4.2 
常用的算術操作</a></h3>

<p>一般的算術操作符是可用的。注意在<code>-</code>、<code>+</code>和<code>*</code>情況下，如果兩個參數是整數，結果用<code>BIGINT</code>（64位）精度計算！ 
&nbsp; 

<dl COMPACT="IDX265">
  <dt><code>+</code> </dt>
  <dd><a NAME="IDX266"></a> <a NAME="IDX267"></a>加法<pre>mysql&gt; select 3+5;
        -&gt; 8
</pre>
  </dd>
  <dt><code>-</code> </dt>
  <dd>減法<pre>mysql&gt; select 3-5;
        -&gt; -2<a NAME="IDX270"></a> <a NAME="IDX271"></a> </pre>
  </dd>
  <dt><code>*</code> </dt>
  <dd>乘法<pre>mysql&gt; select 3*5;
        -&gt; 15
mysql&gt; select 18014398509481984*18014398509481984.0;
        -&gt; 324518553658426726783156020576256.0
mysql&gt; select 18014398509481984*18014398509481984;
        -&gt; 0

</pre>
    <p>最後一個表達式的結果是不正確的，因為整數乘積的結果超過用<code>BIGINT</code>計算的64位範圍。 
    <a NAME="IDX272"></a> <a NAME="IDX273"></a> </p>
  </dd>
  <dt><code>/</code> </dt>
  <dd>除法<pre>mysql&gt; select 3/5;
        -&gt; 0.60
</pre>
    <p>被零除產生一個<code>NULL</code>結果： </p>
    <pre>mysql&gt; select 102/(1-1);
        -&gt; NULL
</pre>
    <p>一個除法用<code>BIGINT</code>算術計算，只要在它的結果被轉換到一個整數的上下文中執行！<a NAME="IDX276"></a> <a NAME="IDX277"></a> </p>
  </dd>
</dl>

<h3><a NAME="Bit_functions" HREF="manual_toc.html#Bit_functions">7.4.3 位函數</a></h3>

<p><strong>MySQL</strong>為位操作使用<code>BIGINT</code>（64位)算法，因此這些操作符有最大64位的一個範圍。 

<dl COMPACT="Bit_functions">
  <dt><code>|</code> </dt>
  <dd><a NAME="IDX278"></a><a NAME="IDX279"></a>位或<pre>mysql&gt; select 29 | 15;
        -&gt; 31
</pre>
  </dd>
  <dt><code>&amp;</code> </dt>
  <dd>位與<pre>mysql&gt; select 29 &amp; 15;
        -&gt; 13
<a NAME="IDX282"></a> </pre>
  </dd>
  <dt><code>&lt;&lt;</code> </dt>
  <dd>左移位一個長(<code>BIGINT</code>)數字。 <pre>mysql&gt; select 1 &lt;&lt; 2
        -&gt; 4
 </pre>
  </dd>
  <dt><code>&gt;&gt;</code> </dt>
  <dd>右移位一個長(<code>BIGINT</code>)數字。 <pre>mysql&gt; select 4 &gt;&gt; 2
        -&gt; 1 </pre>
  </dd>
  <dt><code>~</code> </dt>
  <dd>顛倒所有的位。 <pre>mysql&gt; select 5 &amp; ~1
        -&gt; 4
 </pre>
  </dd>
  <dt><code>BIT_COUNT(N)</code> </dt>
  <dd>返回在參數<code>N</code>設定的位的數量。 <pre>mysql&gt; select BIT_COUNT(29);
        -&gt; 4
<a NAME="IDX286"></a> <a NAME="IDX287"></a> </pre>
  </dd>
</dl>

<h3><a NAME="Logical_functions" HREF="manual_toc.html#Logical_functions">7.4.4 
邏輯運算</a></h3>

<p>所有的邏輯函數返回<code>1</code>（TRUE）或<code>0</code>（FALSE）。 

<dl COMPACT="Logical_functions">
  <dt><code>NOT</code> </dt>
  <dd><a NAME="IDX288"></a> <a NAME="IDX289"></a> </dd>
  <dt><code>!</code> </dt>
  <dd>邏輯非。如果參數是<code>0</code>，返回<code>1</code>，否則返回<code>0</code>。例外： 
    <code>NOT NULL</code>返回<code>NULL</code>。 <pre>mysql&gt; select NOT 1;
        -&gt; 0
mysql&gt; select NOT NULL;
        -&gt; NULL
mysql&gt; select ! (1+1);
        -&gt; 0
mysql&gt; select ! 1+1;
        -&gt; 1
</pre>
    <pre>最後的例子返回<code>1</code>，因為表達式作為<code>(!1)+1</code>計算。 <a NAME="IDX290"></a> <a NAME="IDX291"></a> </pre>
  </dd>
  <dt><code>OR</code> </dt>
  <dd>　</dd>
  <dt><code>||</code> </dt>
  <dd>邏輯或。如果任何一個參數不是<code>0</code>並且不<code>NULL</code>，返回<code>1</code>。 
    <pre>mysql&gt; select 1 || 0;
        -&gt; 1
mysql&gt; select 0 || 0;
        -&gt; 0
mysql&gt; select 1 || NULL;
        -&gt; 1
<a NAME="IDX293"></a> </pre>
  </dd>
  <dt><code>AND</code> </dt>
  <dd>　</dd>
  <dt><code>&amp;&amp;</code> </dt>
  <dd>邏輯與。如果任何一個參數是<code>0</code>或<code>NULL</code>，返回<code>0</code>，否則返回<code>1</code>。 
    <pre>mysql&gt; select 1 &amp;&amp; NULL;
        -&gt; 0
mysql&gt; select 1 &amp;&amp; 0;
        -&gt; 0
 <a NAME="IDX295"></a> <a NAME="IDX296"></a> </pre>
  </dd>
</dl>

<h3><a NAME="Comparison_functions" HREF="manual_toc.html#Comparison_functions">7.4.5 
比較運算符</a></h3>

<p>比較操作得出值<code>1</code>（TRUE）、<code>0</code>（FALSE）或<code>NULL</code>等結果。這些函數工作運用在數字和字符串上。當需要時，字符串自動地被變換到數字且數字到字符串(如在Perl)。 
</p>

<p><strong>MySQL</strong>使用下列規則執行比較： 

<ul>
  <li>如果一個或兩個參數是<code>NULL</code>，比較的結果是<code>NULL</code>，除了<code>&lt;=&gt;</code>操作符。 
  </li>
  <li>如果在比較中操作的兩個參數是字符串，他們作為字符串被比較。 </li>
  <li>如果兩個參數是整數，他們作為整數被比較。 </li>
  <li>十六進制的值如果不與一個數字比較，則被當作二進制字符串。 </li>
  <li><a NAME="IDX297"></a><a NAME="IDX298"></a>如果參數之一是一個<code>TIMESTAMP</code>或<code>DATETIME</code>列而其他參數是一個常數，在比較執行前，常數被轉換為一個時間標記。這樣做是為了對ODBC更友好。 
  </li>
  <li>在所有其他的情況下，參數作為浮點(實數)數字被比較。 </li>
</ul>

<p>預設地，字符串使用當前的字符集以大小寫敏感的方式進行(預設為ISO-8859-1 
Latin1，它對英語運用得很出色)。 </p>

<p>下面的例子演示了對於比較操作字符串到數字的轉換： </p>

<pre>mysql&gt; SELECT 1 &gt; '6x';
         -&gt; 0
mysql&gt; SELECT 7 &gt; '6x';
         -&gt; 1
mysql&gt; SELECT 0 &gt; 'x6';
         -&gt; 0
mysql&gt; SELECT 0 = 'x6';
         -&gt; 1
</pre>

<dl COMPACT="IDX298">
  <dt><code>=</code> </dt>
  <dd><a NAME="IDX299"></a>等於<pre>mysql&gt; select 1 = 0;
        -&gt; 0
mysql&gt; select '0' = 0;
        -&gt; 1
mysql&gt; select '0.0' = 0;
        -&gt; 1
mysql&gt; select '0.01' = 0;
        -&gt; 0
mysql&gt; select '.01' = 0.01;
        -&gt; 1
<a NAME="IDX301"></a> <a NAME="IDX302"></a> <a NAME="IDX303"></a> <a NAME="IDX304"></a> </pre>
  </dd>
  <dt><code>&lt;&gt;</code> </dt>
  <dd>　</dd>
  <dt><code>!=</code> </dt>
  <dd>不等於<pre>mysql&gt; select '.01' &lt;&gt; '0.01';
        -&gt; 1
mysql&gt; select .01 &lt;&gt; '0.01';
        -&gt; 0
mysql&gt; select 'zapp' &lt;&gt; 'zappp';
        -&gt; 1
</pre>
  </dd>
  <dt><code>&lt;=</code> </dt>
  <dd>小於或等於<br>
    <pre>mysql&gt; select 0.1 &lt;= 2;
        -&gt; 1
 </pre>
  </dd>
  <dt><code>&lt;</code> </dt>
  <dd>小於<pre>mysql&gt; select 2 &lt;= 2;
        -&gt; 1
 <a NAME="IDX310"></a> </pre>
  </dd>
  <dt><code>&gt;=</code> </dt>
  <dd>大於或等於<pre>mysql&gt; select 2 &gt;= 2;
        -&gt; 1 </pre>
  </dd>
  <dt><code>&gt;</code> </dt>
  <dd>大於<pre>mysql&gt; select 2 &gt; 2;
        -&gt; 0
</pre>
  </dd>
  <dt><code>&lt;=&gt;</code> </dt>
  <dd>安全等於Null<pre>mysql&gt; select 1 &lt;=&gt; 1, NULL &lt;=&gt; NULL, 1 &lt;=&gt; NULL;
        -&gt; 1 1 0
<a NAME="IDX314"></a> <a NAME="IDX315"></a> </pre>
  </dd>
  <dt><code>IS NULL</code> </dt>
  <dd>　</dd>
  <dt><code>IS NOT NULL</code> </dt>
  <dd>測試值是否是或不是<code>NULL</code> <pre>mysql&gt; select 1 IS NULL, 0 IS NULL, NULL IS NULL:
        -&gt; 0 0 1
mysql&gt; select 1 IS NOT NULL, 0 IS NOT NULL, NULL IS NOT NULL;
 </pre>
  </dd>
  <dt><code>expr BETWEEN min AND max</code> </dt>
  <dd>如果<code>expr</code>對大於或等於<code>min</code>且<code>expr</code>是小於或等於<code>max</code>，<code>BETWEEN</code>返回<code>1</code>，否則它返回<code>0</code>。如果所有的參數類型是一樣得，這等價於表達式<code>(min 
    &lt;= expr AND expr &lt;= max)</code>。第一個參數(<code>expr</code>)決定比較如何被執行。如果<code>expr</code>是一個大小寫不敏感的字符串表達式，進行一個大小寫不敏感的字符串比較。如果<code>expr</code>是一個大小寫敏感的字符串表達式，進行一個大小寫敏感的字符串比較。如果<code>expr</code>是一個整數表達式，進行整數比較。否則，進行一個浮點(實數)比較。 
    <pre>mysql&gt; select 1 BETWEEN 2 AND 3;
        -&gt; 0
mysql&gt; select 'b' BETWEEN 'a' AND 'c';
        -&gt; 1
mysql&gt; select 2 BETWEEN 2 AND '3';
        -&gt; 1
mysql&gt; select 2 BETWEEN 2 AND 'x-3';
        -&gt; 0
</pre>
  </dd>
  <dt><code>expr IN (value,...)</code> </dt>
  <dd>如果<code>expr</code>是在<code>IN</code>表中的任何值，返回<code>1</code>，否則返回<code>0</code>。如果所有的值是常數，那麼所有的值根據<code>expr</code>類型被計算和排序，然後項目的搜索是用二進制的搜索完成。這意味著如果<code>IN</code>值表全部由常數組成<code>，IN</code>是很快的。如果<code>expr</code>是一個大小寫敏感的字符串表達式，字符串比較以大小寫敏感方式執行。 
    <pre>mysql&gt; select 2 IN (0,3,5,'wefwf');
        -&gt; 0
mysql&gt; select 'wefwf' IN (0,3,5,'wefwf');
        -&gt; 1<a NAME="IDX318"></a> </pre>
  </dd>
  <dt><code>expr NOT IN (value,...)</code> </dt>
  <dd>與<code>NOT (expr IN (value,...))</code>相同。 <a NAME="IDX319"></a> </dd>
  <dt><code>ISNULL(expr)</code> </dt>
  <dd>如果<code>expr</code>是<code>NULL</code>，<code>ISNULL()</code>返回<code>1</code>，否則它返回<code>0</code>。 
    <pre>mysql&gt; select ISNULL(1+1);
        -&gt; 0
mysql&gt; select ISNULL(1/0);
        -&gt; 1
</pre>
    <p>注意，使用<code>=</code>的<code>NULL</code>的值比較總為假！ <a NAME="IDX320"></a> </p>
  </dd>
  <dt><code>COALESCE(list)</code> </dt>
  <dd>回來list中第一個非<code>NULL</code>的單元。 <pre>mysql&gt; select COALESCE(NULL,1);
        -&gt; 1
mysql&gt; select COALESCE(NULL,NULL,NULL);
        -&gt; NULL
</pre>
  </dd>
  <dt><code>INTERVAL(N,N1,N2,N3,...)</code> </dt>
  <dd>如果<code>N</code>&lt; <code>N1</code>，返回<code>0</code>，如果<code>N</code>&lt; 
    <code>N2</code>，返回<code>1</code>等等。所有的參數被當作整數。為了函數能正確地工作，它要求<code>N1</code>&lt;<code>N2</code>&lt;<code>N3</code>&lt; 
    <code>...</code>&lt;<code>Nn</code>。這是因為使用二進制搜索(很快)。 <pre>mysql&gt; select INTERVAL(23, 1, 15, 17, 30, 44, 200);
        -&gt; 3
mysql&gt; select INTERVAL(10, 1, 10, 100, 1000);
        -&gt; 2
mysql&gt; select INTERVAL(22, 23, 30, 44, 200);
        -&gt; 0<a NAME="IDX322"></a> <a NAME="IDX323"></a> </pre>
  </dd>
</dl>

<h3><a NAME="String_comparison_functions" HREF="manual_toc.html#String_comparison_functions">7.4.6 字符串比較函數</a></h3>

<p>通常，如果在字符串比較中的任何表達式是區分大小寫的，比較以大小寫敏感的方式執行。 

<dl COMPACT="IDX325">
  <dt><code>expr LIKE pat [ESCAPE 'escape-char']</code> </dt>
  <dd><a NAME="IDX326"></a>使用SQL的簡單的正規表達式比較的模式匹配。返回<code>1</code>（TRUE）或<code>0</code>（FALSE）。用<code>LIKE</code>，你可以在模式中使用下列2個通配符字符： 
    <table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
      <tr>
        <td><code>%</code> </td>
        <td>匹配任何數目的字符，甚至零個字符</td>
      </tr>
      <tr>
        <td><code>_</code> </td>
        <td>精確匹配一個字符</td>
      </tr>
    </table>
    <pre>mysql&gt; select 'David!' LIKE 'David_';
        -&gt; 1
mysql&gt; select 'David!' LIKE '%D%v%';
        -&gt; 1
</pre>
    <p>為了測試一個通配符的文字實例，用轉義字符的加在字符前面。如果你不指定<code>ESCAPE</code>字符，<samp>假定為“\”</samp>： 
    </p>
    <table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
      <tr>
        <td><code>\%</code> </td>
        <td>匹配一<code>%</code>字符</td>
      </tr>
      <tr>
        <td><code>\_</code> </td>
        <td>匹配一<code>_</code>字符</td>
      </tr>
    </table>
    <pre>mysql&gt; select 'David!' LIKE 'David\_';
        -&gt; 0
mysql&gt; select 'David_' LIKE 'David\_';
        -&gt; 1

為了指定一個不同的轉義字符，使用<code>ESCAPE</code>子句： </pre>
    <pre>mysql&gt; select 'David_' LIKE 'David|_' ESCAPE '|';
        -&gt; 1
</pre>
    <p><code>LIKE</code>允許用在數字的表達式上！（這是<strong>MySQL</strong>對ANSI 
    SQL<code> LIKE</code>的一個擴充。) </p>
    <pre>mysql&gt; select 10 LIKE '1%';
        -&gt; 1
</pre>
    <p>注意：因為<strong>MySQL</strong>在字符串中使用C轉義語法(例如，<samp>“\n”</samp>)，你必須在你的<code>LIKE</code>字符串中重複任何<samp>“\”</samp>。例如，為了查找<samp>“\n”</samp>，指定它為<samp>“ 
    \\n”</samp>，為了查找<samp>“\”</samp>，指定它為<samp>“\\\\”</samp>（反斜線被分析器剝去一次，另一次是在模式匹配完成時，留下一條單獨的反斜線被匹配)。 
    <a NAME="IDX327"></a> </p>
  </dd>
  <dt><code>expr NOT LIKE pat [ESCAPE 'escape-char']</code> </dt>
  <dd>與<code>NOT (expr LIKE pat [ESCAPE 'escape-char'])</code>相同。 <a NAME="IDX328"></a> 
    <a NAME="IDX329"></a> <a NAME="IDX330"></a> <a NAME="IDX331"></a> </dd>
  <dt><code>expr REGEXP pat</code> </dt>
  <dd>　</dd>
  <dt><code>expr RLIKE pat</code> </dt>
  <dd>執行一個字符串表達式<code>expr</code>對一個模式<code>pat</code>的模式匹配。模式可以是一個擴充的正則表達式。見<a HREF="manual_Regexp.html#Regexp">MySQL 正則表達式句法的 H 描述</a>.如果<code>expr</code>匹配<code>pat</code>，返回<code>1</code>，否則返回<code>0</code>。<code>RLIKE</code>是<code>REGEXP</code>的一個同義詞，提供了與<code>mSQL</code>的兼容性。注意：因為<strong>MySQL</strong>在字符串中使用C轉義語法(例如，<samp>“\n”</samp>), 
    你必須在你的<code>REGEXP</code>字符串重複任何<samp>“\”</samp>。在<code>MySQL</code>3.23.4中，<code>REGEXP</code>對於正常的(不是二進制)字符串是忽略大小寫。 
    <pre>mysql&gt; select 'Monty!' REGEXP 'm%y%%';
        -&gt; 0
mysql&gt; select 'Monty!' REGEXP '.*';
        -&gt; 1
mysql&gt; select 'new*\n*line' REGEXP 'new\\*.\\*line';
        -&gt; 1
mysql&gt; select &quot;a&quot; REGEXP &quot;A&quot;, &quot;a&quot; REGEXP BINARY &quot;A&quot;;
        -&gt; 1  0
</pre>
  </dd>
  <dd>當決定一個字符的類型時，<code>REGEXP</code>和<code>RLIKE</code>使用當前的字符集(預設為ISO-8859-1 
    Latin1)。 <a NAME="IDX332"></a> </dd>
  <dt><code>expr NOT REGEXP pat</code> </dt>
  <dd>　</dd>
  <dt><code>expr NOT RLIKE pat</code> </dt>
  <dd>與<code>NOT (expr REGEXP pat)</code>相同。 <a NAME="IDX333"></a> </dd>
  <dt><code>STRCMP(expr1,expr2)</code> </dt>
  <dd>如果字符串相同，<code>STRCMP()</code>回來<code>0</code>，如果第一參數根據當前的排序次序小於第二個，返回<code>-1</code>，否則返回<code>1</code>。 
    <pre>mysql&gt; select STRCMP('text', 'text2');
        -&gt; -1
mysql&gt; select STRCMP('text2', 'text');
        -&gt; 1
mysql&gt; select STRCMP('text', 'text');
        -&gt; 0
<a NAME="IDX334"></a> </pre>
  </dd>
</dl>

<h3><a NAME="Casts" HREF="manual_toc.html#Casts">7.4.7 類型轉換運算符</a></h3>

<dl COMPACT="Casts">
  <dt><code><code>BINARY</code></code> </dt>
  <dd><a NAME="IDX335"></a><code>BINARY</code>操作符強制跟隨它後面的字符串為一個二進制字符串。即使列沒被定義為<code>BINARY</code>或<code>BLOB</code>，這是一個強制列比較區分大小寫的簡易方法。 
    <pre>mysql&gt; select &quot;a&quot; = &quot;A&quot;;
        -&gt; 1
mysql&gt; select BINARY &quot;a&quot; = &quot;A&quot;;
        -&gt; 0
</pre>
    <p><code>BINARY</code>在<strong>MySQL</strong> 3.23.0中被引入。</p>
  </dd>
</dl>

<h3><a NAME="Control_flow_functions" HREF="manual_toc.html#Control_flow_functions">7.4.8 
控制流函數</a></h3>

<dl COMPACT="Control_flow_functions">
  <dt><code>IFNULL(expr1,expr2)</code> </dt>
  <dd><a NAME="IDX338"></a>如果<code>expr1</code>不是<code>NULL</code>，<code>IFNULL()</code>返回<code>expr1</code>，否則它返回<code>expr2</code>。<code>IFNULL()</code>返回一個數字或字符串值，取決於它被使用的上下文環境。 
    <dl>
      <dd><pre>mysql&gt; select IFNULL(1,0);
        -&gt; 1
mysql&gt; select IFNULL(0,10);
        -&gt; 0
mysql&gt; select IFNULL(1/0,10);
        -&gt; 10
mysql&gt; select IFNULL(1/0,'yes');
        -&gt; 'yes'
<a NAME="IDX339"></a> </pre>
      </dd>
    </dl>
  </dd>
  <dt><code>IF(expr1,expr2,expr3)</code> </dt>
  <dd>如果<code>expr1</code>是TRUE(<code>expr1&lt;&gt;0</code>且<code>expr1&lt;&gt;NULL</code>)，那麼<code>IF()</code>返回<code>expr2</code>，否則它返回<code>expr3</code>。<code>IF()</code>返回一個數字或字符串值，取決於它被使用的上下文。 
    <pre>mysql&gt; select IF(1&gt;2,2,3);
        -&gt; 3
mysql&gt; select IF(1&lt;2,'yes','no');
        -&gt; 'yes'
mysql&gt; select IF(strcmp('test','test1'),'yes','no');
        -&gt; 'no'
</pre>
    <p><code>expr1</code>作為整數值被計算，它意味著如果你正在測試浮點或字符串值，你應該使用一個比較操作來做。 
    </p>
    <pre>mysql&gt; select IF(0.1,1,0);
        -&gt; 0
mysql&gt; select IF(0.1&lt;&gt;0,1,0);
        -&gt; 1
</pre>
    <p>在上面的第一種情況中，<code>IF(0.1)</code>返回<code>0</code>，因為<code>0.1</code>被變換到整數值, 
    導致測試<code>IF(0)</code>。這可能不是你期望的。在第二種情況中，比較測試原來的浮點值看它是否是非零，比較的結果被用作一個整數。 
    <a NAME="IDX340"></a> </p>
  </dd>
  <dt><code>CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] 
    [ELSE result] END</code> </dt>
  <dd>　</dd>
  <dt><code>CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] 
    END</code> </dt>
  <dd>第一個版本返回<code>result</code>，其中<code>value=compare-value</code>。第二個版本中如果第一個條件為真，返回result。如果沒有匹配的result值，那麼結果在<code>ELSE</code>後的result被返回。如果沒有<code>ELSE</code>部分，那麼<code>NULL</code>被返回。 
    <pre>mysql&gt; SELECT CASE 1 WHEN 1 THEN &quot;one&quot; WHEN 2 THEN &quot;two&quot; ELSE &quot;more&quot; END;
       -&gt; &quot;one&quot;
mysql&gt; SELECT CASE WHEN 1&gt;0 THEN &quot;true&quot; ELSE &quot;false&quot; END;
       -&gt; &quot;true&quot;
mysql&gt; SELECT CASE BINARY &quot;B&quot; when &quot;a&quot; then 1 when &quot;b&quot; then 2 END;
       -&gt; NULL
</pre>
  </dd>
</dl>

<h3><a NAME="Mathematical_functions" HREF="manual_toc.html#Mathematical_functions">7.4.9 
數學函數</a></h3>

<p>所有的數學函數在一個出錯的情況下返回<code>NULL</code>。 

<dl COMPACT="Mathematical_functions">
  <dt><code>-</code> </dt>
  <dd><a NAME="IDX343"></a> <a NAME="IDX344"></a> <a NAME="IDX345"></a>單目減。改變參數的符號。 
    <pre>mysql&gt; select - 2;
</pre>
    <pre>注意，如果這個操作符與一個<code>BIGINT</code>使用，返回值是一個<code>BIGINT</code>！這意味著你應該避免在整數上使用<code>-</code>，那可能有值<code>-2^63</code>！ </pre>
  </dd>
  <dt><code>ABS(X)</code> </dt>
  <dd>返回<code>X</code>的絕對值。 <pre>mysql&gt; select ABS(2);
        -&gt; 2
mysql&gt; select ABS(-32);
        -&gt; 32
</pre>
    <p>該功能可安全用於<code>BIGINT</code>值。 <a NAME="IDX347"></a> </p>
  </dd>
  <dt><code>SIGN(X)</code> </dt>
  <dd>返回參數的符號，為<code>-1</code>、<code>0</code>或<code>1</code>，取決於<code>X</code>是否是負數、零或正數。 
    <pre>mysql&gt; select SIGN(-32);
        -&gt; -1
mysql&gt; select SIGN(0);
        -&gt; 0
mysql&gt; select SIGN(234);
        -&gt; 1
<a NAME="IDX348"></a> <a NAME="IDX349"></a> <a NAME="IDX350"></a> </pre>
  </dd>
  <dt><code>MOD(N,M)</code> </dt>
  <dd>　</dd>
  <dt><code>%</code> </dt>
  <dd>模 (類似C中的<code>%</code>操作符)。返回<code>N</code>被<code>M</code>除的餘數。 
    <pre>mysql&gt; select MOD(234, 10);
        -&gt; 4
mysql&gt; select 253 % 7;
        -&gt; 1
mysql&gt; select MOD(29,9);
        -&gt; 2
</pre>
    <pre>這個函數可安全用於<code>BIGINT</code>值。 <a NAME="IDX351"></a> </pre>
  </dd>
  <dt><code>FLOOR(X)</code> </dt>
  <dd>返回不大於<code>X</code>的最大整數值。 <pre>
</pre>
    <pre>mysql&gt; select FLOOR(1.23);
        -&gt; 1
mysql&gt; select FLOOR(-1.23);
        -&gt; -2
</pre>
    <pre>注意返回值被變換為一個<code>BIGINT</code>！ <a NAME="IDX352"></a> </pre>
  </dd>
  <dt><code>CEILING(X)</code> </dt>
  <dd>返回不小於<code>X</code>的最小整數值。 <pre>mysql&gt; select CEILING(1.23);
        -&gt; 2
mysql&gt; select CEILING(-1.23);
        -&gt; -1
</pre>
    <p>注意返回值被變換為一個<code>BIGINT</code>！ <a NAME="IDX353"></a> </p>
  </dd>
  <dt><code>ROUND(X)</code> </dt>
  <dd>返回參數<code>X</code>的四捨五入的一個整數。 <pre>mysql&gt; select ROUND(-1.23);
        -&gt; -1
mysql&gt; select ROUND(-1.58);
        -&gt; -2
mysql&gt; select ROUND(1.58);
        -&gt; 2
 </pre>
    <p>注意返回值被變換為一個<code>BIGINT</code>! <a NAME="IDX354"></a> </p>
  </dd>
  <dt><code>ROUND(X,D)</code> </dt>
  <dd>返回參數<code>X</code>的四捨五入的有<code>D</code>為小數的一個數字。如果<code>D</code>為<code>0</code>，結果將沒有小數點或小數部分。 
    <pre>mysql&gt; select ROUND(1.298, 1);
        -&gt; 1.3
mysql&gt; select ROUND(1.298, 0);
        -&gt; 1
</pre>
    <p>注意返回值被變換為一個<code>BIGINT</code>! <a NAME="IDX355"></a> </p>
  </dd>
  <dt><code>EXP(X)</code> </dt>
  <dd>返回值<code>e</code>（自然對數的底）的<code>X</code>次方。 <pre>mysql&gt; select EXP(2);
        -&gt; 7.389056
mysql&gt; select EXP(-2);
        -&gt; 0.135335
<a NAME="IDX356"></a> </pre>
  </dd>
  <dt><code>LOG(X)</code> </dt>
  <dd>返回<code>X</code>的自然對數。 <pre>mysql&gt; select LOG(2);
        -&gt; 0.693147
mysql&gt; select LOG(-2);
        -&gt; NULL
</pre>
    <p>如果你想要一個數字<code>X</code>的任意底<code>B</code>的對數，使用公式<code>LOG(X)/LOG(B)</code>。 
    <a NAME="IDX357"></a> </p>
  </dd>
  <dt><code>LOG10(X)</code> </dt>
  <dd>返回<code>X</code>的以10為底的對數。 <pre>mysql&gt; select LOG10(2);
        -&gt; 0.301030
mysql&gt; select LOG10(100);
        -&gt; 2.000000
mysql&gt; select LOG10(-100);
        -&gt; NULL
</pre>
  </dd>
  <dt><code>POW(X,Y)</code> </dt>
  <dd>　</dd>
  <dt><code>POWER(X,Y)</code> </dt>
  <dd>返回值<code>X</code>的<code>Y</code>次冪。 <pre>mysql&gt; select POW(2,2);
        -&gt; 4.000000
mysql&gt; select POW(2,-2);
        -&gt; 0.250000</pre>
  </dd>
  <dt><code>SQRT(X)</code> </dt>
  <dd>返回非負數<code>X</code>的平方根。 <pre>mysql&gt; select SQRT(4);
        -&gt; 2.000000
mysql&gt; select SQRT(20);
        -&gt; 4.472136
<a NAME="IDX361"></a> </pre>
  </dd>
  <dt><code>PI()</code> </dt>
  <dd>返回PI的值（圓周率）。 <pre>mysql&gt; select PI();
        -&gt; 3.141593
</pre>
  </dd>
  <dt><code>COS(X)</code> </dt>
  <dd>返回<code>X</code>的餘弦, 在這裡<code>X</code>以弧度給出。 <pre>mysql&gt; select COS(PI());
        -&gt; -1.000000
<a NAME="IDX363"></a> </pre>
  </dd>
  <dt><code>SIN(X)</code> </dt>
  <dd>返回<code>X</code>的正弦值，在此<code>X</code>以弧度給出。 <pre>mysql&gt; select SIN(PI());
        -&gt; 0.000000
<a NAME="IDX364"></a> </pre>
  </dd>
  <dt><code>TAN(X)</code> </dt>
  <dd>返回<code>X</code>的正切值，在此<code>X</code>以弧度給出。 <pre>mysql&gt; select TAN(PI()+1);
        -&gt; 1.557408
<a NAME="IDX365"></a> </pre>
  </dd>
  <dt><code>ACOS(X)</code> </dt>
  <dd>返回<code>X</code>反餘弦，即其餘弦值是<code>X</code>。如果<code>X</code>不在<code>-1</code>到<code>1</code>的範圍，返回<code>NULL</code>。 
    <pre>mysql&gt; select ACOS(1);
        -&gt; 0.000000
mysql&gt; select ACOS(1.0001);
        -&gt; NULL
mysql&gt; select ACOS(0);
        -&gt; 1.570796
<a NAME="IDX366"></a> </pre>
  </dd>
  <dt><code>ASIN(X)</code> </dt>
  <dd>返回<code>X</code>反正弦值，即其正弦值是<code>X</code>。<code>L</code>如果<code>X</code>不在<code>-1</code>到<code>1</code>的範圍，返回<code>NULL</code>。 
    <pre>mysql&gt; select ASIN(0.2);
        -&gt; 0.201358
mysql&gt; select ASIN('foo');
        -&gt; 0.000000
<a NAME="IDX367"></a> </pre>
  </dd>
  <dt><code>ATAN(X)</code> </dt>
  <dd>返回<code>X</code>的反正切值，即其正切值是<code>X</code>。 <pre>mysql&gt; select ATAN(2);
        -&gt; 1.107149
mysql&gt; select ATAN(-2);
        -&gt; -1.107149</pre>
  </dd>
  <dt><code>ATAN2(X,Y)</code> </dt>
  <dd>返回2個變數<code>X</code>和<code>Y</code>的反正切。它類似於計算<code>Y/X</code>的反正切，除了兩個參數的符號被用來決定結果的像限。 
    <pre>mysql&gt; select ATAN(-2,2);
        -&gt; -0.785398
mysql&gt; select ATAN(PI(),0);
        -&gt; 1.570796<a NAME="IDX369"></a> </pre>
  </dd>
  <dt><code>COT(X)</code> </dt>
  <dd>返回<code>X</code>的餘切。 <pre>mysql&gt; select COT(12);
        -&gt; -1.57267341
mysql&gt; select COT(0);
        -&gt; NULL
</pre>
  </dd>
  <dt><code>RAND()</code> </dt>
  <dd>　</dd>
  <dt><code>RAND(N)</code> </dt>
  <dd>返回在範圍<code>0</code>到<code>1.0</code>內的隨機浮點值。如果一個整數參數<code>N</code>被指定，它被用作種子值。 
    <pre>mysql&gt; select RAND();
        -&gt; 0.5925
mysql&gt; select RAND(20);
        -&gt; 0.1811
mysql&gt; select RAND(20);
        -&gt; 0.1811
mysql&gt; select RAND();
        -&gt; 0.2079
mysql&gt; select RAND();
        -&gt; 0.7888
</pre>
    <p>你不能在一個<code>ORDER BY</code>子句用<code>RAND()</code>值使用列，因為<code>ORDER 
    BY</code>將重複計算列多次。然而在<strong>MySQL</strong>3.23中，你可以做： 
    <code>SELECT * FROM table_name ORDER BY RAND()</code>，這是有利於得到一個來自<code>SELECT 
    * FROM table1,table2 WHERE a=b AND c&lt;d ORDER BY RAND() LIMIT 1000</code>的集合的隨機樣本。注意在一個<code>WHERE</code>子句裡的一個<code>RAND()</code>將在每次<code>WHERE</code>被執行時重新評估。 
    <a NAME="IDX371"></a> </p>
  </dd>
  <dt><code>LEAST(X,Y,...)</code> </dt>
  <dd>有2和2個以上的參數，返回最小(最小值)的參數。參數使用下列規則進行比較： 
    <ul>
      <li>如果返回值被使用在一個<code>INTEGER</code>上下文，或所有的參數都是整數值，他們作為整數比較。 
      </li>
      <li>如果返回值被使用在一個<code>REAL</code>上下文，或所有的參數是實數值，他們作為實數比較。 
      </li>
      <li>如果任何參數是一個大小敏感的字符串，參數作為大小寫敏感的字符串被比較。 
      </li>
      <li>在其他的情況下，參數作為大小寫無關的字符串被比較。 </li>
    </ul>
    <pre>mysql&gt; select LEAST(2,0);
        -&gt; 0
mysql&gt; select LEAST(34.0,3.0,5.0,767.0);
        -&gt; 3.0
mysql&gt; select LEAST(&quot;B&quot;,&quot;A&quot;,&quot;C&quot;);
        -&gt; &quot;A&quot;
</pre>
    <p>在<strong>MySQL</strong> 3.22.5以前的版本，你可以使用<code>MIN()</code>而不是<code>LEAST</code>。 
    <a NAME="IDX372"></a> </p>
  </dd>
  <dt><code>GREATEST(X,Y,...)</code> </dt>
  <dd>返回最大(最大值)的參數。參數使用與<code>LEAST</code>一樣的規則進行比較。 
    <pre>mysql&gt; select GREATEST(2,0);
        -&gt; 2
mysql&gt; select GREATEST(34.0,3.0,5.0,767.0);
        -&gt; 767.0
mysql&gt; select GREATEST(&quot;B&quot;,&quot;A&quot;,&quot;C&quot;);
        -&gt; &quot;C&quot;
</pre>
    <pre>在<strong>MySQL</strong>在 3.22.5 以前的版本, 你能使用<code>MAX()</code>而不是<code>GREATEST</code>. <a NAME="IDX373"></a> </pre>
  </dd>
  <dt><code>DEGREES(X)</code> </dt>
  <dd>返回參數<code>X</code>，從弧度變換為角度。 <pre>mysql&gt; select DEGREES(PI());
        -&gt; 180.000000</pre>
  </dd>
  <dt><code>RADIANS(X)</code> </dt>
  <dd>返回參數<code>X</code>，從角度變換為弧度。 <pre>mysql&gt; select RADIANS(90);
        -&gt; 1.570796
</pre>
  </dd>
  <dt><code>TRUNCATE(X,D)</code> </dt>
  <dd>返回數字<code>X</code>，截斷為<code>D</code>位小數。如果<code>D</code>為<code>0</code>，結果將沒有小數點或小數部分。 
    <pre>mysql&gt; select TRUNCATE(1.223,1);
        -&gt; 1.2
mysql&gt; select TRUNCATE(1.999,1);
        -&gt; 1.9
mysql&gt; select TRUNCATE(1.999,0);
        -&gt; 1
 </pre>
  </dd>
</dl>

<h3><a NAME="String_functions" HREF="manual_toc.html#String_functions">7.4.10 
字符串函數</a></h3>

<p>如果結果的長度大於伺服器參數<code>max_allowed_packet</code>，字符串值函數返回<code>NULL</code>。見<a HREF="manual_Performance.html#Server_parameters">10.2.3 調節伺服器參數</a>。 </p>

<p>對於針對字符串位置的操作，第一個位置被標記為1。 

<dl COMPACT="manual_Performance.html#Server_parameters">
  <dt><code>ASCII(str)</code> </dt>
  <dd><a NAME="IDX378"></a>返回字符串<code>str</code>的最左面字符的ASCII代碼值。如果<code>str</code>是空字符串，返回<code>0</code>。如果<code>str</code>是<code>NULL</code>，返回<code>NULL</code>。 
    <pre>mysql&gt; select ASCII('2');
        -&gt; 50
mysql&gt; select ASCII(2);
        -&gt; 50
mysql&gt; select ASCII('dx');
        -&gt; 100</pre>
    <p>也可參見ORD()函數。 <a NAME="IDX379"></a> </p>
  </dd>
  <dt><code>ORD(str)</code> </dt>
  <dd>如果字符串str最左面字符是一個多字節字符，通過以格式<code>((first 
    byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code...]</code>返回字符的ASCII代碼值來返回多字節字符代碼。如果最左面的字符不是一個多字節字符。返回與<code>ASCII()</code>函數返回的相同值。<pre>mysql&gt; select ORD('2');
        -&gt; 50
 </pre>
  </dd>
  <dt><code>CONV(N,from_base,to_base)</code> </dt>
  <dd>在不同的數字基之間變換數字。返回數字<code>N</code>的字符串數字，從<code>from_base</code>基變換為<code>to_base</code>基，如果任何參數是<code>NULL</code>，返回<code>NULL</code>。參數<code>N</code>解釋為一個整數，但是可以指定為一個整數或一個字符串。最小基是<code>2</code>且最大的基是<code>36</code>。如果<code>to_base</code>是一個負數，<code>N</code>被認為是一個有符號數，否則，<code>N</code>被當作無符號數。 
    <code>CONV</code>以64位點精度工作。 <pre>mysql&gt; select CONV(&quot;a&quot;,16,2);
        -&gt; '1010'
mysql&gt; select CONV(&quot;6E&quot;,18,8);
        -&gt; '172'
mysql&gt; select CONV(-17,10,-18);
        -&gt; '-H'
mysql&gt; select CONV(10+&quot;10&quot;+'10'+0xa,10,10);
        -&gt; '40'
<a NAME="IDX381"></a> </pre>
  </dd>
  <dt><code>BIN(N)</code> </dt>
  <dd>返回二進制值<code>N</code>的一個字符串表示，在此<code>N</code>是一個長整數(<code>BIGINT</code>)數字，這等價於<code>CONV(N,10,2)</code>。如果<code>N</code>是<code>NULL</code>，返回<code>NULL</code>。 
    <pre>mysql&gt; select BIN(12);
        -&gt; '1100'
</pre>
  </dd>
  <dt><code>OCT(N)</code> </dt>
  <dd>返回八進制值<code>N</code>的一個字符串的表示，在此<code>N</code>是一個長整型數字，這等價於<code>CONV(N,10,8)</code>。如果<code>N</code>是NULL，返回<code>NULL</code>。 
    <pre>mysql&gt; select OCT(12);
        -&gt; '14'
 </pre>
  </dd>
  <dt><code>HEX(N)</code> </dt>
  <dd>返回十六進制值<code>N</code>一個字符串的表示，在此<code>N</code>是一個長整型(<code>BIGINT</code>)數字，這等價於<code>CONV(N,10,16)</code>。如果<code>N</code>是<code>NULL</code>，返回<code>NULL</code>。 
    <pre>mysql&gt; select HEX(255);
        -&gt; 'FF'
<a NAME="IDX384"></a> </pre>
  </dd>
  <dt><code>CHAR(N,...)</code> </dt>
  <dd><code>CHAR()</code>將參數解釋為整數並且返回由這些整數的ASCII代碼字符組成的一個字符串。<code>NULL</code>值被跳過。 
    <pre>mysql&gt; select CHAR(77,121,83,81,'76');
        -&gt; 'MySQL'
mysql&gt; select CHAR(77,77.3,'77.3');
        -&gt; 'MMM'
 </pre>
  </dd>
  <dt><code>CONCAT(str1,str2,...)</code> </dt>
  <dd>返回來自於參數連結的字符串。如果任何參數是<code>NULL</code>，返回<code>NULL</code>。可以有超過2個的參數。一個數字參數被變換為等價的字符串形式。 
    <pre>mysql&gt; select CONCAT('My', 'S', 'QL');
        -&gt; 'MySQL'
mysql&gt; select CONCAT('My', NULL, 'QL');
        -&gt; NULL
mysql&gt; select CONCAT(14.3);
        -&gt; '14.3'
</pre>
  </dd>
  <dt><code>LENGTH(str)</code> </dt>
  <dd>　</dd>
  <dt><code>OCTET_LENGTH(str)</code> </dt>
  <dd>　</dd>
  <dt><code>CHAR_LENGTH(str)</code> </dt>
  <dd>　</dd>
  <dt><code>CHARACTER_LENGTH(str)</code> </dt>
  <dd>返回字符串<code>str</code>的長度。 <pre>mysql&gt; select LENGTH('text');
        -&gt; 4
mysql&gt; select OCTET_LENGTH('text');
        -&gt; 4
</pre>
    <p>注意，對於多字節字符，其CHAR_LENGTH()僅計算一次。 <a NAME="IDX390"></a> 
    <a NAME="IDX391"></a> </p>
  </dd>
  <dt><code>LOCATE(substr,str)</code> </dt>
  <dd>　</dd>
  <dt><code>POSITION(substr IN str)</code> </dt>
  <dd>返回子串<code>substr</code>在字符串<code>str</code>第一個出現的位置，如果<code>substr</code>不是在<code>str</code>裡面，返回<code>0</code>. 
    <pre>mysql&gt; select LOCATE('bar', 'foobarbar');
        -&gt; 4
mysql&gt; select LOCATE('xbar', 'foobar');
        -&gt; 0
</pre>
    <pre>該函數是多字節可靠的。 <a NAME="IDX392"></a> </pre>
  </dd>
  <dt><code>LOCATE(substr,str,pos)</code> </dt>
  <dd>返回子串<code>substr</code>在字符串<code>str</code>第一個出現的位置，從位置<code>pos</code>開始。如果<code>substr</code>不是在<code>str</code>裡面，返回<code>0</code>。<pre>mysql&gt; select LOCATE('bar', 'foobarbar',5);
        -&gt; 7
</pre>
    <p>這函數是多字節可靠的。 <a NAME="IDX393"></a> </p>
  </dd>
  <dt><code>INSTR(str,substr)</code> </dt>
  <dd>返回子串<code>substr</code>在字符串<code>str</code>中的第一個出現的位置。這與有2個參數形式的<code>LOCATE()</code>相同，除了參數被顛倒。 
    <pre>mysql&gt; select INSTR('foobarbar', 'bar');
        -&gt; 4
mysql&gt; select INSTR('xbar', 'foobar');
        -&gt; 0
</pre>
    <p>這函數是多字節可靠的。 <a NAME="IDX394"></a> </p>
  </dd>
  <dt><code>LPAD(str,len,padstr)</code> </dt>
  <dd>返回字符串<code>str</code>，左面用字符串<code>padstr</code>填補直到<code>str</code>是<code>len</code>個字符長。 
    <pre>mysql&gt; select LPAD('hi',4,'??');
        -&gt; '??hi'
<a NAME="IDX395"></a> </pre>
  </dd>
  <dt><code>RPAD(str,len,padstr)</code> </dt>
  <dd>返回字符串<code>str</code>，右面用字符串<code>padstr</code>填補直到<code>str</code>是<code>len</code>個字符長。 
    &nbsp; <pre>mysql&gt; select RPAD('hi',5,'?');
        -&gt; 'hi???'
</pre>
  </dd>
  <dt><code>LEFT(str,len)</code> </dt>
  <dd>返回字符串<code>str</code>的最左面<code>len</code>個字符。<pre>mysql&gt; select LEFT('foobarbar', 5);
        -&gt; 'fooba'
</pre>
    <p>該函數是多字節可靠的。 <a NAME="IDX397"></a> </p>
  </dd>
  <dt><code>RIGHT(str,len)</code> </dt>
  <dd>返回字符串<code>str</code>的最右面<code>len</code>個字符<code>。</code> <pre>mysql&gt; select RIGHT('foobarbar', 4);
        -&gt; 'rbar'
</pre>
    <p>該函數是多字節可靠的。 <a NAME="IDX398"></a> <a NAME="IDX399"></a> </p>
  </dd>
  <dt><code>SUBSTRING(str,pos,len)</code> </dt>
  <dd>　</dd>
  <dt><code>SUBSTRING(str FROM pos FOR len)</code> </dt>
  <dd>　</dd>
  <dt><code>MID(str,pos,len)</code> </dt>
  <dd>從字符串<code>str</code>返回一個<code>len</code>個字符的子串，從位置<code>pos</code>開始。使用<code>FROM</code>的變種形式是ANSI 
    SQL92語法。 <pre>mysql&gt; select SUBSTRING('Quadratically',5,6);
        -&gt; 'ratica'
</pre>
    <p>該函數是多字節可靠的。 <a NAME="IDX400"></a> </p>
  </dd>
  <dt><code>SUBSTRING(str,pos)</code> </dt>
  <dd>　</dd>
  <dt><code>SUBSTRING(str FROM pos)</code> </dt>
  <dd>從字符串<code>str</code>的起始位置<code>pos</code>返回一個子串。 <pre>mysql&gt; select SUBSTRING('Quadratically',5);
        -&gt; 'ratically'
mysql&gt; select SUBSTRING('foobarbar' FROM 4);
        -&gt; 'barbar'
</pre>
    <p>該函數是多字節可靠的。 <a NAME="IDX401"></a> </p>
  </dd>
  <dt><code>SUBSTRING_INDEX(str,delim,count)</code> </dt>
  <dd>返回從字符串<code>str</code>的第<code>count</code>個出現<code>的</code>分隔符<code>delim</code>之後的子串。如果<code>count</code>是正數，返回最後的分隔符到左邊(從左邊數) 
    的所有字符。如果<code>count</code>是負數，返回最後的分隔符到右邊的所有字符(從右邊數)。 
    <pre>mysql&gt; select SUBSTRING_INDEX('www.mysql.com', '.', 2);
        -&gt; 'www.mysql'
mysql&gt; select SUBSTRING_INDEX('www.mysql.com', '.', -2);
        -&gt; 'mysql.com'
</pre>
    <p>該函數對多字節是可靠的。 <a NAME="IDX402"></a> </p>
  </dd>
  <dt><code>LTRIM(str)</code> </dt>
  <dd>返回刪除了其前置空格字符的字符串<code>str</code>。 <pre>mysql&gt; select LTRIM('  barbar');
        -&gt; 'barbar'
</pre>
  </dd>
  <dt><code>RTRIM(str)</code> </dt>
  <dd>返回刪除了其拖後空格字符的字符串<code>str</code>。 <pre>mysql&gt; select RTRIM('barbar   ');
        -&gt; 'barbar'
</pre>
    <pre>該函數對多字節是可靠的。 <a NAME="IDX404"></a> </pre>
  </dd>
  <dt><code>TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)</code> </dt>
  <dd>返回字符串<code>str</code>，其所有<code>remstr</code>前綴或後綴被刪除了。如果沒有修飾符<code>BOTH</code>、<code>LEADING</code>或<code>TRAILING</code>給出，<code>BOTH</code>被假定。如果<code>remstr</code>沒被指定，空格被刪除。 
    <pre>mysql&gt; select TRIM('  bar   ');
        -&gt; 'bar'
mysql&gt; select TRIM(LEADING 'x' FROM 'xxxbarxxx');
        -&gt; 'barxxx'
mysql&gt; select TRIM(BOTH 'x' FROM 'xxxbarxxx');
        -&gt; 'bar'
mysql&gt; select TRIM(TRAILING 'xyz' FROM 'barxxyz');
        -&gt; 'barx'
</pre>
    <p>該函數對多字節是可靠的。 <a NAME="IDX405"></a> </p>
  </dd>
  <dt><code>SOUNDEX(str)</code> </dt>
  <dd>返回<code>str</code>的一個同音字符串。聽起來“大致相同”的2個字符串應該有相同的同音字符串。一個“標準”的同音字符串長是4個字符，但是<code>SOUNDEX()</code>函數返回一個任意長的字符串。你可以在結果上使用<code>SUBSTRING()</code>得到一個“標準”的 
    同音串。所有非數字字母字符在給定的字符串中被忽略。所有在A-Z之外的字符國際字母被當作元音。 
    <pre>mysql&gt; select SOUNDEX('Hello');
        -&gt; 'H400'
mysql&gt; select SOUNDEX('Quadratically');
        -&gt; 'Q36324'
<a NAME="IDX406"></a> </pre>
  </dd>
  <dt><code>SPACE(N)</code> </dt>
  <dd>返回由<code>N</code>個空格字符組成的一個字符串。 <pre>mysql&gt; select SPACE(6);
        -&gt; '      '
<a NAME="IDX407"></a> </pre>
  </dd>
  <dt><code>REPLACE(str,from_str,to_str)</code> </dt>
  <dd>返回字符串<code>str</code>，其字符串<code>from_str</code>的所有出現由字符串<code>to_str</code>代替。 
    <pre>mysql&gt; select REPLACE('www.mysql.com', 'w', 'Ww');
        -&gt; 'WwWwWw.mysql.com'
</pre>
    <p>該函數對多字節是可靠的。 <a NAME="IDX408"></a> </p>
  </dd>
  <dt><code>REPEAT(str,count)</code> </dt>
  <dd>返回由重複<code>count</code>Times次的字符串<code>str</code>組成的一個字符串。如果<code>count 
    &lt;= 0</code>，返回一個空字符串。如果<code>str</code>或<code>count</code>是<code>NULL</code>，返回<code>NULL</code>。 
    <pre>mysql&gt; select REPEAT('MySQL', 3);
        -&gt; 'MySQLMySQLMySQL'
<a NAME="IDX409"></a> </pre>
  </dd>
  <dt><code>REVERSE(str)</code> </dt>
  <dd>返回顛倒字符順序的字符串<code>str</code>。 <pre>mysql&gt; select REVERSE('abc');
        -&gt; 'cba'
</pre>
    <p>該函數對多字節可靠的。 <a NAME="IDX410"></a> </p>
  </dd>
  <dt><code>INSERT(str,pos,len,newstr)</code> </dt>
  <dd>返回字符串<code>str</code>，在位置<code>pos</code>起始的子串且<code>len</code>個字符長得子串由字符串<code>newstr</code>代替。 
    <pre>mysql&gt; select INSERT('Quadratic', 3, 4, 'What');
        -&gt; 'QuWhattic'
</pre>
    <p>該函數對多字節是可靠的。 <a NAME="IDX411"></a> </p>
  </dd>
  <dt><code>ELT(N,str1,str2,str3,...)</code> </dt>
  <dd>如果<code>N</code>= <code>1</code>，返回<code>str1</code>，如果<code>N</code>= <code>2</code>，返回<code>str2</code>，等等。如果<code>N</code>小於<code>1</code>或大於參數個數，返回<code>NULL</code>。<code>ELT()</code>是<code>FIELD()</code>反運算。 
    <pre>mysql&gt; select ELT(1, 'ej', 'Heja', 'hej', 'foo');
        -&gt; 'ej'
mysql&gt; select ELT(4, 'ej', 'Heja', 'hej', 'foo');
        -&gt; 'foo'
</pre>
  </dd>
  <dt><code>FIELD(str,str1,str2,str3,...)</code> </dt>
  <dd>返回<code>str</code>在<code>str1</code>, <code>str2</code>, <code>str3</code>, <code>...</code>清單的索引。如果<code>str</code>沒找到，返回<code>0</code>。<code>FIELD()</code>是<code>ELT()</code>反運算。 
    <pre>mysql&gt; select FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&gt; 2
mysql&gt; select FIELD('fo', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&gt; 0
</pre>
  </dd>
  <dt><code>FIND_IN_SET(str,strlist)</code> </dt>
  <dd>如果字符串<code>str</code>在由<code>N</code>子串組成的表<code>strlist</code>之中，返回一個<code>1</code>到<code>N</code>的值。一個字符串表是被<samp>“,”</samp>分隔的子串組成的一個字符串。如果第一個參數是一個常數字符串並且第二個參數是一種類型為<code>SET</code>的列，<code>FIND_IN_SET()</code>函數被最佳化而使用位運算！如果<code>str</code>不是在<code>strlist</code>裡面或如果<code>strlist</code>是空字符串，返回<code>0</code>。如果任何一個參數是<code>NULL</code>，返回<code>NULL</code>。如果第一個參數包含一個<samp>“,”</samp>，該函數將工作不正常。 
    <pre>mysql&gt; SELECT FIND_IN_SET('b','a,b,c,d');
        -&gt; 2
<a NAME="IDX414"></a> </pre>
  </dd>
  <dt><code>MAKE_SET(bits,str1,str2,...)</code> </dt>
  <dd>返回一個集合 (包含由<samp>“,”</samp>字符分隔的子串組成的一個字符串)，由相應的位在<code>bits</code>集合中的的字符串組成。<code>str1</code>對應於位0，<code>str2</code>對應位1，等等。在<code>str1</code>, 
    <code>str2</code>, <code>...</code>中的<code>NULL</code>串不添加到結果中。 <pre>mysql&gt; SELECT MAKE_SET(1,'a','b','c');
        -&gt; 'a'
mysql&gt; SELECT MAKE_SET(1 | 4,'hello','nice','world');
        -&gt; 'hello,world'
mysql&gt; SELECT MAKE_SET(0,'a','b','c');
        -&gt; ''
</pre>
  </dd>
  <dt><code>EXPORT_SET(bits,on,off,[separator,[number_of_bits]])</code> </dt>
  <dd>返回一個字符串，在這裡對於在“bits”中設定每一位，你得到一個“on”字符串，並且對於每個復位(reset)的位，你得到一個“off”字符串。每個字符串用“separator”分隔(預設“,”)，並且只有“bits”的“number_of_bits” 
    (預設64)位被使用。 <pre>mysql&gt; select EXPORT_SET(5,'Y','N',',',4)
        -&gt; Y,N,Y,N 
</pre>
  </dd>
  <dt><code>LCASE(str)</code> </dt>
  <dd>　</dd>
  <dt><code>LOWER(str)</code> </dt>
  <dd>返回字符串<code>str</code>，根據當前字符集映射(預設是ISO-8859-1 
    Latin1)把所有的字符改變成小寫。該函數對多字節是可靠的。 <pre>mysql&gt; select LCASE('QUADRATICALLY');
        -&gt; 'quadratically'
<a NAME="IDX419"></a> </pre>
  </dd>
  <dt><code>UCASE(str)</code> </dt>
  <dd>　</dd>
  <dt><code>UPPER(str)</code> </dt>
  <dd>返回字符串<code>str</code>，根據當前字符集映射(預設是ISO-8859-1 
    Latin1)把所有的字符改變成大寫。該函數對多字節是可靠的。 <pre>mysql&gt; select UCASE('Hej');
        -&gt; 'HEJ'
</pre>
    <p>該函數對多字節是可靠的。 <a NAME="IDX420"></a> </p>
  </dd>
  <dt><code>LOAD_FILE(file_name)</code> </dt>
  <dd>讀入文件並且作為一個字符串返回文件內容。文件必須在伺服器上，你必須指定到文件的完整路徑名，而且你必須有<strong>file</strong>權限。文件必須所有內容都是可讀的並且小於<code>max_allowed_packet</code>。如果文件不存在或由於上面原因之一不能被讀出，函數返回<code>NULL</code>。 
    <pre>mysql&gt; UPDATE table_name
           SET blob_column=LOAD_FILE(&quot;/tmp/picture&quot;)
           WHERE id=1;

</pre>
  </dd>
</dl>

<p><strong>MySQL</strong>必要時自動變換數字為字符串，並且反過來也如此： 
</p>

<pre>mysql&gt; SELECT 1+&quot;1&quot;;
        -&gt; 2
mysql&gt; SELECT CONCAT(2,' test');
        -&gt; '2 test'
</pre>

<p>如果你想要明確地變換一個數字到一個字符串，把它作為參數傳遞到<code>CONCAT()</code>。 
</p>

<p>如果字符串函數提供一個二進制字符串作為參數，結果字符串也是一個二進制字符串。被變換到一個字符串的數字被當作是一個二進制字符串。這僅影響比較。 
</p>

<h3><a NAME="Date_and_time_functions" HREF="manual_toc.html#Date_and_time_functions">7.4.11 
日期和時間函數</a></h3>

<p>對於每個類型擁有的值範圍以及並且指定日期何時間值的有效格式的描述見<a HREF="manual_Reference.html#Date_and_time_types">7.3.6 日期和時間類型</a>。 </p>

<p>這裡是一個使用日期函數的例子。下面的查詢選擇了所有記錄，其<code>date_col</code>的值是在最後30天以內： 
</p>

<pre>mysql&gt; SELECT something FROM table
           WHERE TO_DAYS(NOW()) - TO_DAYS(date_col) &lt;= 30;
</pre>

<dl COMPACT="manual_Reference.html#Date_and_time_types">
  <dt><code>DAYOFWEEK(date)</code> </dt>
  <dd><a NAME="IDX423"></a>返回日期<code>date</code>的星期索引(<code>1</code>=星期天，<code>2</code>=星期一, 
    ……<code>7</code>=星期六)。這些索引值對應於ODBC標準。 <pre>mysql&gt; select DAYOFWEEK('1998-02-03');
        -&gt; 3
<a NAME="IDX424"></a> </pre>
  </dd>
  <dt><code>WEEKDAY(date)</code> </dt>
  <dd>返回<code>date</code>的星期索引(<code>0</code>=星期一，<code>1</code>=星期二, 
    ……<code>6</code>= 星期天)。 <pre>mysql&gt; select WEEKDAY('1997-10-04 22:23:00');
        -&gt; 5
mysql&gt; select WEEKDAY('1997-11-05');
        -&gt; 2
<a NAME="IDX425"></a> </pre>
  </dd>
  <dt><code>DAYOFMONTH(date)</code> </dt>
  <dd>返回<code>date</code>的月份中日期，在<code>1</code>到<code>31</code>範圍內。 
    <pre>mysql&gt; select DAYOFMONTH('1998-02-03');
        -&gt; 3
</pre>
  </dd>
  <dt><code>DAYOFYEAR(date)</code> </dt>
  <dd>返回<code>date</code>在一年中的日數, 在<code>1</code>到<code>366</code>範圍內。 
    <pre>mysql&gt; select DAYOFYEAR('1998-02-03');
        -&gt; 34
</pre>
  </dd>
  <dt><code>MONTH(date)</code> </dt>
  <dd>返回<code>date</code>的月份，範圍<code>1</code>到<code>12</code>。 <pre>mysql&gt; select MONTH('1998-02-03');
        -&gt; 2
 </pre>
  </dd>
  <dt><code>DAYNAME(date)</code> </dt>
  <dd>返回<code>date</code>的星期名字。 <pre>mysql&gt; select DAYNAME(&quot;1998-02-05&quot;);
        -&gt; 'Thursday'
</pre>
  </dd>
  <dt><code>MONTHNAME(date)</code> </dt>
  <dd>返回<code>date</code>的月份名字。 <pre>mysql&gt; select MONTHNAME(&quot;1998-02-05&quot;);
        -&gt; 'February'
<a NAME="IDX430"></a> </pre>
  </dd>
  <dt><code>QUARTER(date)</code> </dt>
  <dd>返回<code>date</code>一年中的季度，範圍<code>1</code>到<code>4</code>。 <pre>mysql&gt; select QUARTER('98-04-01');
        -&gt; 2
 </pre>
  </dd>
  <dt><code>WEEK(date)</code> </dt>
  <dd>　</dd>
  <dt><code>WEEK(date,first)</code> </dt>
  <dd>對於星期天是一周的第一天的地方，有一個單個參數，返回<code>date</code>的周數，範圍在<code>0</code>到<code>52</code>。2個參數形式<code>WEEK()</code>允許你指定星期是否開始於星期天或星期一。如果第二個參數是<code>0</code>，星期從星期天開始，如果第二個參數是<code>1</code>，從星期一開始。 
    <pre>mysql&gt; select WEEK('1998-02-20');
        -&gt; 7
mysql&gt; select WEEK('1998-02-20',0);
        -&gt; 7
mysql&gt; select WEEK('1998-02-20',1);
        -&gt; 8
</pre>
  </dd>
  <dt><code>YEAR(date)</code> </dt>
  <dd>返回<code>date</code>的年份，範圍在<code>1000</code>到<code>9999</code>。<pre>mysql&gt; select YEAR('98-02-03');
        -&gt; 1998
</pre>
  </dd>
  <dt><code>HOUR(time)</code> </dt>
  <dd>返回<code>time</code>的小時，範圍是<code>0</code>到<code>23</code>。<pre>mysql&gt; select HOUR('10:05:03');
        -&gt; 10
</pre>
  </dd>
  <dt><code>MINUTE(time)</code> </dt>
  <dd>返回<code>time</code>的分鐘，範圍是<code>0</code>到<code>59</code>。<pre>mysql&gt; select MINUTE('98-02-03 10:05:03');
        -&gt; 5
</pre>
  </dd>
  <dt><code>SECOND(time)</code> </dt>
  <dd>回來<code>time</code>的秒數，範圍是<code>0</code>到<code>59</code>。<pre>mysql&gt; select SECOND('10:05:03');
        -&gt; 3
</pre>
  </dd>
  <dt><code>PERIOD_ADD(P,N)</code> </dt>
  <dd>增加<code>N</code>個月到階段<code>P</code>（以格式<code>YYMM</code>或<code>YYYYMM</code>)。以格式<code>YYYYMM</code>返回值。注意階段參數<code>P</code><em>不是</em>日期值。 
    <pre>mysql&gt; select PERIOD_ADD(9801,2);
        -&gt; 199803
</pre>
  </dd>
  <dt><code>PERIOD_DIFF(P1,P2)</code> </dt>
  <dd>返回在時期<code>P1</code>和<code>P2</code>之間月數，<code>P1</code>和<code>P2</code>應該以格式<code>YYMM</code>或<code>YYYYMM</code>。注意，時期參數<code>P1</code>和<code>P2</code><em>不是</em>日期值。 
    <pre>mysql&gt; select PERIOD_DIFF(9802,199703);
        -&gt; 11
<a NAME="IDX439"></a> <a NAME="IDX440"></a> <a NAME="IDX441"></a> <a NAME="IDX442"></a> </pre>
  </dd>
  <dt><code>DATE_ADD(date,INTERVAL expr type)</code> </dt>
  <dd>　</dd>
  <dt><code>DATE_SUB(date,INTERVAL expr type)</code> </dt>
  <dd>　</dd>
  <dt><code>ADDDATE(date,INTERVAL expr type)</code> </dt>
  <dd>　</dd>
  <dt><code>SUBDATE(date,INTERVAL expr type)</code> </dt>
  <dd>這些功能執行日期運算。對於<strong>MySQL</strong> 3.22，他們是新的。<code>ADDDATE()</code>和<code>SUBDATE()</code>是<code>DATE_ADD()</code>和<code>DATE_SUB()</code>的同義詞。在<strong>MySQL</strong> 
    3.23中，你可以使用<code>+</code>和<code>-</code>而不是<code>DATE_ADD()</code>和<code>DATE_SUB()</code>。（見例子）<code>date</code>是一個指定開始日期的<code>DATETIME</code>或<code>DATE</code>值，<code>expr</code>是指定加到開始日期或從開始日期減去的間隔值一個表達式，<code>expr</code>是一個字符串﹔它可以以一個<samp>“-”</samp>開始表示負間隔。<code>type</code>是一個關鍵詞，指明表達式應該如何被解釋。<code>EXTRACT(type 
    FROM date)</code>函數從日期中返回“type”間隔。下表顯示了<code>type</code>和<code>expr</code>參數怎樣被關聯： 
    <table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
      <tr>
        <td><code>type</code><strong>值</strong> </td>
        <td><strong>含義</strong> </td>
        <td><strong>期望的</strong><code>expr</code><strong>格式</strong> </td>
      </tr>
      <tr>
        <td><code>SECOND</code> </td>
        <td>秒</td>
        <td><code>SECONDS</code> </td>
      </tr>
      <tr>
        <td><code>MINUTE</code> </td>
        <td>分鐘</td>
        <td><code>MINUTES</code> </td>
      </tr>
      <tr>
        <td><code>HOUR</code> </td>
        <td>時間</td>
        <td><code>HOURS</code> </td>
      </tr>
      <tr>
        <td><code>DAY</code> </td>
        <td>天</td>
        <td><code>DAYS</code> </td>
      </tr>
      <tr>
        <td><code>MONTH</code> </td>
        <td>月</td>
        <td><code>MONTHS</code> </td>
      </tr>
      <tr>
        <td><code>YEAR</code> </td>
        <td>年</td>
        <td><code>YEARS</code> </td>
      </tr>
      <tr>
        <td><code>MINUTE_SECOND</code> </td>
        <td>分鐘和秒</td>
        <td><code>&quot;MINUTES:SECONDS&quot;</code> </td>
      </tr>
      <tr>
        <td><code>HOUR_MINUTE</code> </td>
        <td>小時和分鐘</td>
        <td><code>&quot;HOURS:MINUTES&quot;</code> </td>
      </tr>
      <tr>
        <td><code>DAY_HOUR</code> </td>
        <td>天和小時</td>
        <td><code>&quot;DAYS HOURS&quot;</code> </td>
      </tr>
      <tr>
        <td><code>YEAR_MONTH</code> </td>
        <td>年和月</td>
        <td><code>&quot;YEARS-MONTHS&quot;</code> </td>
      </tr>
      <tr>
        <td><code>HOUR_SECOND</code> </td>
        <td>小時, 分鐘，</td>
        <td><code>&quot;HOURS:MINUTES:SECONDS&quot;</code> </td>
      </tr>
      <tr>
        <td><code>DAY_MINUTE</code> </td>
        <td>天, 小時, 分鐘</td>
        <td><code>&quot;DAYS HOURS:MINUTES&quot;</code> </td>
      </tr>
      <tr>
        <td><code>DAY_SECOND</code> </td>
        <td>天, 小時, 分鐘, 秒</td>
        <td><code>&quot;DAYS HOURS:MINUTES:SECONDS&quot;</code> </td>
      </tr>
    </table>
    <p><strong>MySQL</strong>在<code>expr</code>格式中允許任何標點分隔符。表示顯示的是建議的分隔符。如果<code>date</code>參數是一個<code>DATE</code>值並且你的計算僅僅包含<code>YEAR</code>、<code>MONTH</code>和<code>DAY</code>部分(即，沒有時間部分)，結果是一個<code>DATE</code>值。否則結果是一個<code>DATETIME</code>值。 
    </p>
    <pre>mysql&gt; SELECT &quot;1997-12-31 23:59:59&quot; + INTERVAL 1 SECOND;
        -&gt; 1998-01-01 00:00:00
mysql&gt; SELECT INTERVAL 1 DAY + &quot;1997-12-31&quot;;
        -&gt; 1998-01-01
mysql&gt; SELECT &quot;1998-01-01&quot; - INTERVAL 1 SECOND;
       -&gt; 1997-12-31 23:59:59 
mysql&gt; SELECT DATE_ADD(&quot;1997-12-31 23:59:59&quot;,
                       INTERVAL 1 SECOND);
        -&gt; 1998-01-01 00:00:00
mysql&gt; SELECT DATE_ADD(&quot;1997-12-31 23:59:59&quot;,
                       INTERVAL 1 DAY);
        -&gt; 1998-01-01 23:59:59
mysql&gt; SELECT DATE_ADD(&quot;1997-12-31 23:59:59&quot;,
                       INTERVAL &quot;1:1&quot; MINUTE_SECOND);
        -&gt; 1998-01-01 00:01:00
mysql&gt; SELECT DATE_SUB(&quot;1998-01-01 00:00:00&quot;,
                       INTERVAL &quot;1 1:1:1&quot; DAY_SECOND);
        -&gt; 1997-12-30 22:58:59
mysql&gt; SELECT DATE_ADD(&quot;1998-01-01 00:00:00&quot;,
                       INTERVAL &quot;-1 10&quot; DAY_HOUR);
        -&gt; 1997-12-30 14:00:00
mysql&gt; SELECT DATE_SUB(&quot;1998-01-02&quot;, INTERVAL 31 DAY);
        -&gt; 1997-12-02
mysql&gt; SELECT EXTRACT(YEAR FROM &quot;1999-07-02&quot;);
       -&gt; 1999
mysql&gt; SELECT EXTRACT(YEAR_MONTH FROM &quot;1999-07-02 01:02:03&quot;);
       -&gt; 199907
mysql&gt; SELECT EXTRACT(DAY_MINUTE FROM &quot;1999-07-02 01:02:03&quot;);
       -&gt; 20102
</pre>
    <p>如果你指定太短的間隔值(不包括<code>type</code>關鍵詞期望的間隔部分)，<strong>MySQL</strong>假設你省掉了間隔值的最左面部分。例如，如果你指定一個<code>type</code>是<code>DAY_SECOND</code>，值<code>expr</code>被希望有天、小時、分鐘和秒部分。如果你像<code>&quot;1:10&quot;</code>這樣指定值，<strong>MySQL</strong>假設日子和小時部分是丟失的並且值代表分鐘和秒。換句話說，<code>&quot;1:10&quot; 
    DAY_SECOND</code>以它等價於<code>&quot;1:10&quot; MINUTE_SECOND</code>的方式解釋，這對那<strong>MySQL</strong>解釋<code>TIME</code>值表示經過的時間而非作為一天的時間的方式有二義性。如果你使用確實不正確的日期，結果是<code>NULL</code>。如果你增加<code>MONTH</code>、<code>YEAR_MONTH</code>或<code>YEAR</code>並且結果日期大於新月份的最大值天數，日子在新月用最大的天調整。 
    </p>
    <pre>mysql&gt; select DATE_ADD('1998-01-30', Interval 1 month);
        -&gt; 1998-02-28
</pre>
    <pre>注意，從前面的例子中詞<code>INTERVAL</code>和<code>type</code>關鍵詞不是區分大小寫的。 <a NAME="IDX443"></a> </pre>
  </dd>
  <dt><code>TO_DAYS(date)</code> </dt>
  <dd>給出一個日期<code>date</code>，返回一個天數(從0年的天數)。 <pre>mysql&gt; select TO_DAYS(950501);
        -&gt; 728779
mysql&gt; select TO_DAYS('1997-10-07');
        -&gt; 729669
</pre>
    <p><code>TO_DAYS()</code>不打算用於使用格列高裡歷(1582)出現前的值。 <a NAME="IDX444"></a> </p>
  </dd>
  <dt><code>FROM_DAYS(N)</code> </dt>
  <dd>給出一個天數<code>N</code>，返回一個<code>DATE</code>值。 <pre>mysql&gt; select FROM_DAYS(729669);
        -&gt; '1997-10-07'
</pre>
    <p><code>TO_DAYS()</code>不打算用於使用格列高裡歷(1582)出現前的值。 <a NAME="IDX445"></a> </p>
  </dd>
  <dt><code>DATE_FORMAT(date,format)</code> </dt>
  <dd>根據<code>format</code>字符串格式化<code>date</code>值。下列修飾符可以被用在<code>format</code>字符串中： 
    <table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
      <tr>
        <td><code>%M</code> </td>
        <td>月名字(<code>January</code>……<code>December</code>) </td>
      </tr>
      <tr>
        <td><code>%W</code> </td>
        <td>星期名字(<code>Sunday</code>……<code>Saturday</code>) </td>
      </tr>
      <tr>
        <td><code>%D</code> </td>
        <td>有英語前綴的月份的日期(<code>1st</code>, <code>2nd</code>, <code>3rd</code>, 
        等等。）</td>
      </tr>
      <tr>
        <td><code>%Y</code> </td>
        <td>年, 數字, 4 位</td>
      </tr>
      <tr>
        <td><code>%y</code> </td>
        <td>年, 數字, 2 位</td>
      </tr>
      <tr>
        <td><code>%a</code> </td>
        <td>縮寫的星期名字(<code>Sun</code>……<code>Sat</code>) </td>
      </tr>
      <tr>
        <td><code>%d</code> </td>
        <td>月份中的天數, 數字(<code>00</code>……<code>31</code>) </td>
      </tr>
      <tr>
        <td><code>%e</code> </td>
        <td>月份中的天數, 數字(<code>0</code>……<code>31</code>) </td>
      </tr>
      <tr>
        <td><code>%m</code> </td>
        <td>月, 數字(<code>01</code>……<code>12</code>) </td>
      </tr>
      <tr>
        <td><code>%c</code> </td>
        <td>月, 數字(<code>1</code>……<code>12</code>) </td>
      </tr>
      <tr>
        <td><code>%b</code> </td>
        <td>縮寫的月份名字(<code>Jan</code>……<code>Dec</code>) </td>
      </tr>
      <tr>
        <td><code>%j</code> </td>
        <td>一年中的天數(<code>001</code>……<code>366</code>) </td>
      </tr>
      <tr>
        <td><code>%H</code> </td>
        <td>小時(<code>00</code>……<code>23</code>) </td>
      </tr>
      <tr>
        <td><code>%k</code> </td>
        <td>小時(<code>0</code>……<code>23</code>) </td>
      </tr>
      <tr>
        <td><code>%h</code> </td>
        <td>小時(<code>01</code>……<code>12</code>) </td>
      </tr>
      <tr>
        <td><code>%I</code> </td>
        <td>小時(<code>01</code>……<code>12</code>) </td>
      </tr>
      <tr>
        <td><code>%l</code> </td>
        <td>小時(<code>1</code>……<code>12</code>) </td>
      </tr>
      <tr>
        <td><code>%i</code> </td>
        <td>分鐘, 數字(<code>00</code>……<code>59</code>) </td>
      </tr>
      <tr>
        <td><code>%r</code> </td>
        <td>時間,12 小時(<code>hh:mm:ss [AP]M</code>) </td>
      </tr>
      <tr>
        <td><code>%T</code> </td>
        <td>時間,24 小時(<code>hh:mm:ss</code>) </td>
      </tr>
      <tr>
        <td><code>%S</code> </td>
        <td>秒(<code>00</code>……<code>59</code>) </td>
      </tr>
      <tr>
        <td><code>%s</code> </td>
        <td>秒(<code>00</code>……<code>59</code>) </td>
      </tr>
      <tr>
        <td><code>%p</code> </td>
        <td><code>AM</code>或<code>PM</code> </td>
      </tr>
      <tr>
        <td><code>%w</code> </td>
        <td>一個星期中的天數(<code>0</code>=Sunday ……<code>6</code>=Saturday ）</td>
      </tr>
      <tr>
        <td><code>%U</code> </td>
        <td>星期(<code>0</code>……<code>52</code>), 這裡星期天是星期的第一天</td>
      </tr>
      <tr>
        <td><code>%u</code> </td>
        <td>星期(<code>0</code>……<code>52</code>), 這裡星期一是星期的第一天</td>
      </tr>
      <tr>
        <td><code>%%</code> </td>
        <td>一個文字<samp>“%”</samp>。 </td>
      </tr>
    </table>
    <p>所有的其他字符不做解釋被複製到結果中。 </p>
    <pre>mysql&gt; select DATE_FORMAT('1997-10-04 22:23:00', '%W %M %Y');
        -&gt; 'Saturday October 1997'
mysql&gt; select DATE_FORMAT('1997-10-04 22:23:00', '%H:%i:%s');
        -&gt; '22:23:00'
mysql&gt; select DATE_FORMAT('1997-10-04 22:23:00',
                          '%D %y %a %d %m %b %j');
        -&gt; '4th 97 Sat 04 10 Oct 277'
mysql&gt; select DATE_FORMAT('1997-10-04 22:23:00',
                          '%H %k %I %r %T %S %w');
        -&gt; '22 22 10 10:23:00 PM 22:23:00 00 6'</pre>
    <p><strong>MySQL</strong>3.23中，在格式修飾符字符前需要<code>%</code>。在<strong>MySQL</strong>更早的版本中，<code>%</code>是可選的。 
    <a NAME="IDX446"></a> </p>
  </dd>
  <dt><code>TIME_FORMAT(time,format)</code> </dt>
  <dd>這像上面的<code>DATE_FORMAT()</code>函數一樣使用，但是<code>format</code>字符串只能包含處理小時、分鐘和秒的那些格式修飾符。其他修飾符產生一個<code>NULL</code>值或<code>0</code>。 
    <a NAME="IDX447"></a> <a NAME="IDX448"></a> </dd>
  <dt><code>CURDATE()</code> </dt>
  <dd>　</dd>
  <dt><code>CURRENT_DATE</code> </dt>
  <dd>以<code>'YYYY-MM-DD'</code>或<code>YYYYMMDD</code>格式返回今天日期值，取決於函數是在一個字符串還是數字上下文被使用。 
    <pre>mysql&gt; select CURDATE();
        -&gt; '1997-12-15'
mysql&gt; select CURDATE() + 0;
        -&gt; 19971215
</pre>
  </dd>
  <dt><code>CURTIME()</code> </dt>
  <dd>　</dd>
  <dt><code>CURRENT_TIME</code> </dt>
  <dd>以<code>'HH:MM:SS'</code>或<code>HHMMSS</code>格式返回當前時間值，取決於函數是在一個字符串還是在數字的上下文被使用。 
    <pre>mysql&gt; select CURTIME();
        -&gt; '23:50:26'
mysql&gt; select CURTIME() + 0;
        -&gt; 235026
</pre>
  </dd>
  <dt><code>NOW()</code> </dt>
  <dd>　</dd>
  <dt><code>SYSDATE()</code> </dt>
  <dd>　</dd>
  <dt><code>CURRENT_TIMESTAMP</code> </dt>
  <dd>以<code>'YYYY-MM-DD HH:MM:SS'</code>或<code>YYYYMMDDHHMMSS</code>格式返回當前的日期和時間，取決於函數是在一個字符串還是在數字的上下文被使用。 
    <pre>mysql&gt; select NOW();
        -&gt; '1997-12-15 23:50:26'
mysql&gt; select NOW() + 0;
        -&gt; 19971215235026
</pre>
  </dd>
  <dt><code>UNIX_TIMESTAMP()</code> </dt>
  <dd>　</dd>
  <dt><code>UNIX_TIMESTAMP(date)</code> </dt>
  <dd>如果沒有參數調用，返回一個Unix時間戳記(從<code>'1970-01-01 00:00:00'</code>GMT開始的秒數)。如果<code>UNIX_TIMESTAMP()</code>用一個<code>date</code>參數被調用，它返回從<code>'1970-01-01 
    00:00:00'</code> GMT開始的秒數值。<code>date</code>可以是一個<code>DATE</code>字符串、一個<code>DATETIME</code>字符串、一個<code>TIMESTAMP</code>或以<code>YYMMDD</code>或<code>YYYYMMDD</code>格式的本地時間的一個數字。 
    <pre>mysql&gt; select UNIX_TIMESTAMP();
        -&gt; 882226357
mysql&gt; select UNIX_TIMESTAMP('1997-10-04 22:23:00');
        -&gt; 875996580
</pre>
    <p>當<code>UNIX_TIMESTAMP</code>被用於一個<code>TIMESTAMP</code>列，函數將直接接受值，沒有隱含的“string-to-unix-timestamp”變換。 
    <a NAME="IDX455"></a> </p>
  </dd>
  <dt><code>FROM_UNIXTIME(unix_timestamp)</code> </dt>
  <dd>以<code>'YYYY-MM-DD HH:MM:SS'</code>或<code>YYYYMMDDHHMMSS</code>格式返回<code>unix_timestamp</code>參數所表示的值，取決於函數是在一個字符串還是或數字上下文中被使用。 
    <pre>mysql&gt; select FROM_UNIXTIME(875996580);
        -&gt; '1997-10-04 22:23:00'
mysql&gt; select FROM_UNIXTIME(875996580) + 0;
        -&gt; 19971004222300
</pre>
  </dd>
  <dt><code>FROM_UNIXTIME(unix_timestamp,format)</code> </dt>
  <dd>返回表示 Unix 時間標記的一個字符串，根據<code>format</code>字符串格式化。<code>format</code>可以包含與<code>DATE_FORMAT()</code>函數列出的條目同樣的修飾符。 
    <pre>mysql&gt; select FROM_UNIXTIME(UNIX_TIMESTAMP(),
                            '%Y %D %M %h:%i:%s %x');
        -&gt; '1997 23rd December 03:43:30 x'
</pre>
  </dd>
  <dt><code>SEC_TO_TIME(seconds)</code> </dt>
  <dd>返回<code>seconds</code>參數，變換成小時、分鐘和秒，值以<code>'HH:MM:SS'</code>或<code>HHMMSS</code>格式化，取決於函數是在一個字符串還是在數字上下文中被使用。 
    <pre>mysql&gt; select SEC_TO_TIME(2378);
        -&gt; '00:39:38'
mysql&gt; select SEC_TO_TIME(2378) + 0;
        -&gt; 3938
</pre>
  </dd>
  <dt><code>TIME_TO_SEC(time)</code> </dt>
  <dd>返回<code>time</code>參數，轉換成秒。 <pre>mysql&gt; select TIME_TO_SEC('22:23:00');
        -&gt; 80580
mysql&gt; select TIME_TO_SEC('00:39:38');
        -&gt; 2378
</pre>
  </dd>
</dl>

<h3><a NAME="Miscellaneous_functions" HREF="manual_toc.html#Miscellaneous_functions">7.4.12 
其他函數</a></h3>

<dl COMPACT="Miscellaneous_functions">
  <dt><code>DATABASE()</code> </dt>
  <dd><a NAME="IDX461"></a>返回當前的資料庫名字。 <pre>mysql&gt; select DATABASE();
        -&gt; 'test'
</pre>
    <p>如果沒有當前的資料庫，<code>DATABASE()</code>返回空字符串。 <a NAME="IDX462"></a> <a NAME="IDX463"></a> <a NAME="IDX464"></a> </p>
  </dd>
  <dt><code>USER()</code> </dt>
  <dd>　</dd>
  <dt><code>SYSTEM_USER()</code> </dt>
  <dd>　</dd>
  <dt><code>SESSION_USER()</code> </dt>
  <dd>返回當前<strong>MySQL</strong>用戶名。 <pre>mysql&gt; select USER();
        -&gt; <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="a780c3c6d1cec3c6e7cbc8c4c6cbcfc8d4d3">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>'
</pre>
    <p>在MySQL 3.22.11或以後版本中，這包括用戶名和客戶主機名。你可以像這樣只提取用戶名部分(值是否包括主機名部分均可工作)： 
    </p>
    <pre>mysql&gt; select substring_index(USER(),&quot;@&quot;,1);
        -&gt; 'davida'
</pre>
  </dd>
  <dt><code>PASSWORD(str)</code> </dt>
  <dd>從純文本密碼<code>str</code>計算一個密碼字符串。該函數被用於為了在<code>user</code>授權表的<code>Password</code>列中儲存密碼而加密<strong>MySQL</strong>密碼。 
    <pre>mysql&gt; select PASSWORD('badpwd');
        -&gt; '7f84554057dd964b'
</pre>
    <p><code>PASSWORD()</code>加密是非可逆的。<code>PASSWORD()</code>不以與Unix密碼加密的相同的方法執行密碼加密。你不應該假定如果你的Unix 
    密碼和你的<strong>MySQL</strong>密碼是一樣的，<code>PASSWORD()</code>將導致與在Unix密碼文件儲存的相同的加密值。見<code>ENCRYPT()</code>。 
    <a NAME="IDX467"></a> </p>
  </dd>
  <dt><code>ENCRYPT(str[,salt])</code> </dt>
  <dd>使用Unix<code> crypt()</code>系統調用加密<code>str</code>。<code>salt</code>參數應該是一個有2個字符的字符串。（MySQL 
    3.22.16中，<code>salt</code>可以長於2個字符。）<pre>mysql&gt; select ENCRYPT(&quot;hello&quot;);
        -&gt; 'VxuFAJXVARROc'
</pre>
    <p>如果<code>crypt()</code>在你的系統上不可用，<code>ENCRYPT()</code>總是返回<code>NULL</code>。<code>ENCRYPT()</code>只保留<code>str</code>起始8個字符而忽略所有其他，至少在某些系統上是這樣。這將由底層的<code>crypt()</code>系統調用的行為決定。 
    <a NAME="IDX468"></a> </p>
  </dd>
  <dt><code>ENCODE(str,pass_str)</code> </dt>
  <dd>使用<code>pass_str</code>作為密碼加密<code>str</code>。為了解密結果，使用<code>DECODE()</code>。結果是一個二進制字符串，如果你想要在列中保存它，使用一個<code>BLOB</code>列類型。 
    <a NAME="IDX469"></a> </dd>
  <dt><code>DECODE(crypt_str,pass_str)</code> </dt>
  <dd>使用<code>pass_str</code>作為密碼解密加密的字符串<code>crypt_str</code>。<code>crypt_str</code>應該是一個由<code>ENCODE()</code>返回的字符串。 
    <a NAME="IDX470"></a> </dd>
  <dt><code>MD5(string)</code> </dt>
  <dd>對字符串計算MD5校驗和。值作為一個32長的十六進制數字被返回可以，例如用作哈希(hash)鍵。 
    <pre>mysql&gt; select MD5(&quot;testing&quot;)
        -&gt; 'ae2b1fca515949e5d54fb22b8ed95575'
</pre>
    <p>這是一個“RSA數據安全公司的MD5消息摘要算法”。 <a NAME="IDX471"></a> 
    </p>
  </dd>
  <dt><code>LAST_INSERT_ID([expr])</code> </dt>
  <dd>返回被插入一個<code>AUTO_INCREMENT</code>列的最後一個自動產生的值。見<a HREF="manual_Clients.html#mysql_insert_id">20.4.29<code> mysql_insert_id()</code></a>。 <pre>mysql&gt; select LAST_INSERT_ID();
        -&gt; 195
</pre>
    <p>產生的最後ID以每個連接為基礎在伺服器被維護，它不會被其他客戶改變。如果你更新另外一個有非魔術值(即，不是<code>NULL</code>和不是<code>0</code>的一個值)的<code>AUTO_INCREMENT</code>列，它甚至不會被改變。<a NAME="IDX472"></a>如果<code>expr</code>作為一個參數在一個<code>UPDATE</code>子句的<code>LAST_INSERT_ID()</code>裡面給出，那麼參數值作為一個<code>LAST_INSERT_ID()</code>值被返回。這可以用來模仿順序：首先創建表： 
    </p>
    <pre>mysql&gt; create table sequence (id int not null);
mysql&gt; insert into sequence values (0);
</pre>
    <p>然後表能被用來產生順序號，像這樣： </p>
    <pre>mysql&gt; update sequence set id=LAST_INSERT_ID(id+1);
</pre>
    <p>你可以不調用<code>LAST_INSERT_ID()</code>而產生順序，但是這樣使用函數的實用程式在伺服器上自動維護ID值作為最後自動產生的值。你可以檢索新的ID值，就像你能讀入正常<strong>MySQL</strong>中的任何正常的<code>AUTO_INCREMENT</code>值一樣。例如，<code>LAST_INSERT_ID()</code>（沒有一個參數 
    )將返回新ID。C API函數<code>mysql_insert_id()</code>也可被用來得到值。 <a NAME="IDX473"></a> </p>
  </dd>
  <dt><code>FORMAT(X,D)</code> </dt>
  <dd>格式化數字<code>X</code>為類似於格式<code>'#,###,###.##'</code>，四捨五入到<code>D</code>為小數。如果<code>D</code>為<code>0</code>，結果將沒有小數點和小數部分。 
    <pre>mysql&gt; select FORMAT(12332.123456, 4);
        -&gt; '12,332.1235'
mysql&gt; select FORMAT(12332.1,4);
        -&gt; '12,332.1000'
mysql&gt; select FORMAT(12332.2,0);
        -&gt; '12,332'
</pre>
  </dd>
  <dt><code>VERSION()</code> </dt>
  <dd>返回表明<strong>MySQL</strong>伺服器版本的一個字符串。 <pre>mysql&gt; select VERSION();
        -&gt; '3.22.19b-log'
</pre>
  </dd>
  <dt><code>GET_LOCK(str,timeout)</code> </dt>
  <dd>試圖獲得由字符串<code>str</code>給定的一個名字的鎖定，第二個<code>timeout</code>為超時。如果鎖定成功獲得，返回<code>1</code>，如果嘗試超時了，返回<code>0</code>，或如果發生一個錯誤，返回<code>NULL</code>(例如從記憶體溢位或執行緒用<code>mysqladmin 
    kill</code>被殺死)。當你執行<code>RELEASE_LOCK()</code>時、執行一個新的<code>GET_LOCK()</code>或執行緒終止時，一個鎖定被釋放。該函數可以用來實現應用鎖或模擬記錄鎖，它阻止其他客戶用同樣名字的鎖定請求﹔贊成一個給定的鎖定字符串名字的客戶可以使用字符串執行子協作建議的鎖定。 
    <pre>mysql&gt; select GET_LOCK(&quot;lock1&quot;,10);
        -&gt; 1
mysql&gt; select GET_LOCK(&quot;lock2&quot;,10);
        -&gt; 1
mysql&gt; select RELEASE_LOCK(&quot;lock2&quot;);
        -&gt; 1
mysql&gt; select RELEASE_LOCK(&quot;lock1&quot;);
        -&gt; NULL
</pre>
    <p>注意，第二個<code>RELEASE_LOCK()</code>調用返回<code>NULL</code>，因為鎖<code>&quot;lock1&quot;</code>自動地被第二個<code>GET_LOCK()</code>調用釋放。 
    <a NAME="IDX476"></a> </p>
  </dd>
  <dt><code>RELEASE_LOCK(str)</code> </dt>
  <dd>釋放字符串<code>str</code>命名的通過<code>GET_LOCK()</code>獲得的鎖。如果鎖被釋放，返回<code>1</code>，如果鎖沒被這個執行緒鎖定(在此情況下鎖沒被釋放)返回<code>0</code>，並且如果命名的鎖不存在，返回<code>NULL</code>。如果鎖從來沒有通過調用<code>GET_LOCK()</code>獲得或如果它已經被釋放了，鎖將不存在。 
    <a NAME="IDX477"></a> </dd>
  <dt><code>BENCHMARK(count,expr)</code> </dt>
  <dd><code>BENCHMARK()</code>函數重複<code>count</code>Times次執行表達式<code>expr</code>，它可以用於計時<strong>MySQL</strong>處理表達式有多快。結果值總是<code>0</code>。意欲用於<code>mysql</code>客戶，它報告查詢的執行時間。 
    <pre>mysql&gt; select BENCHMARK(1000000,encode(&quot;hello&quot;,&quot;goodbye&quot;));
+----------------------------------------------+
| BENCHMARK(1000000,encode(&quot;hello&quot;,&quot;goodbye&quot;)) |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+
1 row in set (4.74 sec)
</pre>
    <p>報告的時間是客戶端的經過時間，不是在伺服器端的CPU時間。執行<code>BENCHMARK()</code>若干次可能是明智的，並且注意伺服器機器的負載有多重來解釋結果。 
    </p>
  </dd>
</dl>

<p><a NAME="IDX478"></a> <a NAME="IDX479"></a> </p>

<h3><a NAME="Group_by_functions" href="manual_toc.html#Group_by_functions">7.4.13 與<code>GROUP 
BY</code>子句一起使用的函數</a></h3>

<p>如果你在不包含<code>GROUP BY</code>子句的一個語句中使用聚合函數，它等價於聚合所有行。 

<dl COMPACT="Group_by_functions">
  <dt><code>COUNT(expr)</code> </dt>
  <dd><a NAME="IDX480"></a>返回由一個<code>SELECT</code>語句檢索出來的行的非<code>NULL</code>值的數目。 
    <pre>mysql&gt; select student.student_name,COUNT(*)
           from student,course
           where student.student_id=course.student_id
           GROUP BY student_name;
</pre>
    <p><code>COUNT(*)</code>在它返回的檢索出來的行數目上有些不同，不管他們是否包含<code>NULL</code>值。如果<code>SELECT</code>從一個表檢索，或沒有檢索出其他列並且沒有<code>WHERE</code>子句，<code>COUNT(*)</code>被最佳化以便快速地返回。例如： 
    </p>
    <pre>mysql&gt; select COUNT(*) from student;
<a NAME="IDX481"></a> <a NAME="IDX482"></a> </pre>
  </dd>
  <dt><code>COUNT(DISTINCT expr,[expr...])</code> </dt>
  <dd>返回一個不同值的數目。 <pre>mysql&gt; select COUNT(DISTINCT results) from student;
</pre>
    <p>在<strong>MySQL</strong>中，你可以通過給出一個表達式列表以得到不同的表達式組合的數目。在 
    ANSI SQL中，你可能必須在<code>CODE(DISTINCT ..)</code>內進行所有表達式的連接。 
    <a NAME="IDX483"></a> </p>
  </dd>
  <dt><code>AVG(expr)</code> </dt>
  <dd>返回<code>expr</code>的平均值。 <pre>mysql&gt; select student_name, AVG(test_score)
           from student
           GROUP BY student_name;
<a NAME="IDX484"></a> <a NAME="IDX485"></a> </pre>
  </dd>
  <dt><code>MIN(expr)</code> </dt>
  <dd>　</dd>
  <dt><code>MAX(expr)</code> </dt>
  <dd>返回<code>expr</code>的最小或最大值。<code>MIN()</code>和<code>MAX()</code>可以有一個字符串參數﹔在這種的情況下，他們返回最小或最大的字符串值。 
    <pre>mysql&gt; select student_name, MIN(test_score), MAX(test_score)
           from student
           GROUP BY student_name;
<a NAME="IDX486"></a> </pre>
  </dd>
  <dt><code>SUM(expr)</code> </dt>
  <dd>返回<code>expr</code>的和。注意，如果返回的集合沒有行，它返回NULL！ 
    <a NAME="IDX487"></a> <a NAME="IDX488"></a> <a NAME="IDX489"></a> <a NAME="IDX490"></a> </dd>
  <dt><code>STD(expr)</code> </dt>
  <dd>　</dd>
  <dt><code>STDDEV(expr)</code> </dt>
  <dd>返回<code>expr</code>標準差(deviation)。這是對 ANSI SQL 
    的擴展。該函數的形式<code>STDDEV()</code>是提供與Oracle的兼容性。 <a NAME="IDX491"></a> </dd>
  <dt><code>BIT_OR(expr)</code> </dt>
  <dd>返回<code>expr</code>裡所有位的位或。計算用 64 位(<code>BIGINT</code>)精度進行。 
    <a NAME="IDX492"></a> </dd>
  <dt><code>BIT_AND(expr)</code> </dt>
  <dd>返回<code>expr</code>裡所有位的位與。計算用 64 位(<code>BIGINT</code>)精度進行。 
  </dd>
</dl>

<p><strong>MySQL</strong>擴展了<code>GROUP BY</code>的用法。你可以不出現在的<code>GROUP 
BY</code>部分的<code>SELECT</code>表達式中使用列或計算，這表示<em>這個組的任何可能值</em>。你可以使用它是性能更好，避免在不必要的項目上排序和分組。例如，你在下列查詢中不需要在<code>customer.name</code>上聚合： 
</p>

<pre>mysql&gt; select order.custid,customer.name,max(payments)
       from order,customer
       where order.custid = customer.custid
       GROUP BY order.custid;
</pre>

<p>在 ANSI SQL中，你將必須將<code>customer.name</code>加到<code>GROUP BY</code>子句。在<strong>MySQL</strong>中，名字是冗餘的。 
</p>

<p>如果你從<code>GROUP BY</code>部分省略的列在組中不是唯一的，不要使用這個功能。</p>

<p>在某些情況下，你可以使用<code>MIN()</code>和<code>MAX()</code>獲得一個特定的列值，即使它不是唯一的。下例給出從包含<code>sort</code>列中最小值的行的<code>column</code>值： 
</p>

<pre>substr(MIN(concat(sort,space(6-length(sort)),column),7,length(column)))
</pre>

<p><a NAME="IDX493"></a>注意，<a NAME="IDX498"></a>如果你正在使用<strong>MySQL</strong> 
3.22(或更早)或如果你正在試圖遵從ANSI SQL，你不能在<code>GROUP BY</code>或<code>ORDER 
BY</code>子句中使用表達式。你可以通過使用表達式的一個別名解決此限制： 
</p>

<pre>mysql&gt; SELECT id,FLOOR(value/100) AS val FROM tbl_name
           GROUP BY id,val ORDER BY val;
</pre>

<p>在<code>MySQL</code>3.23中，你可以這樣做： </p>

<pre>mysql&gt; SELECT id,FLOOR(value/100) FROM tbl_name ORDER BY RAND();
</pre>

<h2><a NAME="CREATE_DATABASE" HREF="manual_toc.html#CREATE_DATABASE">7.5<code> CREATE 
DATABASE</code>句法</a></h2>

<pre>CREATE DATABASE db_name
</pre>

<p><code>CREATE DATABASE</code>用給定的名字創建一個資料庫。允許的資料庫名字規則在<a HREF="manual_Reference.html#Legal_names">7.1.5 
資料庫、桌子、索引、列和別名命名</a>中給出。如果資料庫已經存在，發生一個錯誤。 
</p>

<p>在<strong>MySQL</strong>中的資料庫實現成包含對應資料庫中表的文件的目錄。因為資料庫在初始創建時沒有任何表，<code>CREATE 
DATABASE</code>語句只是在<strong>MySQL</strong>數據目錄下面創建一個目錄。 
</p>

<p><a NAME="IDX500"></a>你也可以用<code>mysqladmin</code>創建資料庫。見<a HREF="manual_Tools.html#Programs">12.1 不同的MySQL程式的概述</a>。 </p>

<p><a NAME="IDX501"></a> </p>

<h2><a NAME="DROP_DATABASE" HREF="manual_toc.html#DROP_DATABASE">7.6<code> DROP DATABASE</code>句法</a></h2>

<pre>DROP DATABASE [IF EXISTS] db_name
</pre>

<p><code>DROP DATABASE</code>刪除資料庫中的所有表和資料庫。<strong>要小心地使用這個命令！</strong> 
</p>

<p><code>DROP DATABASE</code>返回從資料庫目錄被刪除的文件的數目。通常，這3倍於表的數量，因為每張表對應於一個<tt>“.MYD”</tt>文件、一<tt>個“.MYI”</tt>文件和一個<tt>“.frm”</tt>文件。 
</p>

<p>在<strong>MySQL</strong> 3.22或以後版本中，你可以使用關鍵詞<code>IF 
EXISTS</code>阻止一個錯誤的發生，如果資料庫不存在。 </p>

<p><a NAME="IDX502"></a>你也可以用<code>mysqladmin</code>丟棄資料庫。見<a HREF="manual_Tools.html#Programs">12.1 不同的 MySQL 程式的概述</a>。 </p>

<p><a NAME="IDX503"></a> </p>

<h2><a NAME="CREATE_TABLE" HREF="manual_toc.html#CREATE_TABLE">7.7<code> CREATE TABLE</code>句法</a></h2>

<pre>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,...)]
[table_options] [select_statement]

create_definition:
  col_name type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT]
            [PRIMARY KEY] [reference_definition]
  or    PRIMARY KEY (index_col_name,...)
  or    KEY [index_name] (index_col_name,...)
  or    INDEX [index_name] (index_col_name,...)
  or    UNIQUE [INDEX] [index_name] (index_col_name,...)
  or    [CONSTRAINT symbol] FOREIGN KEY index_name (index_col_name,...)
            [reference_definition]
  or    CHECK (expr)

type:
        TINYINT[(length)] [UNSIGNED] [ZEROFILL]
  or    SMALLINT[(length)] [UNSIGNED] [ZEROFILL]
  or    MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]
  or    INT[(length)] [UNSIGNED] [ZEROFILL]
  or    INTEGER[(length)] [UNSIGNED] [ZEROFILL]
  or    BIGINT[(length)] [UNSIGNED] [ZEROFILL]
  or    REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    DECIMAL(length,decimals) [UNSIGNED] [ZEROFILL]
  or    NUMERIC(length,decimals) [UNSIGNED] [ZEROFILL]
  or    CHAR(length) [BINARY]
  or    VARCHAR(length) [BINARY]
  or    DATE
  or    TIME
  or    TIMESTAMP
  or    DATETIME
  or    TINYBLOB
  or    BLOB
  or    MEDIUMBLOB
  or    LONGBLOB
  or    TINYTEXT
  or    TEXT
  or    MEDIUMTEXT
  or    LONGTEXT
  or    ENUM(value1,value2,value3,...)
  or    SET(value1,value2,value3,...)

index_col_name:
        col_name [(length)]

reference_definition:
        REFERENCES tbl_name [(index_col_name,...)]
                   [MATCH FULL | MATCH PARTIAL]
                   [ON DELETE reference_option]
                   [ON UPDATE reference_option]

reference_option:
        RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

table_options:
	TYPE = {ISAM | MYISAM | HEAP}
or	AUTO_INCREMENT = #
or	AVG_ROW_LENGTH = #
or	CHECKSUM = {0 | 1}
or	COMMENT = &quot;string&quot;
or	MAX_ROWS = #
or	MIN_ROWS = #
or	PACK_KEYS = {0 | 1}
or	PASSWORD = &quot;string&quot;
or	DELAY_KEY_WRITE = {0 | 1}
or      ROW_FORMAT= { default | dynamic | static | compressed }

select_statement:
	[IGNORE | REPLACE] SELECT ...  (Some legal select statement)
</pre>

<p><code>CREATE TABLE</code>在當前資料庫刈谻給出的名字創建一個資料庫表。允許的表名的規則在<a HREF="manual_Reference.html#Legal_names">7.1.5 
資料庫，桌子，索引，列和別名命名</a>中給出。如果當前資料庫不存在或如果表已經存在，出現一個錯誤。 
</p>

<p>在<strong>MySQL</strong>3.22或以後版本中，表名可以被指定為<code>db_name.tbl_name</code>，不管有沒有當前的資料庫都可以。 
</p>

<p>在<strong>MySQL</strong>3.23中，當你創建一張表時，你可以使用<code>TEMPORARY</code>關鍵詞。如果一個連接死掉，臨時表將自動被刪除，並且其名字是按連接命名。這意味著，2個不同的連接能使用相同的暫時表的名字而不會彼此衝突或與相同名字的現有資料庫表衝突。（現有的表被隱蔽直到臨時表被刪除）。 
</p>

<p>在<strong>MySQL</strong>3.23或以後版本中，你可以使用關鍵詞<code>IF NOT 
EXISTS</code>以便如果表已經存在不發生一個錯誤。注意，無法証實表結構是相同的。 
</p>

<p>每張表<code>tbl_name</code>由在資料庫目錄的一些文件表示。在MyISAM類型的表的情況下，你將得到： 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>文件</strong> </td>
    <td><strong>目的</strong> </td>
  </tr>
  <tr>
    <td><code>tbl_name.frm</code> </td>
    <td>表定義(表格)文件</td>
  </tr>
  <tr>
    <td><code>tbl_name.MYD</code> </td>
    <td>數據文件</td>
  </tr>
  <tr>
    <td><code>tbl_name.MYI</code> </td>
    <td>索引文件</td>
  </tr>
</table>

<p>對於各種列類型的性質的更多資訊，見<a HREF="manual_Reference.html#Column_types">7.3 列類型</a>。 

<ul>
  <li>如果既不指定<code>NULL</code>也不指定<code>NOT NULL</code>，列被視為指定了<code>NULL</code>。 
  </li>
  <li>整型列可以有附加的屬性<code>AUTO_INCREMENT</code>。當你插入<code>NULL</code>值（推薦)或<code>0</code>到一個<code>AUTO_INCREMENT</code>列中時，列被設置為<code>value+1</code>，在此<code>value</code>是當前表中的列的最大值。<code>AUTO_INCREMENT</code>順序從<code>1</code>開始。見<a HREF="manual_Clients.html#mysql_insert_id">20.4.29<code> mysql_insert_id()</code></a>。如果你刪除了包含一個<code>AUTO_INCREMENT</code>列的最大值的行，值將被重新使用。如果你刪除表中所有的行，順序重新開始。<strong>注意：</strong>每個表只能有一個<code>AUTO_INCREMENT</code>列，並且它必須被索引。為了使做<strong>MySQL</strong>兼容一些 
    ODBC 應用程式，用下列查詢你可以找出最後插入的行： <pre>SELECT * FROM tbl_name WHERE auto_col IS NULL
</pre>
  </li>
  <li><code>NULL</code>值對於<code>TIMESTAMP</code>列的處理不同於其他列類型。你不能在一個<code>TIMESTAMP</code>列中儲存一個文字<code>NULL</code>﹔設置列為<code>NULL</code>將把它設成當前的日期和時間。因為<code>TIMESTAMP</code>列表現就這樣，<code>NULL</code>和<code>NOT 
    NULL</code>屬性不以一般方式運用並且如果你指定它們，將被忽略。在另一方面，為了使它<strong>MySQL</strong>客戶更容易地使用<code>TIMESTAMP</code>列，伺服器報告這樣的列可以被賦值<code>NULL</code>( 
    它是對的)，盡管<code>TIMESTAMP</code>實際上絕不包含一個<code>NULL</code>值。當你使用<code>DESCRIBE 
    tbl_name</code>得到有關你的表的描述時，你就會明白。注意，設置一個<code>TIMESTAMP</code>列為<code>0</code>不同於將它設置為<code>NULL</code>，因為<code>0</code>是一個有效的<code>TIMESTAMP</code>值。 
  </li>
  <li>如果沒有為列指定<code>DEFAULT</code>值，<strong>MySQL</strong>自動地分配一個。如果列可以取<code>NULL</code>作為值，預設值是<code>NULL</code>。如果列被聲明為<code>NOT 
    NULL</code>，預設值取決於列類型： <ul>
      <li>對於沒有聲明<code>AUTO_INCREMENT</code>屬性的數字類型，預設值是<code>0</code>。對於一個<code>AUTO_INCREMENT</code>列，預設值是在順序中的下一個值。 
      </li>
      <li>對於除<code>TIMESTAMP</code>的日期和時間類型，預設值是該類型適當的“零”值。對於表中第一個<code>TIMESTAMP</code>列，預設值是當前的日期和時間。見<a HREF="manual_Reference.html#Date_and_time_types">7.3.6 日期和時間類型</a>。 </li>
      <li>對於除<code>ENUM</code>的字符串類型，預設是空字符串。對於<code>ENUM</code>，預設值是第一個枚舉值。 
      </li>
    </ul>
  </li>
  <li><code>KEY</code>是<code>INDEX</code>的一個同義詞。 </li>
  <li>在<strong>MySQL</strong>中，一個<code>UNIQUE</code>鍵只能有不同的值。如果你試圖用匹配現有行的鍵來增加新行，發生一個錯誤。 
  </li>
  <li>A <code>PRIMARY KEY</code>是一個唯一<code>KEY</code>，它有額外的限制，即所有的關鍵列必須被定義為<code>NOT 
    NULL</code>。在<strong>MySQL</strong>中，鍵被命名為<code>PRIMARY</code>。一張表只能有一個<code>PRIMARY 
    KEY</code>。如果在表中你沒有一個<code>PRIMARY KEY</code>並且一些應用程式要求<code>PRIMARY 
    KEY</code>，<strong>MySQL</strong>將返回第一個<code>UNIQUE</code>鍵，它沒有任何<code>NULL</code>列，作為<code>PRIMARY 
    KEY</code>。 </li>
  <li>一個<code>PRIMARY KEY</code>可以是一個多列索引。然而，你不能在一個列說明中使用<code>PRIMARY 
    KEY</code>的關鍵字屬性創建一個多列索引。這樣做將僅僅標記單個列作為主鍵。你必須使用<code>PRIMARY 
    KEY(index_col_name, ...)</code>語法。 </li>
  <li>如果你不能給索引賦予一個名字，這個索引將賦予與第一個<code>index_col_name</code>相同的名字，用一個可選的suffix(<code>_2</code>, 
    <code>_3</code>, <code>...</code>)使它唯一。你能使用<code>SHOW INDEX FROM 
    tbl_name</code>看到一張表的索引名字。見<a HREF="manual_Reference.html#SHOW">7.21<code> 
    SHOW</code>句法(得到表、列等的資訊）</a>。 </li>
  <li><a NAME="IDX506"></a>只有<code>MyISAM</code>表類型支援可以有<code>NULL</code>值的列上的索引。在其他情況下，你必須聲明這樣的列為<code>NOT 
    NULL</code>，否則導致一個錯。 </li>
  <li>用<code>col_name(length)</code>語法，你可以指定僅使用部分的<code>CHAR</code>或<code>VARCHAR</code>列的一個索引。這能使索引文件變得更小。見<a HREF="manual_Reference.html#Indexes">7.3.9 列索引</a>。 </li>
  <li><a NAME="IDX508"></a>只有<code>MyISAM</code>表類型支援<code>BLOB</code>和<code>TEXT</code>列的索引。當在一個<code>BLOB</code>或<code>TEXT</code>列上放置索引時，你必須總是指定索引的長度： 
    <pre>CREATE TABLE test (blob_col BLOB, index(blob_col(10)));
</pre>
  </li>
  <li>當你與<code>TEXT</code>或<code>BLOB</code>列一起使用<code>ORDER BY</code>或<code>GROUP 
    BY</code>時，只使用頭<code>max_sort_length</code>個字節。見<a HREF="manual_Reference.html#BLOB">7.3.7.2 <code>BLOB</code>和<code>TEXT</code>類型</a>。 
  </li>
  <li><code>FOREIGN KEY</code>、<code>CHECK</code>和<code>REFERENCES</code>子句實際上不做任何事情，其語法僅僅提供兼容性，使得它更容易從其他的SQL伺服器移植代碼並運行借助引用創建表的應用。見<a HREF="manual_Compatibility.html#Missing_functions">5.4 MySQL缺少的功能</a>。 </li>
  <li>每個<code>NULL</code>列占據額外一位，取舍到最接近的字節。 </li>
  <li>最大記錄長度以字節計可以如下計算： <pre>row length = 1
             + (sum of column lengths)
             + (number of NULL columns + 7)/8
             + (number of variable-length columns)
</pre>
  </li>
  <li><code>table_options</code>和<code>SELECT</code>選項只在<strong>MySQL</strong> 3.23和以後版本中被實現。不同的表類型是： 
    <table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
      <tr>
        <td>ISAM</td>
        <td>原來的表處理器</td>
      </tr>
      <tr>
        <td>MyISAM</td>
        <td>全新二進制可移植的表處理器</td>
      </tr>
      <tr>
        <td>HEAP</td>
        <td>用於該表的數據僅僅儲存在內存中</td>
      </tr>
    </table>
    <p>見<a HREF="manual_Server.html#Table_types">9.4 MySQL 表類型</a>。其他表選項被用來最佳化表的行為。在大多數情況下，你不必指定他們任何一個。選項對所有表都適用，如果不是則說明。 
    </p>
    <table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
      <tr>
        <td><code>AUTO_INCREMENT</code> </td>
        <td>你想要為你的表設定的下一個 auto_increment 值 ( MyISAM ）</td>
      </tr>
      <tr>
        <td><code>AVG_ROW_LENGTH</code> </td>
        <td>你的表的平均行長度的近似值。你只需要為有變長記錄的表設置它。 
        </td>
      </tr>
      <tr>
        <td><code>CHECKSUM</code> </td>
        <td>如果你想要<strong>MySQL</strong>對每行維持一個校驗和(使表變得更慢以更新但是使它更容易找出損壞的表)設置它為1 
        ( MyISAM )</td>
      </tr>
      <tr>
        <td><code>COMMENT</code> </td>
        <td>對於你的表的一篇60個字符的注釋</td>
      </tr>
      <tr>
        <td><code>MAX_ROWS</code> </td>
        <td>你計劃在表中儲存的行的最大數目</td>
      </tr>
      <tr>
        <td><code>MIN_ROWS</code> </td>
        <td>你計劃在表中儲存的行的最小數目</td>
      </tr>
      <tr>
        <td><code>PACK_KEYS</code> </td>
        <td>如果你想要有更小的索引，將它設為1。這通常使的更新更慢並且讀取更快(MyISAM，ISAM)。 
        </td>
      </tr>
      <tr>
        <td><code>PASSWORD</code> </td>
        <td>用一個密碼加密<code>.frm</code>文件。該選項在標準<strong>MySQL</strong>版本中不做任何事情。 
        </td>
      </tr>
      <tr>
        <td><code>DELAY_KEY_WRITE</code> </td>
        <td>如果想要推遲關鍵表的更新直到表被關閉(MyISAM)，將它設置為1。 </td>
      </tr>
      <tr>
        <td><code>ROW_FORMAT</code> </td>
        <td>定義行應該如何被儲存(為了將來)。 </td>
      </tr>
    </table>
    <p>當你使用一個<code>MyISAM</code>表時，<strong>MySQL</strong>使用<code>max_rows 
    * avg_row_length</code>的乘積決定最終的表將有多大。如果你不指定上面的任何選項，對一個表的最大尺寸將是4G(或2G，如果你的作業系統僅支援2G的表)。 
    </p>
  </li>
  <li>如果你在<code>CREATE</code>語句後指定一個<code>SELECT</code>，<strong>MySQL</strong>將為在<code>SELECT</code>中所有的單元創鍵新字段。例如： 
    <pre>mysql&gt; CREATE TABLE test (a int not null auto_increment,
           primary key (a), key(b))
           TYPE=HEAP SELECT b,c from test2;
</pre>
    <p>這將創建一個有3個列的<code>HEAP</code>表。注意如果在拷貝數據進表時發生任何錯誤，表將自動被刪除。 
    </p>
  </li>
</ul>

<h3><a NAME="Silent_column_changes" HREF="manual_toc.html#Silent_column_changes">7.7.1 
隱含的列說明改變</a></h3>

<p>在某些情況下，<strong>MySQL</strong>隱含地改變在一個<code>CREATE TABLE</code>語句給出的一個列說明。（這也可能在<code>ALTER 
TABLE</code>。） 

<ul>
  <li>長度小於4的<code>VARCHAR</code>被改變為<code>CHAR</code>。 </li>
  <li>如果在一個表中的任何列有可變長度，結果是整個行是變長的。因此, 
    如果一張表包含任何變長的列(<code>VARCHAR</code>、<code>TEXT</code>或<code>BLOB</code>)，所有大於3個字符的<code>CHAR</code>列被改變為<code>VARCHAR</code>列。這在任何方面都不影響你如何使用列﹔在<strong>MySQL</strong>中，<code>VARCHAR</code>只是儲存字符的一個不同方法。<strong>MySQL</strong>實施這種改變，是因為它節省空間並且使表操作更快捷。見<a HREF="manual_Performance.html#Choosing_table_type">10.6 選擇一種表格類型</a>。 </li>
  <li><code>TIMESTAMP</code>的顯示尺寸必須是偶數且在2 ∼ 14的範圍內。如果你指定0顯示尺寸或比14大，尺寸被強制為14。從1∼13範圍內的奇數值尺寸被強制為下一個更大的偶數。 
  </li>
  <li>你不能在一個<code>TIMESTAMP</code>列裡面儲存一個文字<code>NULL</code>﹔將它設為<code>NULL</code>將設置為當前的日期和時間。因為<code>TIMESTAMP</code>列表現就是這樣，<code>NULL</code>和<code>NOT 
    NULL</code>屬性不以一般的方式運用並且如果你指定他們，將被忽略。<code>DESCRIBE 
    tbl_name</code>總是報告該<code>TIMESTAMP</code>列可能賦予了<code>NULL</code>值。 
  </li>
  <li><strong>MySQL</strong>將其他SQL資料庫供應商使用的某個列類型映射到<strong>MySQL</strong>類型。見<a HREF="manual_Reference.html#Other-vendor_column_types">7.3.11 
    只用其他資料庫引擎的類型</a>。 </li>
</ul>

<p>如果你想要知道<strong>MySQL</strong>是否使用了除你指定的以外的一種列類型，在創建或改變你的表之後，發出一個<code>DESCRIBE 
tbl_name</code>語句即可。 </p>

<p><a NAME="IDX512"></a>如果你使用<code>myisampack</code>壓縮一個表，可能會發生改變某些其他的列類型。見<a HREF="manual_Performance.html#Compressed_format">10.6.3 壓縮表的特徵</a>。&nbsp; </p>

<h2><a NAME="ALTER_TABLE" HREF="manual_toc.html#ALTER_TABLE">7.8<code> ALTER TABLE</code>句法</a></h2>

<pre>ALTER [IGNORE] TABLE tbl_name alter_spec [, alter_spec ...]

alter_specification:
        ADD [COLUMN] create_definition [FIRST | AFTER column_name ]
  or    ADD INDEX [index_name] (index_col_name,...)
  or    ADD PRIMARY KEY (index_col_name,...)
  or    ADD UNIQUE [index_name] (index_col_name,...)
  or    ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
  or    CHANGE [COLUMN] old_col_name create_definition
  or    MODIFY [COLUMN] create_definition
  or    DROP [COLUMN] col_name
  or    DROP PRIMARY KEY
  or    DROP INDEX index_name
  or    RENAME [AS] new_tbl_name
  or    table_options
</pre>

<p><code>ALTER TABLE</code>允許你修改一個現有表的結構。例如，你可以增加或刪除列、創造或消去索引、改變現有列的類型、或重新命名列或表本身。你也能改變表的注釋和表的類型。見<a HREF="manual_Reference.html#CREATE_TABLE">7.7<code> CREATE TABLE</code>句法</a>。 </p>

<p>如果你使用<code>ALTER TABLE</code>修改一個列說明但是<code>DESCRIBE 
tbl_name</code>顯示你的列並沒有被修改，這可能是<strong>MySQL</strong>因為在<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱含的列說明改變</a>中描述的原因之一而忽略了你的修改。例如，如果你試圖將一個<code>VARCHAR</code>改為<code>CHAR</code>，<strong>MySQL</strong>將仍然使用<code>VARCHAR</code>，如果表包含其他變長的列。 
</p>

<p><code>ALTER TABLE</code>通過制作原來表的一個臨時副本來工作。修改在副本上施行，然後原來的表被刪除並且重新命名一個新的。這樣做使得所有的修改自動地轉向到新表，沒有任何失敗的修改。當<code>ALTER 
TABLE</code>正在執行時，原來的桌可被其他客戶讀取。更新和寫入表被延遲到新表準備好了為止。 

<ul>
  <li>為了使用<code>ALTER TABLE</code>，你需要在表上的<strong>select</strong>、<strong>insert</strong>、<strong>delete</strong>、<strong>update</strong>、<strong>create</strong>和<strong>drop</strong>的權限。 
  </li>
  <li><code>IGNORE</code>是<strong>MySQL</strong>對ANSI SQL92 
    的一個擴充，如果在新表中的唯一鍵上有重複，它控制<code>ALTER TABLE</code>如何工作。如果<code>IGNORE</code>沒被指定，副本被放棄並且恢復原狀。如果<code>IGNORE</code>被指定，那麼對唯一鍵有重複的行，只有使用第一行﹔其餘被刪除。 
  </li>
  <li>你可以在單個<code>ALTER TABLE</code>語句中發出多個<code>ADD</code>、<code>ALTER</code>、<code>DROP</code>和<code>CHANGE</code>子句。這是<strong>MySQL</strong>對ANSI 
    SQL92的一個擴充，SQL92在每個<code>ALTER TABLE</code>語句刈荿允許一個子句。 
  </li>
  <li><code>CHANGE col_name</code>、<code>DROP col_name</code>和<code>DROP INDEX</code>是<strong>MySQL</strong>對 
    ANSI SQL92 的擴充。 </li>
  <li><code>MODIFY</code>是 Oracle 對<code>ALTER TABLE</code>的擴充。 </li>
  <li>可選的詞<code>COLUMN</code>是一個純粹的噪音且可以省略。 </li>
  <li>如果你使用<code>ALTER TABLE tbl_name RENAME AS new_name</code>而沒有任何其他選項，<strong>MySQL</strong>簡單地重命名對應於表<code>tbl_name</code>的文件。沒有必要創建臨時表。 
  </li>
  <li><code>create_definition</code>子句使用<code>CREATE TABLE</code>相同的<code>ADD</code>和<code>CHANGE</code>語法。注意語法包括列名字，不只列類型。見<a HREF="manual_Reference.html#CREATE_TABLE">7.7<code> CREATE TABLE</code>句法</a>。 </li>
  <li>你可以使用<code>CHANGE old_col_name create_definition</code>子句重命名一個列。為了這樣做，指定舊的和新的列名字和列當前有的類型。例如，重命名一個<code>INTEGER</code>列，從<code>a</code>到<code>b</code>，你可以這樣做： 
    <pre>mysql&gt; ALTER TABLE t1 CHANGE a b INTEGER;
</pre>
    <p>如果你想要改變列的類型而非名字，就算他們是一樣的，<code>CHANGE</code>語法仍然需要2個列名。例如： 
    </p>
    <pre>mysql&gt; ALTER TABLE t1 CHANGE b b BIGINT NOT NULL;
</pre>
    <p>然而，在<strong>MySQL</strong>3.22.16a，你也可以使用<code>MODIFY</code>來改變列的類型而不是重命名它： 
    </p>
    <pre>mysql&gt; ALTER TABLE t1 MODIFY b BIGINT NOT NULL;
</pre>
  </li>
  <li>如果你使用<code>CHANGE</code>或<code>MODIFY</code>縮短一個列，一個索引存在於該列的部分(例如，如果你有一個<code>VARCHAR</code>列的頭10個字符的索引)，你不能使列短於被索引的字符數目。 
  </li>
  <li>當你使用<code>CHANGE</code>或<code>MODIFY</code>改變一個列類型時，<strong>MySQL</strong>盡可能試圖很好地變換數據到新類型。 
  </li>
  <li>在<strong>MySQL</strong>3.22或以後，你能使用<code>FIRST</code>或<code>ADD ... 
    AFTER col_name</code>在一個表的行內在一個特定的位置增加列。預設是增加到最後一列。 
  </li>
  <li><code>ALTER COLUMN</code>為列指定新的預設值或刪除老的預設值。如果老的預設值被刪除且列可以是<code>NULL</code>，新預設值是<code>NULL</code>。如果列不能是<code>NULL</code>，<strong>MySQL</strong>賦予一個預設值。預設值賦值在<a HREF="manual_Reference.html#CREATE_TABLE">7.7<code> CREATE TABLE</code>句法</a>中描述。 
  </li>
  <li><code>DROP INDEX</code>刪除一個索引。這是<strong>MySQL</strong>對 ANSI SQL92 
    的一個擴充。 </li>
  <li>如果列從一張表中被丟棄，列也從他們是組成部分的任何索引中被刪除。如果組成一個索引的所有列被丟棄，該索引也被丟棄。 
  </li>
  <li><code>DROP PRIMARY KEY</code>丟棄主索引。如果這樣的索引不存在，它丟棄表中第一個<code>UNIQUE</code>索引。(如果沒有明確地指定<code>PRIMARY 
    KEY</code>，<strong>MySQL</strong>標記第一個<code>UNIQUE</code>鍵為<code>PRIMARY 
    KEY</code>。）</li>
  <li><a NAME="IDX514"></a>用 C API 函數<code>mysql_info()</code>，你能找出多少記錄被拷貝， 
    和(當使用<code>IGNORE</code>時)由於唯一鍵值的重複多少記錄被刪除。 </li>
  <li><a NAME="IDX515"></a><code>FOREIGN KEY</code>、<code>CHECK</code>和<code>REFERENCES</code>子句實際上不做任何事情，他們的句法僅僅提供兼容性，使得更容易地從其他SQL伺服器移植代碼並且運行借助引用來創建表的應用程式。見<a HREF="manual_Compatibility.html#Missing_functions">5.4 MySQL缺少的功能</a>。 </li>
</ul>

<p>這裡是一個例子，顯示了一些<code>ALTER TABLE</code>用法。我們以一個如下創建的表<code>t1</code>開始： 
</p>

<pre>mysql&gt; CREATE TABLE t1 (a INTEGER,b CHAR(10));
</pre>

<p>重命名表，從<code>t1</code>到<code>t2</code>: </p>

<pre>mysql&gt; ALTER TABLE t1 RENAME t2;
</pre>

<p>為了改變列<code>a</code>，從<code>INTEGER</code>改為<code>TINYINT NOT NULL</code>(名字一樣)，並且改變列<code>b</code>，從<code>CHAR(10)</code>改為<code>CHAR(20)</code>，同時重命名它，從<code>b</code>改為<code>c</code>： 
</p>

<pre>mysql&gt; ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);
</pre>

<p>增加一個新<code>TIMESTAMP</code>列，名為<code>d</code>： </p>

<pre>mysql&gt; ALTER TABLE t2 ADD d TIMESTAMP; 
</pre>

<p>在列<code>d</code>上增加一個索引，並且使列<code>a</code>為主鍵： </p>

<pre>mysql&gt; ALTER TABLE t2 ADD INDEX (d), ADD PRIMARY KEY (a);
</pre>

<p>刪出列<code>c</code>： </p>

<pre>mysql&gt; ALTER TABLE t2 DROP COLUMN c;
</pre>

<p>增加一個新的<code>AUTO_INCREMENT</code>整數列，命名為<code>c</code>： </p>

<pre>mysql&gt; ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,
           ADD INDEX (c);
</pre>

<p>注意，我們索引了<code>c</code>，因為<code>AUTO_INCREMENT</code>柱必須被索引，並且另外我們聲明<code>c</code>為<code>NOT 
NULL</code>，因為索引了的列不能是<code>NULL</code>。 </p>

<p>當你增加一個<code>AUTO_INCREMENT</code>列時，自動地用順序數字填入列值。 
</p>

<h2><a NAME="OPTIMIZE_TABLE" HREF="manual_toc.html#OPTIMIZE_TABLE">7.9<code> OPTIMIZE 
TABLE</code>句法</a></h2>

<pre>OPTIMIZE TABLE tbl_name
</pre>

<p>如果你刪除了一個表的大部分或如果你用變長的行對一個表(有<code>VARCHAR</code>、<code>BLOB</code>或<code>TEXT</code>列的表)做了改變，應該使用<code>OPTIMZE 
TABLE</code>。刪除的記錄以一個鏈接表維持並且隨後的<code>INSERT</code>操作再次使用老記錄的位置。你可以使用<code>OPTIMIZE 
TABLE</code>回收閑置的空間。 </p>

<p><code>OPTIMIZE TABLE</code>通過制作原來的表的一個臨時副本來工作。老的表子被拷貝到新表中(沒有閑置的行)，然後原來的表被刪除並且重命名一個新的。這樣做使得所有更新自動轉向新的表，沒有任何失敗的更新。當時<code>OPTIMIZE 
TABLE</code>正在執行時，原來的表可被另外的客戶讀取。對表的更新和寫入延遲到新表是準備好為止。 
</p>

<h2><a NAME="DROP_TABLE" HREF="manual_toc.html#DROP_TABLE">7.10<code> DROP TABLE</code>句法</a></h2>

<pre>DROP TABLE [IF EXISTS] tbl_name [, tbl_name,...]
</pre>

<p><code>DROP TABLE</code>刪除一個或多個資料庫表。所有表中的數據和表定義均被<em>刪除</em>，故<strong>小心</strong>使用這個命令！ 
</p>

<p>在<strong>MySQL</strong> 3.22或以後版本，你可以使用關鍵詞<code>IF EXISTS</code>類避免不存在表的一個錯誤發生。 
</p>

<p><a NAME="IDX519"></a> </p>

<h2><a NAME="DELETE" HREF="manual_toc.html#DELETE">7.11<code> DELETE</code>句法</a></h2>

<pre>DELETE [LOW_PRIORITY] FROM tbl_name
    [WHERE where_definition] [LIMIT rows]
</pre>

<p><code>DELETE</code>從<code>tbl_name</code>表中刪除滿足由<code>where_definition</code>給出的條件的行，並且返回刪除記錄的個數。 
</p>

<p>如果你發出一個沒有<code>WHERE</code>子句的<code>DELETE</code>，所有行都被刪除。<strong>MySQL</strong>通過創建一個空表來完成，它比刪除每行要快。在這種情況下，<code>DELETE</code>返回零作為受影響記錄的數目。(<strong>MySQL</strong>不能返回實際上被刪除的行數，因為進行再創建而不是打開數據文件。只要表定義文件<tt>“tbl_name.frm”</tt>是有效的，表才能這樣被再創建，即使數據或索引文件破壞了)。 
</p>

<p>如果你確實想要知道在你正在刪除所有行時究竟有對少記錄被刪除，並且願意承受速度上的懲罰，你可以這種形式的一個<code>ELETE</code>語句： 
</p>

<pre>mysql&gt; DELETE FROM tbl_name WHERE 1&gt;0;
</pre>

<p>注意這比沒有<code>WHERE</code>子句的<code>DELETE FROM tbl_name</code>慢的多了，因為它一次刪除一行。 
</p>

<p>如果你指定關鍵詞<code>LOW_PRIORITY</code>，<code>DELETE</code>的執行被推遲到沒有其他客戶讀取表後。 
</p>

<p>刪除的記錄以一個鏈接表維持並且隨後的<code>INSERT</code>操作再次使用老的記錄位置。為了回收閑置的空間並減小文件大小，使用<code>OPTIMIZE 
TABLE</code>語句或<code>myisamchk</code>實用程式重新組織表。<code>OPTIMIZE 
TABLE</code>較容易，但是<code>myisamchk</code>更快。見<a HREF="manual_Reference.html#OPTIMIZE_TABLE">7.9<code> OPTIMIZE TABLE</code>句法</a>和<a HREF="manual_Maintenance.html#Optimization">13.4.3 表最佳化</a>。 </p>

<p><strong>MySQL</strong>對<code>DELETE</code>特定的<code>LIMIT rows</code>選項告訴伺服器在控制被返回到客戶之前，將要刪除的最大行數，這可以用來保証一個特定<code>DELETE</code>命令不會花太多的時間。你可以簡單地重複<code>DELETE</code>命令直到受影響的行數小於<code>LIMIT</code>值。 
</p>

<h2><a NAME="SELECT" HREF="manual_toc.html#SELECT">7.12<code> SELECT</code>句法</a></h2>

<pre>SELECT [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [HIGH_PRIORITY]
       [DISTINCT | DISTINCTROW | ALL]
    select_expression,...
    [INTO {OUTFILE | DUMPFILE} 'file_name' export_options]
    [FROM table_references
        [WHERE where_definition]
        [GROUP BY col_name,...]
        [HAVING where_definition]
        [ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC] ,...]
        [LIMIT [offset,] rows]
        [PROCEDURE procedure_name] ]
</pre>

<p><code>SELECT</code>被用來檢索從一個或多個表中選取的行。<code>select_expression</code>指出你想要檢索的列。<code>SELECT</code>也可以用來檢索不引用任何表的計算行。例如： 
</p>

<pre>mysql&gt; SELECT 1 + 1;
         -&gt; 2
</pre>

<p>所有使用的關鍵詞必須精確地以上面的順序給出。例如，一個<code>HAVING</code>子句必須跟在<code>GROUP 
BY</code>子句之後和<code>ORDER BY</code>子句之前。 

<ul>
  <li><a NAME="IDX521"></a>一個<code>SELECT</code>表達式可以用一個<code>AS</code>給定一個別名，別名被用作表達式的列名並且能使用在<code>ORDER 
    BY</code>或<code>HAVING</code>子句中。例如： <pre>mysql&gt; select concat(last_name,', ',first_name) AS full_name
    from mytable ORDER BY full_name;
</pre>
  </li>
  <li><code>FROM table_references</code>子句指出從哪個表中檢索行。如果你命名多個表，你正在執行一個聯結(join)。對於聯結的句法資訊，見<a HREF="manual_Reference.html#JOIN">7.13<code> JOIN</code>句法</a>。 </li>
  <li>你可以引用一個列為<code>col_name</code>、<code>tbl_name.col_name</code>或<code>db_name.tbl_name.col_name</code>，你不必在一個<code>SELECT</code>語句中指定一個<code>tbl_name</code>或<code>db_name.tbl_name</code>是一個列引用的前綴，除非引用有二義性。見<a HREF="manual_Reference.html#Legal_names">7.1.5 
    資料庫、表、索引、列和別名命名</a>。對於二義性的例子要求更加顯式的列引用格式。 
  </li>
  <li><a NAME="IDX523"></a><a NAME="IDX524"></a>一個表引用可以使用<code>tbl_name [AS] 
    alias_name</code>起一個別名。 <pre>mysql&gt; select t1.name, t2.salary from employee AS t1, info AS t2
           where t1.name = t2.name;
mysql&gt; select t1.name, t2.salary from employee t1, info t2
           where t1.name = t2.name;
</pre>
  </li>
  <li>選取輸出的列可以用列名、列別名或列位置在<code>ORDER BY</code>和<code>GROUP 
    BY</code>子句引用，列位置從1開始。 <pre>mysql&gt; select college, region, seed from tournament
           ORDER BY region, seed;
mysql&gt; select college, region AS r, seed AS s from tournament
           ORDER BY r, s;
mysql&gt; select college, region, seed from tournament
           ORDER BY 2, 3;
</pre>
    <p>為了以降序排列，把<code>DESC</code>（下降 )關鍵詞加到<code>ORDER BY</code>子句中你要排序的列名前。預設是升序﹔這也可以用<code>ASC</code>關鍵詞明確指定。 
    </p>
  </li>
  <li><code>HAVING</code>子句能引用任何列或在<code>select_expression</code>中命名的別名，它最後運用，就在項目被送到客戶之前，沒有最佳化。不要對因該在<code>WHERE</code>子句中的項目使用<code>HAVING</code>。例如，不能寫成這樣： 
    <pre>mysql&gt; select col_name from tbl_name HAVING col_name &gt; 0;
</pre>
    <p>相反寫成這樣： </p>
    <pre>mysql&gt; select col_name from tbl_name WHERE col_name &gt; 0;
</pre>
    <p>在<strong>MySQL</strong> 3.22.5或以後，你也能這樣寫查詢： </p>
    <pre>mysql&gt; select user,max(salary) from users group by user HAVING max(salary)&gt;10; 
</pre>
    <p>在裡面更老的<strong>MySQL</strong>版本中，你能這樣寫： </p>
    <pre>mysql&gt; select user,max(salary) AS sum from users
           group by user HAVING sum&gt;10;
</pre>
  </li>
  <li><code>SQL_SMALL_RESULT</code>、<code>SQL_BIG_RESULT</code>、<code>STRAIGHT_JOIN</code>和<code>HIGH_PRIORITY</code>是<strong>MySQL</strong>對ANSI 
    SQL92的擴展。 </li>
  <li><code>STRAIGHT_JOIN</code>強制最佳化器以其列在<code>FROM</code>子句的次序聯結(join)桌子。如果最佳化器以非最佳次序聯結表，你能使用它加速查詢。見<a HREF="manual_Reference.html#EXPLAIN">7.22<code> EXPLAIN</code>句法(得到關於<code>SELECT</code>的資訊)</a>。 
  </li>
  <li><code>SQL_SMALL_RESULT</code>能與<code>GROUP BY</code>或<code>DISTINCT</code>一起使用告訴最佳化器結果集將很小。在這種情況下，<strong>MySQL</strong>將使用快速臨時表儲存最終的表而不是使用排序。 
    <code>SQL_SMALL_RESULT</code>是一個<strong>MySQL</strong>擴展。 </li>
  <li><code>SQL_BIG_RESULT</code>能與<code>GROUP BY</code>或<code>DISTINCT</code>一起使用以告訴最佳化器結果集合將有很多行。在這種情況下，如果需要，<strong>MySQL</strong>將直接使用基於磁碟的臨時表。 
    <code>MySQL</code>在這種情況下將選擇用<code>GROUP BY</code>單元上的鍵值進行排序而不是做一個臨時表。 
  </li>
  <li><code>HIGH_PRIORITY</code>將賦予<code>SELECT</code>比一個更新表的語句更高的優先級，你應該僅對非常快的並且必須一次完成的查詢使用它。 
    如果表為讀而鎖定或甚至有一個等待表釋放的更新語句，一個<code>SELECT 
    HIGH_PRIORITY</code>將運行。 </li>
  <li><code>LIMIT</code>子句可以被用來限制<code>SELECT</code>語句返回的行數。<code>LIMIT</code>取1個或2個數字參數，如果給定2個參數，第一個指定要返回的第一行的偏移量，第二個指定返回行的最大數目。初始行的偏移量是0(不是1)。 
    <pre>mysql&gt; select * from table LIMIT 5,10;  # Retrieve rows 6-15
</pre>
    <p>如果給定一個參數，它指出返回行的最大數目。 </p>
    <pre>mysql&gt; select * from table LIMIT 5;     # Retrieve first 5 rows
</pre>
    <p>換句話說，<code>LIMIT n</code>等價於<code>LIMIT 0,n</code>。 </p>
  </li>
  <li><code>SELECT ... INTO OUTFILE 'file_name'</code>格式的<code>SELECT</code>語句將選擇的行寫入一個文件。文件在伺服器主機上被創建，並且不能是已經存在的(不管別的，這可阻止資料庫表和文件例如<tt>“/etc/passwd”</tt>被破壞)。在伺服器主機上你必須有<strong>file</strong>權限以使用這種<code>SELECT</code>。<code>SELECT 
    ... INTO OUTFILE</code>是<code>LOAD DATA INFILE</code>逆操作﹔語句的<code>export_options</code>部分的語法與用在<code>LOAD 
    DATA INFILE</code>語句中的<code>FIELDS</code>和<code>LINES</code>子句的相同。見<a HREF="manual_Reference.html#LOAD_DATA">7.16<code> LOAD DATA INFILE</code>句法</a>。在最終的文本文件中，只有下列字符由<code>ESCAPED 
    BY</code>字符轉義： <ul>
      <li><code>ESCAPED BY</code>字符</li>
      <li>在<code>FIELDS TERMINATED BY</code>中的第一個字符</li>
      <li>在<code>LINES TERMINATED BY</code>中的第一個字符</li>
    </ul>
    <p>另外，<code>ASCII 0</code>被變換到<code>ESCAPED BY</code>後跟0(<code>ASCII 48</code>)。上述的原因是你必須轉義任何<code>FIELDS 
    TERMINATED BY</code>、<code>ESCAPED BY</code>或<code>LINES TERMINATED BY</code>字符以便能可靠地能讀回文件。<code>ASCII 
    0</code>被轉義使它更容易用分頁器觀看。因為最終的文件不必須遵循SQL句法，沒有別的東西需要轉義。 
    </p>
  </li>
</ul>

<p><a NAME="IDX526"></a>如果你使用<code>INTO DUMPFILE</code>而不是<code>INTO 
OUTFILE</code>，<strong>MySQL</strong>將只寫一行到文件中，沒有任何列或行結束並且沒有任何轉義。如果你想要在一個文件儲存一個blob，這是很有用的。 
<a NAME="IDX531"></a> <a NAME="IDX532"></a> <a NAME="IDX533"></a> <a NAME="IDX534"></a> </p>

<h2><a NAME="JOIN" HREF="manual_toc.html#JOIN">7.13<code> JOIN</code>句法</a></h2>

<p><strong>MySQL</strong>支援下列用於<code>SELECT</code>語句的<code>JOIN</code>句法： 
</p>

<pre>table_reference, table_reference
table_reference [CROSS] JOIN table_reference
table_reference INNER JOIN table_reference
table_reference STRAIGHT_JOIN table_reference
table_reference LEFT [OUTER] JOIN table_reference ON conditional_expr
table_reference LEFT [OUTER] JOIN table_reference USING (column_list)
table_reference NATURAL LEFT [OUTER] JOIN table_reference
{ oj table_reference LEFT OUTER JOIN table_reference ON conditional_expr }
</pre>

<p><a NAME="IDX535"></a>上述<a NAME="IDX536"></a>最後的<code>LEFT OUTER JOIN</code>的句法只是為了與ODBC兼容而存在的。 

<ul>
  <li>一個表可以是使用aliased<code>tbl_name AS alias_name</code>或<code>tbl_name 
    alias_name</code>的起的別名。 <pre>mysql&gt; select t1.name, t2.salary from employee AS t1, info AS t2
           where t1.name = t2.name;
</pre>
  </li>
  <li><code>INNER JOIN</code>和<code>,</code>（逗號)在語義上是等價的，都是進行一個在使用的表之間的全聯結。通常，你指定表應該如何用<code>WHERE</code>條件聯結起來。 
  </li>
  <li><code>ON</code>條件是可以用在一個<code>WHERE</code>子句形式的任何條件。 
  </li>
  <li>如果在一個<code>LEFT JOIN</code>中沒有右表的匹配記錄，一個所有列設置為<code>NULL</code>的行被用於右表。你可以使用這個事實指出表中在另一個表中沒有對應記錄的記錄： 
    <pre>mysql&gt; select table1.* from table1
           LEFT JOIN table2 ON table1.id=table2.id
           where table2.id is NULL;
</pre>
    <p>這個例子找出在<code>table1</code>中所有的行，其<code>id</code>值在<code>table2</code>中不存在（即，所有<code>table1</code>中的在<code>table2</code>中沒有對應行的行)。當然這假定<code>table2.id</code>被聲明為<code>NOT 
    NULL</code>。</p>
  </li>
  <li><code>USING</code> <code>(column_list)</code>子句命名一系列必須存在於兩個表中的列。 
    例如一個<code>USING</code>子句： <pre>A LEFT JOIN B USING (C1,C2,C3,...)
</pre>
    <p>被定義成在語義上等同一個這樣的<code>ON</code>表達式： </p>
    <pre>A.C1=B.C1 AND A.C2=B.C2 AND A.C3=B.C3,...
</pre>
  </li>
  <li>2個表的<code>NATURAL LEFT JOIN</code>被定義為在語義上等同於一個有<code>USING</code>子句命名在兩表中存在的所有列的一個<code>LEFT 
    JOIN</code>。 </li>
  <li><code>STRAIGHT_JOIN</code>等同於<code>JOIN</code>，除了左表在右表之前被讀入，這能用於這些情況，聯結最佳化器將表的順序放錯了。 
  </li>
</ul>

<p>一些例子： </p>

<pre>mysql&gt; select * from table1,table2 where table1.id=table2.id;
mysql&gt; select * from table1 LEFT JOIN table2 ON table1.id=table2.id;
mysql&gt; select * from table1 LEFT JOIN table2 USING (id);
mysql&gt; select * from table1 LEFT JOIN table2 ON table1.id=table2.id
           LEFT JOIN table3 ON table2.id=table3.id;
</pre>

<p>見<a HREF="manual_Performance.html#LEFT_JOIN_optimization">10.5.4 MySQL怎樣最佳化<code>LEFT 
JOIN</code></a>。 </p>

<h2><a NAME="INSERT" HREF="manual_toc.html#INSERT">7.14<code> INSERT</code>句法</a></h2>

<pre>    INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        VALUES (expression,...),(...),...
或  INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
或  INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name
        SET col_name=expression, col_name=expression, ...
</pre>

<p><code>INSERT</code>把新行插入到一個存在的表中，<code>INSERT ... VALUES</code>形式的語句基於明確指定的值插入行，<code>INSERT 
... SELECT</code>形式插入從其他表選擇的行，有多個值表的<code>INSERT ... 
VALUES</code>的形式在<strong>MySQL</strong> 3.22.5或以後版本中支援，<code>col_name=expression</code>語法在<strong>MySQL</strong> 
3.22.10或以後版本中支援。 </p>

<p><code>tbl_name</code>是行應該被插入其中的表。列名表或<code>SET</code>子句指出語句為那一列指定值。 

<ul>
  <li>如果你為<code>INSERT ... VALUES</code>或<code>INSERT ... SELECT</code>不指定列表，所有列的值必須在<code>VALUES()</code>表或由<code>SELECT</code>提供。如果你不知道表中列的順序，使用<code>DESCRIBE 
    tbl_name</code>來找出。 </li>
  <li>任何沒有明確地給出值的列被設置為它的預設值。例如，如果你指定一個列表並沒命名表中所有列，未命名的列被設置為它們的預設值。預設值賦值在<a HREF="manual_Reference.html#CREATE_TABLE">7.7<code> CREATE TABLE</code>句法</a>中描述。 
  </li>
  <li>一個<code>expression</code>可以引用在一個值表先前設置的任何列。例如，你能這樣： 
    <pre>mysql&gt; INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);
</pre>
    <p>但不能這樣： </p>
    <pre>mysql&gt; INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15);
</pre>
  </li>
  <li>如果你指定關鍵詞<code>LOW_PRIORITY</code>，<code>INSERT</code>的執行被推遲到沒有其他客戶正在讀取表。在這種情況下，客戶必須等到插入語句完成後，如果表頻繁使用，它可能花很長時間。這與<code>INSERT 
    DELAYED</code>讓客馬上繼續正好相反。 </li>
  <li>如果你在一個有許多值行的<code>INSERT</code>中指定關鍵詞<code>IGNORE</code>，表刈酚何複製一個現有<code>PRIMARY</code>或<code>UNIQUE</code>鍵的行被忽略並且不被插入。如果你不指定<code>IGNORE</code>，插入如果有任何複製現有關鍵值的行被放棄。你可用C 
    API函數<code>mysql_info()</code>檢查多少行被插入到表中。 </li>
  <li>如果<strong>MySQL</strong>用<code>DONT_USE_DEFAULT_FIELDS</code>選項配置，<code>INSERT</code>語句產生一個錯誤，除非你明確對需要一個非<code>NULL</code>值的所有列指定值。見<a HREF="manual_Installing.html#configure_options">4.7.3 典型<code>configure</code>選項</a>。 
  </li>
  <li><code>INSERT INTO ... SELECT</code>語句滿足下列條件： <ul>
      <li>查詢不能包含一個<code>ORDER BY</code>子句。 </li>
      <li><code>INSERT</code>語句的目的表不能出現在<code>SELECT</code>查詢部分的<code>FROM</code>子句，因為這在ANSI 
        SQL中被禁止讓從你正在插入的表中<code>SELECT</code>。（問題是<code>SELECT</code>將可能發現在同一個運行期間內先前被插入的記錄。當使用子選擇子句時，情況能很容易混淆）</li>
      <li><code>AUTO_INCREMENT</code>列像往常一樣工作。 </li>
    </ul>
  </li>
</ul>

<p><a NAME="IDX538"></a>如果你使用<code>INSERT ... SELECT</code>或<code>INSERT ... 
VALUES</code>語句有多個值列表，你可以使用C API函數<code>mysql_info()</code>得到查詢的資訊。資訊字符串的格式如下： 
</p>

<pre>Records: 100 Duplicates: 0 Warnings: 0 </pre>

<p><code>Duplicates</code>指出不能被插入的行的數量，因為他們與現有的唯一的索引值重複。<code>Warnings</code>指出在出現某些問題時嘗試插入列值的次數。在下列任何條件下都可能發生錯誤： 

<ul>
  <li>插入<code>NULL</code>到被聲明了<code>NOT NULL</code>的列，列被設置為它的預設值。 
  </li>
  <li>將超出列範圍的值設置給一個數字列，值被剪切為範圍內適當的端點值。 
  </li>
  <li>將數字列設成例如<code>'10.34 a'</code>的值，拖尾的垃圾被剝去並仍然是數字部分被插入。如果值根本不是一個數字，列被設置到<code>0</code>。 
  </li>
  <li>把一個字符串插入到超過列的最大長度的一個<code>CHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>或<code>BLOB</code>列中。值被截斷為列的最大長度。 
  </li>
  <li>把一個對列類型不合法的值插入到一個日期或時間列。列被設置為該列類型適當的“零”值。 
  </li>
</ul>

<p>對於<code>INSERT</code>語句的<code>DELAYED</code>選項是<strong>MySQL</strong>專屬的選項-如果你客戶有不能等到<code>INSERT</code>完成，它是很有用的。當你為日記登錄使用<strong>MySQL</strong>時，而且你也周期性地運行花很長時間完成的<code>SELECT</code>語句，這是一個常見的問題。<code>DELAYED</code>在面<strong>MySQL</strong> 
3.22.15中被引入，它是<strong>MySQL</strong>對 ANSI SQL92 的一個擴展。 </p>

<p>當你使用<code>INSERT DELAYED</code>時，客戶將馬上準備好，並且當表不被任何其他的執行緒使用時，行將被插入。</p>

<p>另一個使用<code>INSERT DELAYED</code>的主要好處是從很多客戶插入被捆綁在一起並且寫進一個塊。這比做很多單獨的插入要來的快。 
</p>

<p>注意，當前排隊的行只是儲存在內存中，直到他們被插入到表中。這意味著，如果你硬要殺死<code>mysqld</code>(<code>kill 
-9</code>)或如果<code>mysqld</code>出人意料地死掉，沒被寫進磁碟的任何排隊的行被丟失！ 
</p>

<p>下列詳細描述當你為<code>INSERT</code>或<code>REPLACE</code>使用<code>DELAYED</code>選項時，發生什麼。在這個描述中，“執行緒”是收到一個<code>INSERT 
DELAYED</code>命令的執行緒並且“處理器”是處理所有對於一個特定表的<code>INSERT 
DELAYED</code>語句。 

<ul>
  <li>當一個執行緒對一個表執行一個<code>DELAYED</code>語句時，如果不存在這樣的處理程式，一個處理器執行緒被創建以處理對於該表的所有<code>DELAYED</code>語句。 
  </li>
  <li>執行緒檢查處理程式是否已經獲得了一個<code>DELAYED</code>鎖﹔如果沒有，它告訴處理程式去獲得。即使其他的執行緒有在表上的一個<code>READ</code>或<code>WRITE</code>鎖，也能獲得<code>DELAYED</code>鎖。然而，處理程式將等待所有<code>ALTER 
    TABLE</code>鎖或<code>FLUSH TABLES</code>以保証表結構是最新的。 </li>
  <li>執行緒執行<code>INSERT</code>語句，但不是將行寫入表，它把最後一行的副本放進被處理器執行緒管理的一個隊列。任何語法錯誤都能被執行緒發覺並報告給客戶程式。 
  </li>
  <li>顧客不能報告結果行的重複次數或<code>AUTO_INCREMENT</code>值﹔它不能從伺服器獲得它們，因為<code>INSERT</code>在插入操作完成前返回。如果你使用C 
    API，<code>同樣原因，mysql_info()</code>函數不返回任何有意義的東西。 </li>
  <li>當行被插入到表中時，更新日誌有處理器執行緒更新。在多行插入的情況下，當第一行被插入時，更新日誌被更新。 
  </li>
  <li>在每寫入<code>delayed_insert_limit</code>行後，處理器檢查是否任何<code>SELECT</code>語句仍然是未完成，如果這樣，在繼續之前允許執行這些語句。 
  </li>
  <li>當處理器在它的隊列中沒有更多行時，表被解鎖。如果在<code>delayed_insert_timeout</code>秒內沒有收到新的<code>INSERT 
    DELAYED</code>命令，處理器終止。 </li>
  <li>如果已經有多於<code>delayed_queue_size</code>行在一個特定的處理器隊列刈袧解決，執行緒等待直到隊列有空間。這有助於保証<code>mysqld</code>伺服器對延遲的內存隊列不使用所有內存。 
  </li>
  <li>處理器執行緒將在<code>Command</code>列的<strong>MySQL</strong>進程表中顯示<code>delayed_insert</code>。如果你執行一個<code>FLUSH 
    TABLES</code>命令或以<code>KILL thread_id</code>殺死它，它將被殺死，然而，它在退出前首先將所有排隊的行存進表中。在這期間，這次它將不從其他執行緒接受任何新的<code>INSERT</code>命令。如果你在它之後執行一個<code>INSERT 
    DELAYED</code>，將創建一個新的處理器執行緒。 </li>
  <li>注意，上述意味著，如果有一個<code>INSERT DELAYED</code>處理器已經運行，<code>INSERT 
    DELAYED</code>命令有比正常<code>INSERT</code>更高的優先級！其他更新命令將必須等到<code>INSERT 
    DELAY</code>排隊變空、殺死處理器執行緒(用<code>KILL thread_id</code>)或執行<code>FLUSH 
    TABLES</code>。 </li>
  <li>下列狀態變數提供了關於<code>INSERT DELAYED</code>命令的資訊： <table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
      <tr>
        <td><code>Delayed_insert_threads</code> </td>
        <td>處理器執行緒數量</td>
      </tr>
      <tr>
        <td><code>Delayed_writes</code> </td>
        <td>用<code>INSERT DELAYED</code>被寫入的行的數量</td>
      </tr>
      <tr>
        <td><code>Not_flushed_delayed_rows</code> </td>
        <td>等待被寫入的行數字</td>
      </tr>
    </table>
    <p>你能通過發出一個<code>SHOW STATUS</code>語句或通過執行一個<code>mysqladmin 
    extended-status</code>命令察看這些變數。 </p>
  </li>
</ul>

<p>注意如果桌子不在使用，<code>INSERT DELAYED</code>比一個正常的<code>INSERT</code>慢。對伺服器也有額外開銷來處理你對它使用<code>INSERT 
DELAYED</code>的每個表的一個單獨執行緒。這意味著，你應該只在你確實肯定需要它的時候才使用<code>INSERT 
DELAYED</code>！ </p>

<p><a NAME="IDX541"></a> </p>

<h2><a NAME="REPLACE" HREF="manual_toc.html#REPLACE">7.15<code> REPLACE</code>句法</a></h2>

<pre>    REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        VALUES (expression,...)
或  REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
或  REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name
        SET col_name=expression, col_name=expression,...
 </pre>

<p><code>REPLACE</code>功能與<code>INSERT</code>完全一樣，除了如果在表中的一個老記錄具有在一個唯一索引上的新記錄有相同的值，在新記錄被插入之前，老記錄被刪除。見<a HREF="manual_Reference.html#INSERT">7.14<code> INSERT</code>句法</a>。 </p>

<p><a NAME="IDX542"></a> </p>

<h2><a NAME="LOAD_DATA" HREF="manual_toc.html#LOAD_DATA">7.16<code> LOAD DATA INFILE</code>句法</a></h2>

<pre>LOAD DATA [LOW_PRIORITY] [LOCAL] INFILE 'file_name.txt' [REPLACE | IGNORE]
    INTO TABLE tbl_name
    [FIELDS
        [TERMINATED BY '\t']
        [OPTIONALLY] ENCLOSED BY '']
        [ESCAPED BY '\\' ]]
    [LINES TERMINATED BY '\n']
    [IGNORE number LINES]
    [(col_name,...)]
</pre>

<p><code>LOAD DATA INFILE</code>語句從一個文本文件刈脛很高的速度讀入一個表中。如果指定<code>LOCAL</code>關鍵詞，從客戶主機讀文件。如果<code>LOCAL</code>沒指定，文件必須位於伺服器上。(<code>LOCAL</code>在<strong>MySQL</strong>3.22.6或以後版本刈莃用。）</p>

<p>為了安全原因，當讀取位於伺服器上的文本文件時，文件必須處於資料庫目錄或可被所有人讀取。另外，為了對伺服器上文件使用<code>LOAD 
DATA INFILE</code>，在伺服器主機上你必須有<strong>file</strong>的權限。見<a HREF="manual_Privilege_system.html#Privileges_provided">6.5 由MySQL提供的權限</a>。 
</p>

<p>如果你指定關鍵詞<code>LOW_PRIORITY</code>，<code>LOAD DATA</code>語句的執行被推遲到沒有其他客戶讀取表後。 
</p>

<p>使用<code>LOCAL</code>將比讓伺服器直接存取文件慢些，因為文件的內容必須從客戶主機傳送到伺服器主機。在另一方面，你不需要<strong>file</strong>權限裝載本地文件。 
</p>

<p><a NAME="IDX543"></a>你也可以使用<code>mysqlimport</code>實用程式裝載數據文件﹔它由發送一個<code>LOAD 
DATA INFILE</code>命令到伺服器來運作。 <code>--local</code>選項使得<code>mysqlimport</code>從客戶主機上讀取數據。如果客戶和伺服器支援壓縮協議，你能指定<code>--compress</code>在較慢的網路上獲得更好的性能。 
</p>

<p>當在伺服器主機上尋找文件時，伺服器使用下列規則： 

<ul>
  <li>如果給出一個絕對路徑名，伺服器使用該路徑名。 </li>
  <li>如果給出一個有一個或多個前置部件的相對路徑名，伺服器相對伺服器的數據目錄搜索文件。 
  </li>
  <li>如果給出一個沒有前置部件的一個文件名，伺服器在當前資料庫的資料庫目錄尋找文件。 
  </li>
</ul>

<p>注意這些規則意味著一個像<tt>“./myfile.txt”</tt>給出的文件是從伺服器的數據目錄讀取，而作為<tt>“myfile.txt”</tt>給出的一個文件是從當前資料庫的資料庫目錄下讀取。也要注意，對於下列哪些語句，對<code>db1</code>文件從資料庫目錄讀取，而不是<code>db2</code>： 
</p>

<pre>mysql&gt; USE db1;
mysql&gt; LOAD DATA INFILE &quot;./data.txt&quot; INTO TABLE db2.my_table; 
</pre>

<p><code>REPLACE</code>和<code>IGNORE</code>關鍵詞控制對現有的唯一鍵記錄的重複的處理。如果你指定<code>REPLACE</code>，新行將代替有相同的唯一鍵值的現有行。如果你指定<code>IGNORE</code>，跳過有唯一鍵的現有行的重複行的輸入。如果你不指定任何一個選項，當找到重複鍵鍵時，出現一個錯誤，並且文本文件的餘下部分被忽略時。 
</p>

<p>如果你使用<code>LOCAL</code>關鍵詞從一個本地文件裝載數據，伺服器沒有辦法在操作的當中停止文件的傳輸，因此預設的行為好像<code>IGNORE</code>被指定一樣。 
</p>

<p><code>LOAD DATA INFILE</code>是<code>SELECT ... INTO OUTFILE</code>的逆操作，見<a HREF="manual_Reference.html#SELECT">7.12<code> SELECT</code>句法</a>。為了將一個資料庫的數據寫入一個文件，使用<code>SELECT 
... INTO OUTFILE</code>，為了將文件讀回資料庫，使用<code>LOAD DATA INFILE</code>。兩個命令的<code>FIELDS</code>和<code>LINES</code>子句的語法是相同的。兩個子句是可選的，但是如果指定兩個，<code>FIELDS</code>必須在<code>LINES</code>之前。 
</p>

<p>如果你指定一個<code>FIELDS</code>子句，它的每一個子句(<code>TERMINATED 
BY</code>, <code>[OPTIONALLY] ENCLOSED BY</code>和<code>ESCAPED BY</code>)也是可選的，除了你必須至少指定他們之一。 
</p>

<p>如果你不指定一個<code>FIELDS</code>子句，預設值與如果你這樣寫的相同： 
</p>

<pre>FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'
</pre>

<p>如果你不指定一個<code>LINES</code>子句，預設值與如果你這樣寫的相同： 
</p>

<pre>LINES TERMINATED BY '\n' </pre>

<p>換句話說，預設值導致讀取輸入時，<code>LOAD DATA INFILE</code>表現如下： 

<ul>
  <li>在換行符處尋找行邊界</li>
  <li>在定位符處將行分進字段</li>
  <li>不要期望字段由任何引號字符封裝</li>
  <li>將由<samp>“\”</samp>開頭的定位符、換行符或<samp>“\”</samp>解釋是字段值的部分字面字符</li>
</ul>

<p>相反，預設值導致在寫入輸出時，<code>SELECT ... INTO OUTFILE</code>表現如下： 

<ul>
  <li>在字段之間寫定位符</li>
  <li>不用任何引號字符封裝字段</li>
  <li>使用<samp>“\”</samp>轉義出現在字段中的定位符、換行符或<samp>“\”</samp>字符</li>
  <li>在行尾處寫換行符</li>
</ul>

<p>注意，為了寫入<code>FIELDS ESCAPED BY '\\'</code>，對作為一條單個的反斜線被讀取的值，你必須指定2條反斜線值。 
</p>

<p><code>IGNORE number LINES</code>選項可被用來忽略在文件開始的一個列名字的頭： 
</p>

<pre>mysql&gt; LOAD DATA INFILE &quot;/tmp/file_name&quot; into table test IGNORE 1 LINES;
</pre>

<p>當你與<code>LOAD DATA INFILE</code>一起使用<code>SELECT ... INTO OUTFILE</code>將一個資料庫的數據寫進一個文件並且隨後馬上將文件讀回資料庫時，兩個命令的字段和處理選項必須匹配，否則，<code>LOAD 
DATA INFILE</code>將不能正確解釋文件的內容。假定你使用<code>SELECT ... 
INTO OUTFILE</code>將由逗號分隔的字段寫入一個文件： </p>

<pre>mysql&gt; SELECT * FROM table1 INTO OUTFILE 'data.txt'
           FIELDS TERMINATED BY ','
           FROM ...
</pre>

<p>為了將由逗號分隔的文件讀回來，正確的語句將是： </p>

<pre>mysql&gt; LOAD DATA INFILE 'data.txt' INTO TABLE table2
           FIELDS TERMINATED BY ',';
</pre>

<p>相反，如果你試圖用下面顯示的語句讀取文件，它不會工作，因為它命令<code>LOAD 
DATA INFILE</code>在字段之間尋找定位符： </p>

<pre>mysql&gt; LOAD DATA INFILE 'data.txt' INTO TABLE table2
           FIELDS TERMINATED BY '\t';
</pre>

<p>可能的結果是每個輸入行將被解釋為單個的字段。</p>

<p><code>LOAD DATA INFILE</code>能被用來讀取從外部來源獲得的文件。例如，以dBASE格式的文件將有由逗號分隔並用雙引號包圍的字段。如果文件中的行由換行符終止，下面顯示的命令說明你將用來裝載文件的字段和行處理選項： 
</p>

<pre>mysql&gt; LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name
           FIELDS TERMINATED BY ',' ENCLOSED BY '&quot;'
           LINES TERMINATED BY '\n';
</pre>

<p>任何字段或行處理選項可以指定一個空字符串(<code>''</code>)。如果不是空，<code>FIELDS 
[OPTIONALLY] ENCLOSED BY</code>和<code>FIELDS ESCAPED BY</code>值必須是一個單個字符。<code>FIELDS 
TERMINATED BY</code>和<code>LINES TERMINATED BY</code>值可以是超過一個字符。例如，寫入由回車換行符對（CR+LF）終止的行，或讀取包含這樣行的一個文件，指定一個<code>LINES 
TERMINATED BY '\r\n'</code>子句。 </p>

<p><code>FIELDS [OPTIONALLY] ENCLOSED BY</code>控制字段的包圍字符。對於輸出(<code>SELECT 
... INTO OUTFILE</code>)，如果你省略<code>OPTIONALLY</code>，所有的字段由<code>ENCLOSED 
BY</code>字符包圍。對於這樣的輸出的一個例子(使用一個逗號作為字段分隔符)顯示在下面： 
</p>

<pre>&quot;1&quot;,&quot;a string&quot;,&quot;100.20&quot;
&quot;2&quot;,&quot;a string containing a , comma&quot;,&quot;102.20&quot;
&quot;3&quot;,&quot;a string containing a \&quot; quote&quot;,&quot;102.20&quot;
&quot;4&quot;,&quot;a string containing a \&quot;, quote and comma&quot;,&quot;102.20&quot;
</pre>

<p>如果你指定<code>OPTIONALLY</code>，<code>ENCLOSED BY</code>字符僅被用於包圍<code>CHAR</code>和<code>VARCHAR</code>字段： 
</p>

<pre>1,&quot;a string&quot;,100.20
2,&quot;a string containing a , comma&quot;,102.20
3,&quot;a string containing a \&quot; quote&quot;,102.20
4,&quot;a string containing a \&quot;, quote and comma&quot;,102.20
</pre>

<p>注意，一個字段值中的<code>ENCLOSED BY</code>字符的出現通過用<code>ESCAPED 
BY</code>字符作為其前綴來轉義。也要注意，如果你指定一個空<code>ESCAPED 
BY</code>值，可能產生不能被<code>LOAD DATA INFILE</code>正確讀出的輸出。例如，如果轉義字符為空，上面顯示的輸出顯示如下。注意到在第四行的第二個字段包含跟隨引號的一個逗號，它(錯誤地)好像要終止字段： 
</p>

<pre>1,&quot;a string&quot;,100.20
2,&quot;a string containing a , comma&quot;,102.20
3,&quot;a string containing a &quot; quote&quot;,102.20
4,&quot;a string containing a &quot;, quote and comma&quot;,102.20
</pre>

<p>對於輸入，<code>ENCLOSED BY</code>字符如果存在，它從字段值的尾部被剝去。（不管是否指定<code>OPTIONALLY</code>都是這樣﹔<code>OPTIONALLY</code>對於輸入解釋不起作用)由<code>ENCLOSED 
BY</code>字符領先的<code>ESCAPED BY</code>字符出現被解釋為當前字段值的一部分。另外，出現在字段中重複的<code>ENCLOSED 
BY</code>被解釋為單個<code>ENCLOSED BY</code>字符，如果字段本身以該字符開始。例如，如果<code>ENCLOSED 
BY '&quot;'</code>被指定，引號如下處理： </p>

<pre>&quot;The &quot;&quot;BIG&quot;&quot; boss&quot;  -&gt; The &quot;BIG&quot; boss
The &quot;BIG&quot; boss      -&gt; The &quot;BIG&quot; boss
The &quot;&quot;BIG&quot;&quot; boss    -&gt; The &quot;&quot;BIG&quot;&quot; boss
</pre>

<p><code>FIELDS ESCAPED BY</code>控制如何寫入或讀出特殊字符。如果<code>FIELDS 
ESCAPED BY</code>字符不是空的，它被用於前綴在輸出上的下列字符： 

<ul>
  <li><code>FIELDS ESCAPED BY</code>字符</li>
  <li><code>FIELDS [OPTIONALLY] ENCLOSED BY</code>字符</li>
  <li><code>FIELDS TERMINATED BY</code>和<code>LINES TERMINATED BY</code>值的第一個字符</li>
  <li>ASCII<code> 0</code>（實際上將後續轉義字符寫成 ASCII<code>'0'</code>，而不是一個零值字節）</li>
</ul>

<p>如果<code>FIELDS ESCAPED BY</code>字符是空的，沒有字符被轉義。指定一個空轉義字符可能不是一個好主意，特別是如果在你數據中的字段值包含剛才給出的表中的任何字符。 
</p>

<p>對於輸入，如果<code>FIELDS ESCAPED BY</code>字符不是空的，該字符的出現被剝去並且後續字符在字面上作為字段值的一個部分。例外是一個轉義的<samp>“0”</samp>或<samp>“N”</samp>（即，<code>\0</code>或<code>\N</code>，如果轉義字符是<samp>“\”</samp>)。這些序列被解釋為ASCII 
<code>0</code>（一個零值字節）和<code>NULL</code>。見下面關於<code>NULL</code>處理的規則。 
</p>

<p>對於更多關於<samp>“\”</samp>- 轉義句法的資訊，見<a HREF="manual_Reference.html#Literals">7.1 文字：怎樣寫字符串和數字</a>。 </p>

<p>在某些情況下，字段和行處理選項相互作用： 

<ul>
  <li>如果<code>LINES TERMINATED BY</code>是一個空字符串並且<code>FIELDS TERMINATED 
    BY</code>是非空的，行也用<code>FIELDS TERMINATED BY</code>終止。 </li>
  <li>如果<code>FIELDS TERMINATED BY</code>和<code>FIELDS ENCLOSED BY</code>值都是空的(<code>''</code>)，一個固定行(非限定的)格式被使用。用固定行格式，在字段之間不使用分隔符。相反，列值只用列的“顯示”寬度被寫入和讀出。例如，如果列被聲明為<code>INT(7)</code>，列的值使用7個字符的字段被寫入。對於輸入，列值通過讀取7個字符獲得。固定行格式也影響<code>NULL</code>值的處理﹔見下面。注意如果你正在使用一個多字節字符集，固定長度格式將不工作。 
  </li>
</ul>

<p><code>NULL</code>值的處理有多種，取決於你使用的<code>FIELDS</code>和<code>LINES</code>選項： 

<ul>
  <li>對於預設<code>FIELDS</code>和<code>LINES</code>值，對輸出，<code>NULL</code>被寫成<code>\N</code>，對輸入，<code>\N</code>被作為<code>NULL</code>讀入(假定<code>ESCAPED 
    BY</code>字符是<samp>“\”</samp>)。 </li>
  <li>如果<code>FIELDS ENCLOSED BY</code>不是空的，包含以文字詞的<code>NULL</code>作為它的值的字段作為一個<code>NULL</code>值被讀入(這不同於包圍在<code>FIELDS 
    ENCLOSED BY</code>字符中的字<code>NULL</code>，它作為字符串<code>'NULL'</code>讀入)。 
  </li>
  <li>如果<code>FIELDS ESCAPED BY</code>是空的，<code>NULL</code>作為字<code>NULL</code>被寫入。 
  </li>
  <li>用固定行格式(它發生在<code>FIELDS TERMINATED BY</code>和<code>FIELDS ENCLOSED 
    BY</code>都是空的時候)，<code>NULL</code>作為一個空字符串被寫入。注意，在寫入文件時，這導致<code>NULL</code>和空字符串在表中不能區分，因為他們都作為空字符串被寫入。如果在讀回文件時需要能區分這兩者，你應該不使用固定行格式。 
  </li>
</ul>

<p>一些不被<code>LOAD DATA INFILE</code>支援的情況： 

<ul>
  <li>固定長度的行(<code>FIELDS TERMINATED BY</code>和<code>FIELDS ENCLOSED BY</code>都為空)和<code>BLOB</code>或<code>TEXT</code>列。 
  </li>
  <li>如果你指定一個分隔符與另一個相同，或是另一個的前綴，<code>LOAD 
    DATA INFILE</code>不能正確地解釋輸入。例如，下列<code>FIELDS</code>子句將導致問題： 
    <pre>FIELDS TERMINATED BY '&quot;' ENCLOSED BY '&quot;'
</pre>
  </li>
  <li>如果<code>FIELDS ESCAPED BY</code>是空的，一個包含跟隨<code>FIELDS 
    TERMINATED BY</code>值之後的<code>FIELDS ENCLOSED BY</code>或<code>LINES TERMINATED 
    BY</code>的字段值將使得<code>LOAD DATA INFILE</code>過早地終止讀取一個字段或行。這是因為<code>LOAD 
    DATA INFILE</code>不能正確地決定字段或行值在哪兒結束。 </li>
</ul>

<p>下列例子裝載所有<code>persondata</code>表的行： </p>

<pre>mysql&gt; LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;
</pre>

<p>沒有指定字段表，所以<code>LOAD DATA INFILE</code>期望輸入行對每個表列包含一個字段。使用預設<code>FIELDS</code>和<code>LINES</code>值。 
</p>

<p>如果你希望僅僅裝載一張表的某些列，指定一個字段表： </p>

<pre>mysql&gt; LOAD DATA INFILE 'persondata.txt'
           INTO TABLE persondata (col1,col2,...);
</pre>

<p>如果在輸入文件中的字段順序不同於表中列的順序，你也必須指定一個字段表。否則，<strong>MySQL</strong>不能知道如何匹配輸入字段和表中的列。 
</p>

<p>如果一個行有很少的字段，對於不存在輸入字段的列被設置為預設值。預設值賦值在<a HREF="manual_Reference.html#CREATE_TABLE">7.7<code> CREATE TABLE</code>句法</a>中描述。 
</p>

<p>如果字段值預設，空字段值有不同的解釋： 

<ul>
  <li>對於字符串類型，列被設置為空字符串。 </li>
  <li>對於數字類型，列被設置為<code>0</code>。 </li>
  <li>對於日期和時間類型，列被設置為該類型的適當“零”值。見<a HREF="manual_Reference.html#Date_and_time_types">7.3.6 日期和時間類型</a>。 </li>
</ul>

<p>如果列有一個<code>NULL</code>，或(只對第一個<code>TIMESTAMP</code>列)在指定一個字段表時，如果<code>TIMESTAMP</code>列從字段表省掉，<code>TIMESTAMP</code>列只被設置為當前的日期和時間。 
</p>

<p>如果輸入行有太多的字段，多餘的字段被忽略並且警告數字加1。 </p>

<p><code>LOAD DATA INFILE</code>認為所有的輸入是字符串，因此你不能像你能用<code>INSERT</code>語句的<code>ENUM</code>或<code>SET</code>列的方式使用數字值。所有的<code>ENUM</code>和<code>SET</code>值必須作為字符串被指定！ 
</p>

<p><a NAME="IDX544"></a>如果你正在使用C API，當<code>LOAD DATA INFILE</code>查詢完成時，你可通過調用API函數<code>mysql_info()</code>得到有關查詢的資訊。資訊字符串的格式顯示在下面： 
</p>

<pre>Records: 1 Deleted: 0 Skipped: 0 Warnings: 0</pre>

<p>當值通過<code>INSERT</code>語句插入時，在某些情況下出現警告(見<a HREF="manual_Reference.html#INSERT">7.14<code> INSERT</code>句法</a>)，除了在輸入行中有太少或太多的字段時，<code>LOAD 
DATA INFILE</code>也產生警告。警告沒被儲存在任何地方﹔警告數字僅能用於表明一切是否順利。如果你得到警告並且想要確切知道你為什麼得到他們，一個方法是使用<code>SELECT 
... INTO OUTFILE</code>到另外一個文件並且把它與你的原版輸入文件比較。 
</p>

<p>對於有關<code>INSERT</code>相對<code>LOAD DATA INFILE</code>的效率和加快<code>LOAD 
DATA INFILE</code>的更多資訊，見<a HREF="manual_Performance.html#Insert_speed">10.5.6 
加速<code>INSERT</code>查詢</a>。 </p>

<p>　</p>

<h2><a NAME="UPDATE" HREF="manual_toc.html#UPDATE">7.17<code> UPDATE</code>句法</a></h2>

<pre>UPDATE [LOW_PRIORITY] tbl_name SET col_name1=expr1,col_name2=expr2,...
    [WHERE where_definition] [LIMIT #]
</pre>

<p><code>UPDATE</code>用新值更新現存表中行的列，<code>SET</code>子句指出哪個列要修改和他們應該被給定的值，<code>WHERE</code>子句，如果給出，指定哪個行應該被更新，否則所有行被更新。 
</p>

<p>如果你指定關鍵詞<code>LOW_PRIORITY</code>，執行<code>UPDATE</code>被推遲到沒有其他客戶正在讀取表時。 
</p>

<p>如果你從一個表達式的<code>tbl_name</code>存取列，<code>UPDATE</code>使用列的當前值。例如，下列語句設置<code>age</code>為它的當前值加1： 
</p>

<pre>mysql&gt; UPDATE persondata SET age=age+1;
</pre>

<p><code>UPDATE</code>賦值是從左到右計算。例如，下列語句兩倍<code>age</code>列，然後加1： 
</p>

<pre>mysql&gt; UPDATE persondata SET age=age*2, age=age+1;
</pre>

<p>如果你設置列為其它當前有的值，<strong>MySQL</strong>注意到這點並且不更新它。 
</p>

<p><a NAME="IDX546"></a><code>UPDATE</code>返回實際上被改變的行的數量。在<strong>MySQL</strong> 
3.22或以後版本中，C API函數<code>mysql_info()</code>返回被匹配並且更新的行數和在<code>UPDATE</code>期間發生警告的數量。 
</p>

<p>在<strong>MySQL</strong>3.23中，你可使用<code>LIMIT #</code>來保証只有一個給定數量的行被改變。 
</p>

<p>　</p>

<h2><a NAME="USE" HREF="manual_toc.html#USE">7.18<code> USE</code>句法</a></h2>

<pre>USE db_name 
</pre>

<p><code>USE db_name</code>語句告訴<strong>MySQL</strong>使用<code>db_name</code>資料庫作為隨後的查詢的預設資料庫。資料庫保持到會話結束，或發出另外一個<code>USE</code>語句： 
</p>

<pre>mysql&gt; USE db1;
mysql&gt; SELECT count(*) FROM mytable;      # selects from db1.mytable
mysql&gt; USE db2;
mysql&gt; SELECT count(*) FROM mytable;      # selects from db2.mytable
</pre>

<p>利用<code>USE</code>語句使得一個特定的資料庫稱為當前資料庫並不阻止你訪問在另外的資料庫中的表。下面的例子訪問<code>db1</code>資料庫中的<code>author</code>表和<code>db2</code>資料庫中的<code>editor</code>表： 
</p>

<pre>mysql&gt; USE db1;
mysql&gt; SELECT author_name,editor_name FROM author,db2.editor
           WHERE author.editor_id = db2.editor.editor_id;
</pre>

<p><code>USE</code>語句提供了Sybase的兼容性。 </p>

<p>　</p>

<h2><a NAME="FLUSH" HREF="manual_toc.html#FLUSH">7.19<code> FLUSH</code>句法(清除緩存）</a></h2>

<pre>FLUSH flush_option [,flush_option]
</pre>

<p>如果你想要清除一些<strong>MySQL</strong>使用內部緩存，你應該使用<code>FLUSH</code>命令。為了執行<code>FLUSH</code>，你必須有<strong>reload</strong>權限。 
</p>

<p><code>flush_option</code>可以是下列任何東西： </p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><code>HOSTS</code> </td>
    <td>清空主機緩存表。如果你的某些主機改變IP數字，或如果你得到錯誤消息<code>Host 
    ... is blocked</code>，你應該清空主機表。當在連接<strong>MySQL</strong>伺服器時，對一台給定的主機有多於<code>max_connect_errors</code>個錯誤連續不斷地發生，<strong>MySQL</strong>認定某些東西錯了並且阻止主機進一步的連接請求。清空主機表允許主機再嘗試連接。見<a HREF="manual_Problems.html#Blocked_host">18.2.3<code> Host '...' is blocked</code>錯誤</a>)。你可用<code>-O 
    max_connection_errors=999999999</code>啟動<code>mysqld</code>來避免這條錯誤消息。 
    </td>
  </tr>
  <tr>
    <td><code>LOGS</code> </td>
    <td>關閉並且再打開標準和更新記錄文件。如果你指定了一個沒有擴展名的更新記錄文件，新的更新記錄文件的擴展數字將相對先前的文件加1。 
    </td>
  </tr>
  <tr>
    <td><code>PRIVILEGES</code> </td>
    <td>從<code>mysql</code>資料庫授權表中重新裝載權限。 </td>
  </tr>
  <tr>
    <td><code>TABLES</code> </td>
    <td>關閉所有打開的表。 </td>
  </tr>
  <tr>
    <td><code>STATUS</code> </td>
    <td>重置大多數狀態變數到0。 </td>
  </tr>
</table>

<p>你也可以用<code>mysqladmin</code>實用程式，使用<code>flush-hosts</code>, <code>flush-logs</code>, 
<code>reload</code>或<code>flush-tables</code>命令來訪問上述的每一個命令。 </p>

<p>　</p>

<h2><a NAME="KILL" HREF="manual_toc.html#KILL">7.20<code> KILL</code>句法</a></h2>

<pre>KILL thread_id 
</pre>

<p>每個對<code>mysqld</code>的連接以一個單獨的執行緒運行。你可以用看<code>SHOW 
PROCESSLIST</code>命令察看哪個執行緒正在運行，並且用<code>KILL thread_id</code>命令殺死一個執行緒。 
</p>

<p>如果你有<strong>process</strong>權限，你能看到並且殺死所有執行緒。否則，你只能看到並且殺死你自己的執行緒。 
</p>

<p>你也可以使用<code>mysqladmin processlist</code>和<code>mysqladmin kill</code>命令檢查並殺死執行緒。 
</p>

<p><a NAME="IDX554"></a> <a NAME="IDX555"></a> <a NAME="IDX556"></a> <a NAME="IDX557"></a> 
<a NAME="IDX558"></a> <a NAME="IDX559"></a> <a NAME="IDX560"></a> <a NAME="IDX561"></a> <a NAME="IDX562"></a> <a NAME="IDX563"></a> <a NAME="IDX564"></a> </p>

<h2><a NAME="SHOW" HREF="manual_toc.html#SHOW">7.21<code> SHOW</code>句法 (得到表，列等的資訊）</a></h2>

<pre>   SHOW DATABASES [LIKE wild]
or SHOW TABLES [FROM db_name] [LIKE wild]
or SHOW COLUMNS FROM tbl_name [FROM db_name] [LIKE wild]
or SHOW INDEX FROM tbl_name [FROM db_name]
or SHOW STATUS
or SHOW VARIABLES [LIKE wild]
or SHOW [FULL] PROCESSLIST
or SHOW TABLE STATUS [FROM db_name] [LIKE wild]
or SHOW GRANTS FOR user
</pre>

<p><code>SHOW</code>提供關於資料庫、桌子、列或伺服器的資訊。如果使用<code>LIKE 
wild</code>部分，<code>wild</code>字符串可以是一個使用SQL的<samp>“%”</samp>和<samp>“_”</samp>通配符的字符串。 
</p>

<p>你能使用<code>db_name.tbl_name</code>作為<code>tbl_name FROM db_name</code>句法的另一種選擇。這兩個語句是相等的： 
</p>

<pre>mysql&gt; SHOW INDEX FROM mytable FROM mydb;
mysql&gt; SHOW INDEX FROM mydb.mytable;
</pre>

<p><code>SHOW DATABASES</code>列出在<strong>MySQL</strong>伺服器主機上的資料庫。你也可以用<code>mysqlshow</code>命令得到這張表。 
</p>

<p><code>SHOW TABLES</code>列出在一個給定的資料庫中的表。你也可以用<code>mysqlshow 
db_name</code>命令得到這張表。 </p>

<p><strong>注意：</strong>如果一個用戶沒有一個表的任何權限，表將不在<code>SHOW 
TABLES</code>或<code>mysqlshow db_name</code>中的輸出中顯示。 </p>

<p><code>SHOW COLUMNS</code>列出在一個給定表中的列。如果列類型不同於你期望的是基於<code>CREATE 
TABLE</code>語句的那樣，注意，MySQL有時改變列類型。見<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱含的列說明變化</a>。 </p>

<p><code>DESCRIBE</code>語句提供了類似<code>SHOW COLUMNS</code>的資訊。見<a HREF="manual_Reference.html#DESCRIBE">7.23<code> DESCRIBE</code> 句法 (得到列的資訊）</a>。 
</p>

<p><code>SHOW TABLE STATUS</code>（在版本3.23引入)運行類似<code>SHOW STATUS</code>，但是提供每個表的更多資訊。你也可以使用<code>mysqlshow 
--status db_name</code>命令得到這張表。下面的列被返回： </p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>列</strong> </td>
    <td><strong>含義</strong> </td>
  </tr>
  <tr>
    <td><code>Name</code> </td>
    <td>表名</td>
  </tr>
  <tr>
    <td><code>Type</code> </td>
    <td>表的類型 (ISAM，MyISAM或HEAP)</td>
  </tr>
  <tr>
    <td><code>Row_format</code> </td>
    <td>行儲存格式 (固定, 動態, 或壓縮）</td>
  </tr>
  <tr>
    <td><code>Rows</code> </td>
    <td>行數量</td>
  </tr>
  <tr>
    <td><code>Avg_row_length</code> </td>
    <td>平均行長度</td>
  </tr>
  <tr>
    <td><code>Data_length</code> </td>
    <td>數據文件的長度</td>
  </tr>
  <tr>
    <td><code>Max_data_length</code> </td>
    <td>數據文件的最大長度</td>
  </tr>
  <tr>
    <td><code>Index_length</code> </td>
    <td>索引文件的長度</td>
  </tr>
  <tr>
    <td><code>Data_free</code> </td>
    <td>已分配但未使用了字節數</td>
  </tr>
  <tr>
    <td><code>Auto_increment</code> </td>
    <td>下一個 autoincrement(自動加1）值</td>
  </tr>
  <tr>
    <td><code>Create_time</code> </td>
    <td>表被創造的時間</td>
  </tr>
  <tr>
    <td><code>Update_time</code> </td>
    <td>數據文件最後更新的時間</td>
  </tr>
  <tr>
    <td><code>Check_time</code> </td>
    <td>最後對表運行一個檢查的時間</td>
  </tr>
  <tr>
    <td><code>Create_options</code> </td>
    <td>與<code>CREATE TABLE</code>一起使用的額外選項 </td>
  </tr>
  <tr>
    <td><code>Comment</code> </td>
    <td>當創造表時，使用的注釋 (或為什麼MySQL不能存取表資訊的一些資訊)。 
    </td>
  </tr>
</table>

<p><code>SHOW FIELDS</code>是<code>SHOW COLUMNS</code>一個同義詞，<code>SHOW KEYS</code>是<code>SHOW 
INDEX</code>一個同義詞。你也可以用<code>mysqlshow db_name tbl_name</code>或<code>mysqlshow 
-k db_name tbl_name</code> 列出一張表的列或索引。</p>

<p><code>SHOW INDEX</code>以非常相似於ODBC的<code>SQLStatistics</code>調用的格式返回索引資訊。下面的列被返回： 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>列</strong> </td>
    <td><strong>含義</strong> </td>
  </tr>
  <tr>
    <td><code>Table</code> </td>
    <td>表名</td>
  </tr>
  <tr>
    <td><code>Non_unique</code> </td>
    <td>0，如果索引不能包含重複。 </td>
  </tr>
  <tr>
    <td><code>Key_name</code> </td>
    <td>索引名</td>
  </tr>
  <tr>
    <td><code>Seq_in_index</code> </td>
    <td>索引中的列順序號, 從 1 開始。 </td>
  </tr>
  <tr>
    <td><code>Column_name</code> </td>
    <td>列名。 </td>
  </tr>
  <tr>
    <td><code>Collation</code> </td>
    <td>列怎樣在索引中被排序。在<strong>MySQL</strong>中，這可以有值<code>A</code>（升序) 
    或<code>NULL</code>（不排序)。 </td>
  </tr>
  <tr>
    <td><code>Cardinality</code> </td>
    <td>索引中唯一值的數量。這可通過運行<code>isamchk -a</code>更改. </td>
  </tr>
  <tr>
    <td><code>Sub_part</code> </td>
    <td>如果列只是部分被索引，索引字符的數量。<code>NULL</code>，如果整個鍵被索引。 
    </td>
  </tr>
</table>

<p><a NAME="IDX565"></a><code>SHOW STATUS</code>提供伺服器的狀態資訊(像<code>mysqladmin 
extended-status</code>一樣)。輸出類似於下面的顯示，盡管格式和數字可以有點不同： 
</p>

<pre>
+--------------------------+--------+
| Variable_name            | Value  |
+--------------------------+--------+
| Aborted_clients          | 0      |
| Aborted_connects         | 0      |
| Connections              | 17     |
| Created_tmp_tables       | 0      |
| Delayed_insert_threads   | 0      |
| Delayed_writes           | 0      |
| Delayed_errors           | 0      |
| Flush_commands           | 2      |
| Handler_delete           | 2      |
| Handler_read_first       | 0      |
| Handler_read_key         | 1      |
| Handler_read_next        | 0      |
| Handler_read_rnd         | 35     |
| Handler_update           | 0      |
| Handler_write            | 2      |
| Key_blocks_used          | 0      |
| Key_read_requests        | 0      |
| Key_reads                | 0      |
| Key_write_requests       | 0      |
| Key_writes               | 0      |
| Max_used_connections     | 1      |
| Not_flushed_key_blocks   | 0      |
| Not_flushed_delayed_rows | 0      |
| Open_tables              | 1      |
| Open_files               | 2      |
| Open_streams             | 0      |
| Opened_tables            | 11     |
| Questions                | 14     |
| Slow_queries             | 0      |
| Threads_connected        | 1      |
| Threads_running          | 1      |
| Uptime                   | 149111 |
+--------------------------+--------+
</pre>

<p>上面列出的狀態變數有下列含義： </p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><code>Aborted_clients</code> </td>
    <td>由於客戶沒有正確關閉連接已經死掉，已經放棄的連接數量。 </td>
  </tr>
  <tr>
    <td><code>Aborted_connects</code> </td>
    <td>嘗試已經失敗的MySQL伺服器的連接的次數。 </td>
  </tr>
  <tr>
    <td><code>Connections</code> </td>
    <td>試圖連接MySQL伺服器的次數。 </td>
  </tr>
  <tr>
    <td><code>Created_tmp_tables</code> </td>
    <td>當執行語句時，已經被創造了的隱含臨時表的數量。 </td>
  </tr>
  <tr>
    <td><code>Delayed_insert_threads</code> </td>
    <td>正在使用的延遲插入處理器執行緒的數量。 </td>
  </tr>
  <tr>
    <td><code>Delayed_writes</code> </td>
    <td>用<code>INSERT DELAYED</code>寫入的行數。 </td>
  </tr>
  <tr>
    <td><code>Delayed_errors</code> </td>
    <td>用<code>INSERT DELAYED</code>寫入的發生某些錯誤(可能<code>重複鍵值</code>)的行數。 
    </td>
  </tr>
  <tr>
    <td><code>Flush_commands</code> </td>
    <td>執行<code>FLUSH</code>命令的次數。 </td>
  </tr>
  <tr>
    <td><code>Handler_delete</code> </td>
    <td>請求從一張表中刪除行的次數。 </td>
  </tr>
  <tr>
    <td><code>Handler_read_first</code> </td>
    <td>請求讀入表中第一行的次數。 </td>
  </tr>
  <tr>
    <td><code>Handler_read_key</code> </td>
    <td>請求數字基於鍵讀行。 </td>
  </tr>
  <tr>
    <td><code>Handler_read_next</code> </td>
    <td>請求讀入基於一個鍵的一行的次數。 </td>
  </tr>
  <tr>
    <td><code>Handler_read_rnd</code> </td>
    <td>請求讀入基於一個固定位置的一行的次數。 </td>
  </tr>
  <tr>
    <td><code>Handler_update</code> </td>
    <td>請求更新表中一行的次數。 </td>
  </tr>
  <tr>
    <td><code>Handler_write</code> </td>
    <td>請求向表中插入一行的次數。 </td>
  </tr>
  <tr>
    <td><code>Key_blocks_used</code> </td>
    <td>用於關鍵字緩存的塊的數量。 </td>
  </tr>
  <tr>
    <td><code>Key_read_requests</code> </td>
    <td>請求從緩存讀入一個鍵值的次數。 </td>
  </tr>
  <tr>
    <td><code>Key_reads</code> </td>
    <td>從磁碟物理讀入一個鍵值的次數。 </td>
  </tr>
  <tr>
    <td><code>Key_write_requests</code> </td>
    <td>請求將一個關鍵字塊寫入緩存次數。 </td>
  </tr>
  <tr>
    <td><code>Key_writes</code> </td>
    <td>將一個鍵值塊物理寫入磁碟的次數。 </td>
  </tr>
  <tr>
    <td><code>Max_used_connections</code> </td>
    <td>同時使用的連接的最大數目。 </td>
  </tr>
  <tr>
    <td><code>Not_flushed_key_blocks</code> </td>
    <td>在鍵緩存中已經改變但是還沒被清空到磁碟上的鍵塊。 </td>
  </tr>
  <tr>
    <td><code>Not_flushed_delayed_rows</code> </td>
    <td>在<code>INSERT DELAY</code>隊列中等待寫入的行的數量。 </td>
  </tr>
  <tr>
    <td><code>Open_tables</code> </td>
    <td>打開表的數量。 </td>
  </tr>
  <tr>
    <td><code>Open_files</code> </td>
    <td>打開文件的數量。 </td>
  </tr>
  <tr>
    <td><code>Open_streams</code> </td>
    <td>打開流的數量(主要用於日誌記載）</td>
  </tr>
  <tr>
    <td><code>Opened_tables</code> </td>
    <td>已經打開的表的數量。 </td>
  </tr>
  <tr>
    <td><code>Questions</code> </td>
    <td>發往伺服器的查詢的數量。 </td>
  </tr>
  <tr>
    <td><code>Slow_queries</code> </td>
    <td>要花超過<code>long_query_time</code>時間的查詢數量。 </td>
  </tr>
  <tr>
    <td><code>Threads_connected</code> </td>
    <td>當前打開的連接的數量。 </td>
  </tr>
  <tr>
    <td><code>Threads_running</code> </td>
    <td>不在睡眠的執行緒數量。 </td>
  </tr>
  <tr>
    <td><code>Uptime</code> </td>
    <td>伺服器工作了多少秒。 </td>
  </tr>
</table>

<p>關於上面的一些注釋： 

<ul>
  <li>如果<code>Opened_tables</code>太大，那麼你的<code>table_cache</code>變數可能太小。 
  </li>
  <li>如果<code>key_reads</code>太大，那麼你的<code>key_cache</code>可能太小。緩存命中率可以用<code>key_reads</code>/<code>key_read_requests</code>計算。 
  </li>
  <li>如果<code>Handler_read_rnd</code>太大，那麼你很可能有大量的查詢需要MySQL掃描整個表或你有沒正確使用鍵值的聯結(join)。 
  </li>
</ul>

<p><code>SHOW VARIABLES</code>顯示出一些<strong>MySQL</strong>系統變數的值，你也能使用<code>mysqladmin 
variables</code>命令得到這個資訊。如果預設值不合適，你能在<code>mysqld</code>啟動時使用命令行選項來設置這些變數的大多數。輸出類似於下面的顯示，盡管格式和數字可以有點不同： 
</p>

<pre>
+------------------------+--------------------------+
| Variable_name          | Value                    |
+------------------------+--------------------------+
| back_log               | 5                        |
| connect_timeout        | 5                        |
| basedir                | /my/monty/               |
| datadir                | /my/monty/data/          |
| delayed_insert_limit   | 100                      |
| delayed_insert_timeout | 300                      |
| delayed_queue_size     | 1000                     |
| join_buffer_size       | 131072                   |
| flush_time             | 0                        |
| interactive_timeout    | 28800                    |
| key_buffer_size        | 1048540                  |
| language               | /my/monty/share/english/ |
| log                    | OFF                      |
| log_update             | OFF                      |
| long_query_time        | 10                       |
| low_priority_updates   | OFF                      |
| max_allowed_packet     | 1048576                  |
| max_connections        | 100                      |
| max_connect_errors     | 10                       |
| max_delayed_threads    | 20                       |
| max_heap_table_size    | 16777216                 |
| max_join_size          | 4294967295               |
| max_sort_length        | 1024                     |
| max_tmp_tables         | 32                       |
| net_buffer_length      | 16384                    |
| port                   | 3306                     |
| protocol-version       | 10                       |
| record_buffer          | 131072                   |
| skip_locking           | ON                       |
| socket                 | /tmp/mysql.sock          |
| sort_buffer            | 2097116                  |
| table_cache            | 64                       |
| thread_stack           | 131072                   |
| tmp_table_size         | 1048576                  |
| tmpdir                 | /machine/tmp/            |
| version                | 3.23.0-alpha-debug       |
| wait_timeout           | 28800                    |
+------------------------+--------------------------+
</pre>

<p>見<a HREF="manual_Performance.html#Server_parameters">10.2.3 調節伺服器參數</a>。 
</p>

<p><a NAME="IDX566"></a><code>SHOW PROCESSLIST</code>顯示哪個執行緒正在運行，你也能使用<code>mysqladmin 
processlist</code>命令得到這個資訊。如果你有<strong>process</strong>權限， 
你能看見所有的執行緒，否則，你僅能看見你自己的執行緒。見<a HREF="manual_Reference.html#KILL">7.20<code> KILL</code>句法</a>。如果你不使用<code>FULL</code>選項，那麼每個查詢只有頭100字符被顯示出來。 
</p>

<p><code>SHOW GRANTS FOR user</code>列出對一個用戶必須發出以重複授權的授權命令。 
</p>

<pre>mysql&gt; SHOW GRANTS FOR <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="b9cbd6d6cdf9d5d6dad8d5d1d6cacd">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>;
<a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="c6edebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebebeb">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>-----+
| Grants for <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="ddafb2b2a99db1b2bebcb1b5b2aea9">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script>                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root''localhost' WITH GRANT OPTION  |
+---------------------------------------------------------------------+
<a NAME="IDX568"></a> <a NAME="IDX569"></a> </pre>

<h2><a NAME="EXPLAIN" HREF="manual_toc.html#EXPLAIN">7.22<code> EXPLAIN</code>句法(得到關於<code>SELECT</code>的資訊)</a></h2>

<pre>    EXPLAIN tbl_name
or  EXPLAIN SELECT select_options
</pre>

<p><code>EXPLAIN tbl_name</code>是<code>DESCRIBE tbl_name</code>或<code>SHOW COLUMNS 
FROM tbl_name</code>的一個同義詞。 </p>

<p>當你在一條<code>SELECT</code>語句前放上關鍵詞<code>EXPLAIN</code>，<strong>MySQL</strong>解釋它將如何處理<code>SELECT</code>，提供有關表如何聯結和以什麼次序聯結的資訊。 
</p>

<p>借助於<code>EXPLAIN</code>，你可以知道你什麼時候必須為表加入索引以得到一個使用索引找到記錄的更快的<code>SELECT</code>。你也能知道最佳化器是否以一個最佳次序聯結表。為了強制最佳化器對一個<code>SELECT</code>語句使用一個特定聯結次序，增加一個<code>STRAIGHT_JOIN</code>子句。 
</p>

<p>對於非簡單的聯結，<code>EXPLAIN</code>為用於<code>SELECT</code>語句中的每個表返回一行資訊。表以他們將被讀入的順序被列出。<strong>MySQL</strong>用一邊掃描多次聯結的方式解決所有聯結，這意味著<strong>MySQL</strong>從第一個表中讀一行，然後找到在第二個表中的一個匹配行，然後在第3個表中等等。當所有的表被處理完，它輸出選擇的列並且回溯表列表直到找到一個表有更多的匹配行，從該表讀入下一行並繼續處理下一個表。 
</p>

<p>從<code>EXPLAIN</code>的輸出包括下面列： 

<dl COMPACT="EXPLAIN">
  <dt><code>table</code> </dt>
  <dd>輸出的行所引用的表。 </dd>
  <dt><code>type</code> </dt>
  <dd>聯結類型。各種類型的資訊在下面給出。 </dd>
  <dt><code>possible_keys</code> </dt>
  <dd><code>possible_keys</code>列指出<strong>MySQL</strong>能使用哪個索引在該表中找到行。注意，該列完全獨立於表的次序。這意味著在possible_keys中的某些鍵實際上不能以產生的表次序使用。如果該列是空的，沒有相關的索引。在這種情況下，你也許能通過檢驗<code>WHERE</code>子句看是否它引用某些列或列不是適合索引來提高你的查詢性能。如果是這樣，創造一個適當的索引並且在用<code>EXPLAIN</code>檢查查詢。見<a HREF="manual_Reference.html#ALTER_TABLE">7.8<code> ALTER TABLE</code>句法</a>。為了看清一張表有什麼索引，使用<code>SHOW 
    INDEX FROM tbl_name</code>。 </dd>
  <dt><code>key</code> </dt>
  <dd><code>key</code>列顯示<strong>MySQL</strong>實際決定使用的鍵。如果沒有索引被選擇，鍵是<code>NULL</code>。 
  </dd>
  <dt><code>key_len</code> </dt>
  <dd><code>key_len</code>列顯示<strong>MySQL</strong>決定使用的鍵長度。如果鍵是<code>NULL</code>，長度是<code>NULL</code>。注意這告訴我們MySQL將實際使用一個多部鍵值的幾個部分。 
  </dd>
  <dt><code>ref</code> </dt>
  <dd><code>ref</code>列顯示哪個列或常數與<code>key</code>一起用於從表中選擇行。 
  </dd>
  <dt><code>rows</code> </dt>
  <dd><code>rows</code>列顯示<strong>MySQL</strong>相信它必須檢驗以執行查詢的行數。 
  </dd>
  <dt><code>Extra</code> </dt>
  <dd>如果<code>Extra</code>列包括文字<code>Only index</code>，這意味著資訊只用索引樹中的資訊檢索出的。通常，這比掃描整個表要快。如果<code>Extra</code>列包括文字<code>where 
    used</code>，它意味著一個<code>WHERE</code>子句將被用來限制哪些行與下一個表匹配或發向客戶。 
  </dd>
</dl>

<p>不同的聯結類型列在下面，以最好到最差類型的次序： 

<dl COMPACT="IDX571">
  <dt><code>system</code> </dt>
  <dd>桌子僅有一行(=系統表)。這是<code>const</code>聯結類型的一個特例。 <a NAME="IDX572"></a> <a NAME="IDX573"></a> </dd>
  <dt><code>const</code> </dt>
  <dd>桌子有最多一個匹配行，它將在查詢開始時被讀取。因為僅有一行，在這行的列值可被剩下的最佳化器認為是常數。 
    <code>const</code>表很快，因為它們只讀取一次！ </dd>
  <dt><code>eq_ref</code> </dt>
  <dd>對於每個來自於先前的表的行組合，從該表中讀取一行。這可能是最好的聯結類型，除了<code>const</code>類型。它用在一個索引的所有部分被聯結使用並且索引是<code>UNIQUE</code>或<code>PRIMARY 
    KEY</code>。 </dd>
  <dt><code>ref</code> </dt>
  <dd>對於每個來自於先前的表的行組合，所有有匹配索引值的行將從這張表中讀取。如果聯結只使用鍵的最左面前綴，或如果鍵不是<code>UNIQUE</code>或<code>PRIMARY 
    KEY</code>（換句話說，如果聯結不能基於鍵值選擇單個行的話)，使用<code>ref</code>。如果被使用的鍵僅僅匹配一些行，該聯結類型是不錯的。 
  </dd>
  <dt><code>range</code> </dt>
  <dd>只有在一個給定範圍的行將被檢索，使用一個索引選擇行。<code>ref</code>列顯示哪個索引被使用。 
  </dd>
  <dt><code>index</code> </dt>
  <dd>這與<code>ALL</code>相同，除了只有索引樹被掃描。這通常比<code>ALL</code>快，因為索引文件通常比數據文件小。 
  </dd>
  <dt><code>ALL</code> </dt>
  <dd>對於每個來自於先前的表的行組合，將要做一個完整的表掃描。如果表格是第一個沒標記<code>const</code>的表，這通常不好，並且通常在所有的其他情況下<strong>很</strong>差。你通常可以通過增加更多的索引來避免<code>ALL</code>，使得行能從早先的表中基於常數值或列值被檢索出。 
  </dd>
</dl>

<p>通過相乘<code>EXPLAIN</code>輸出的<code>rows</code>行的所有值，你能得到一個關於一個聯結要多好的提示。這應該粗略地告訴你<strong>MySQL</strong>必須檢驗多少行以執行查詢。當你使用<code>max_join_size</code>變數限制查詢時，也用這個數字。見<a HREF="manual_Performance.html#Server_parameters">10.2.3 調節伺服器參數</a>。 </p>

<p>下列例子顯示出一個<code>JOIN</code>如何能使用<code>EXPLAIN</code>提供的資訊逐步被最佳化。 
</p>

<p>假定你有顯示在下面的<code>SELECT</code>語句，你使用<code>EXPLAIN</code>檢驗： 
</p>

<pre>EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
            tt.ProjectReference, tt.EstimatedShipDate,
            tt.ActualShipDate, tt.ClientID,
            tt.ServiceCodes, tt.RepetitiveID,
            tt.CurrentProcess, tt.CurrentDPPerson,
            tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
            et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
            AND tt.ActualPC = et.EMPLOYID
            AND tt.AssignedPC = et_1.EMPLOYID
            AND tt.ClientID = do.CUSTNMBR;
</pre>

<p>對於這個例子，假定： 

<ul>
  <li>被比較的列被聲明如下： <table BORDER="1" WIDTH="100%" NOSAVE="#101090">
      <tr>
        <td><strong>表</strong> </td>
        <td><strong>列</strong> </td>
        <td><strong>列類型</strong> </td>
      </tr>
      <tr>
        <td><code>tt</code> </td>
        <td><code>ActualPC</code> </td>
        <td><code>CHAR(10)</code> </td>
      </tr>
      <tr>
        <td><code>tt</code> </td>
        <td><code>AssignedPC</code> </td>
        <td><code>CHAR(10)</code> </td>
      </tr>
      <tr>
        <td><code>tt</code> </td>
        <td><code>ClientID</code> </td>
        <td><code>CHAR(10)</code> </td>
      </tr>
      <tr>
        <td><code>et</code> </td>
        <td><code>EMPLOYID</code> </td>
        <td><code>CHAR(15)</code> </td>
      </tr>
      <tr>
        <td><code>do</code> </td>
        <td><code>CUSTNMBR</code> </td>
        <td><code>CHAR(15)</code> </td>
      </tr>
    </table>
  </li>
  <li>表有顯示在下面的索引： <table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
      <tr>
        <td><strong>表</strong></td>
        <td><strong>索引</strong> </td>
      </tr>
      <tr>
        <td><code>tt</code> </td>
        <td><code>ActualPC</code> </td>
      </tr>
      <tr>
        <td><code>tt</code> </td>
        <td><code>AssignedPC</code> </td>
      </tr>
      <tr>
        <td><code>tt</code> </td>
        <td><code>ClientID</code> </td>
      </tr>
      <tr>
        <td><code>et</code> </td>
        <td><code>EMPLOYID</code>（主鍵）</td>
      </tr>
      <tr>
        <td><code>do</code> </td>
        <td><code>CUSTNMBR</code>（主鍵）</td>
      </tr>
    </table>
  </li>
  <li><code>tt.ActualPC</code>值不是均勻分布的。 </li>
</ul>

<p>開始，在任何最佳化被施行前，<code>EXPLAIN</code>語句產生下列資訊： </p>

<pre>table type possible_keys                key  key_len ref  rows  Extra
et    ALL  PRIMARY                      NULL NULL    NULL 74
do    ALL  PRIMARY                      NULL NULL    NULL 2135
et_1  ALL  PRIMARY                      NULL NULL    NULL 74
tt    ALL  AssignedPC,ClientID,ActualPC NULL NULL    NULL 3872
      range checked for each record (key map: 35)
</pre>

<p>因為<code>type</code>對每張表是<code>ALL</code>，這個輸出顯示<strong>MySQL</strong>正在對所有表進行一個完整聯結！這將花相當長的時間，因為必須檢驗每張表的行數的乘積次數！對於一個實例，這是<code>74 
* 2135 * 74 * 3872 = 45,268,558,720</code>行。如果表更大，你只能想像它將花多長時間…… 
</p>

<p>如果列聲明不同，這裡的一個問題是<strong>MySQL</strong>(還)不能高效地在列上使用索引。在本文中，<code>VARCHAR</code>和<code>CHAR</code>是相同的，除非他們聲明為不同的長度。因為<code>tt.ActualPC</code>被聲明為<code>CHAR(10)</code>並且<code>et.EMPLOYID</code>被聲明為<code>CHAR(15)</code>，有一個長度失配。 
</p>

<p>為了修正在列長度上的不同，使用<code>ALTER TABLE</code>將<code>ActualPC</code>的長度從10個字符變為15個字符：</p>

<pre>mysql&gt; ALTER TABLE tt MODIFY ActualPC VARCHAR(15);
</pre>

<p>現在<code>tt.ActualPC</code>和<code>et.EMPLOYID</code>都是<code>VARCHAR(15)</code>，再執行<code>EXPLAIN</code>語句產生這個結果： 
</p>

<pre>table type   possible_keys   key     key_len ref         rows    Extra
tt    ALL    AssignedPC,ClientID,ActualPC NULL NULL NULL 3872    where used
do    ALL    PRIMARY         NULL    NULL    NULL        2135
      range checked for each record (key map: 1)
et_1  ALL    PRIMARY         NULL    NULL    NULL        74
      range checked for each record (key map: 1)
et    eq_ref PRIMARY         PRIMARY 15      tt.ActualPC 1
</pre>

<p>這不是完美的，但是是好一些了(<code>rows</code>值的乘積少了一個74一個因子)，這個版本在幾秒內執行。 
</p>

<p>第2種改變能消除<code>tt.AssignedPC = et_1.EMPLOYID</code>和<code>tt.ClientID = 
do.CUSTNMBR</code>比較的列的長度失配：</p>

<pre>mysql&gt; ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
                      MODIFY ClientID   VARCHAR(15);
</pre>

<p>現在<code>EXPLAIN</code>產生的輸出顯示在下面： </p>

<pre>table type   possible_keys   key     key_len ref            rows     Extra
et    ALL    PRIMARY         NULL    NULL    NULL           74
tt    ref    AssignedPC,ClientID,ActualPC ActualPC 15 et.EMPLOYID 52 where used
et_1  eq_ref PRIMARY         PRIMARY 15      tt.AssignedPC  1
do    eq_ref PRIMARY         PRIMARY 15      tt.ClientID    1
</pre>

<p>這“幾乎”像它能得到的一樣好。 </p>

<p>剩下的問題是，預設地，<strong>MySQL</strong>假設在<code>tt.ActualPC</code>列的值是均勻分布的，並且對<code>tt</code>表不是這樣。幸好，很容易告訴<strong>MySQL</strong>關於這些： 
</p>

<pre>shell&gt; myisamchk --analyze PATH_TO_MYSQL_DATABASE/tt
shell&gt; mysqladmin refresh
</pre>

<p>現在聯結是“完美”的了，而且<code>EXPLAIN</code>產生這個結果： </p>

<pre>table type   possible_keys   key     key_len ref            rows    Extra
tt    ALL    AssignedPC,ClientID,ActualPC NULL NULL NULL    3872    where used
et    eq_ref PRIMARY         PRIMARY 15      tt.ActualPC    1
et_1  eq_ref PRIMARY         PRIMARY 15      tt.AssignedPC  1
do    eq_ref PRIMARY         PRIMARY 15      tt.ClientID    1
</pre>

<p>注意在從<code>EXPLAIN</code>輸出的<code>rows</code>列是一個來自<strong>MySQL</strong>聯結最佳化器的“教育猜測”﹔為了最佳化查詢，你應該檢查數字是否接近事實。如果不是，你可以通過在你的<code>SELECT</code>語句裡面使用<code>STRAIGHT_JOIN</code>並且試著在在<code>FROM</code>子句以不同的次序列出表，可能得到更好的性能。</p>

<p>　</p>

<h2><a NAME="DESCRIBE" HREF="manual_toc.html#DESCRIBE">7.23<code> DESCRIBE</code>句法 (得到列的資訊）</a></h2>

<pre>{DESCRIBE | DESC} tbl_name {col_name | wild}
</pre>

<p><code>DESCRIBE</code>提供關於一張表的列的資訊。<code>col_name</code>可以是一個列名字或包含SQL的<samp>“%”</samp>和<samp>“_”</samp>通配符的一個字符串。 
</p>

<p>如果列類型不同於你期望的是基於一個<code>CREATE TABLE</code>語句，注意MySQL有時改變列類型。見<a HREF="manual_Reference.html#Silent_column_changes">7.7.1 隱含的列說明變化</a>。 </p>

<p><a NAME="IDX576"></a>這個語句為了與 Oracle 兼容而提供的。 </p>

<p><code>SHOW</code>語句提供類似的資訊。見<a HREF="manual_Reference.html#SHOW">7.21<code> 
SHOW</code>句法(得到表，列的資訊)</a>。</p>

<p>　</p>

<h2><a NAME="LOCK_TABLES" HREF="manual_toc.html#LOCK_TABLES">7.24<code> LOCK TABLES/UNLOCK 
TABLES</code>句法</a></h2>

<pre>LOCK TABLES tbl_name [AS alias] {READ | [LOW_PRIORITY] WRITE}
            [, tbl_name {READ | [LOW_PRIORITY] WRITE} ...]
...
UNLOCK TABLES
</pre>

<p><code>LOCK TABLES</code>為當前執行緒鎖定表。<code>UNLOCK TABLES</code>釋放被當前執行緒持有的任何鎖。當執行緒發出另外一個<code>LOCK 
TABLES</code>時，或當伺服器的連接被關閉時，當前執行緒鎖定的所有表自動被解鎖。 
</p>

<p>如果一個執行緒獲得在一個表上的一個<code>READ</code>鎖，該執行緒(和所有其他執行緒)只能從表中讀。如果一個執行緒獲得一個表上的一個<code>WRITE</code>鎖，那麼只有持鎖的執行緒<code>READ</code>或<code>WRITE</code>表，其他執行緒被阻止。 
</p>

<p>每個執行緒等待(沒有超時)直到它獲得它請求的所有鎖。 </p>

<p><code>WRITE</code>鎖通常比<code>READ</code>鎖有更高的優先級，以確保更改盡快被處理。這意味著，如果一個執行緒獲得<code>READ</code>鎖，並且然後另外一個執行緒請求一個<code>WRITE</code>鎖, 
隨後的<code>READ</code>鎖請求將等待直到<code>WRITE</code>執行緒得到了鎖並且釋放了它。當執行緒正在等待<code>WRITE</code>鎖時，你可以使用<code>LOW_PRIORITY 
WRITE</code>允許其他執行緒獲得<code>READ</code>鎖。如果你肯定終於有個時刻沒有執行緒將有一個<code>READ</code>鎖，你應該只使用<code>LOW_PRIORITY 
WRITE</code>。 </p>

<p>當你使用<code>LOCK TABLES</code>時，你必須鎖定你將使用的所有表！如果你正在一個查詢中多次使用一張表(用別名)，你必須對每個別名得到一把鎖！這條政策保証表鎖定不會死鎖。 
</p>

<p>注意你應該<strong>不</strong>鎖定任何你正在用<code>INSERT DELAYED</code>使用的表，這是因為在這種情況下，<code>INSERT</code>被一個不同的執行緒執行。 
</p>

<p>通常，你不必鎖定表，因為所有單個<code>UPDATE</code>語句是原語﹔沒有其他執行緒能防礙任何其它正在執行SQL語句的執行緒。當你想鎖定表，有一些情況： 

<ul>
  <li>如果你將在一堆表上運行許多操作，鎖定你將使用的表是較快的。當然缺點是，沒有其他執行緒能更新一個<code>READ</code>鎖定的表並且沒有其他執行緒能讀一個<code>WRITE</code>-鎖定的表。 
  </li>
  <li><strong>MySQL</strong>不支援事務環境，所以如果你想要保証在一個<code>SELECT</code>和一個<code>UPDATE</code>之間沒有其他執行緒到來，你必須使用<code>LOCK 
    TABLES</code>。下面顯示的例子要求<code>LOCK TABLES</code>以便安全地執行： 
    <pre>mysql&gt; LOCK TABLES trans READ, customer WRITE;
mysql&gt; select sum(value) from trans where customer_id= some_id;
mysql&gt; update customer set total_value=sum_from_previous_statement
           where customer_id=some_id;
mysql&gt; UNLOCK TABLES;</pre>
  </li>
</ul>

<p>沒有<code>LOCK TABLES</code>，另外一個執行緒可能有一個機會在執行<code>SELECT</code>和<code>UPDATE</code>語句之間往<code>trans</code>表中插入一個新行。 
</p>

<p>通過使用漸增更改(<code>UPDATE customer SET value=value+new_value</code>)或<code>LAST_INSERT_ID()</code>函數，在很多情況下你能使用<code>LOCK 
TABLES</code>來避免。 </p>

<p>你也可以使用用戶級鎖定函數<code>GET_LOCK()</code>和<code>RELEASE_LOCK()</code>解決一些情況，這些鎖保存在伺服器的一張哈希表中並且用<code>pthread_mutex_lock()</code>和<code>pthread_mutex_unlock()</code>實現以獲得高速度。見<a HREF="manual_Reference.html#Miscellaneous_functions">7.4.12 其他函數</a>。 </p>

<p>有關鎖定政策的更多資訊，見<a HREF="manual_Performance.html#Internal_locking">10.2.8 MySQL 怎樣鎖定表</a>。 </p>

<p><a NAME="IDX580"></a> </p>

<h2><a NAME="SET_OPTION" HREF="manual_toc.html#SET_OPTION">7.25<code> SET OPTION</code>句法</a></h2>

<pre>SET [OPTION] SQL_VALUE_OPTION= value, ...
</pre>

<p><code>SET OPTION</code>設置影響伺服器或你的客戶操作的各種選項。你設置的任何選擇保持有效直到當前會話結束，或直到你設置選項為不同的值。 

<dl COMPACT="SET_OPTION">
  <dt><code>CHARACTER SET character_set_name | DEFAULT</code> </dt>
  <dd>這用給定的映射表從/到客戶映射所有字符串。對<code>character_set_name</code>當前唯一的選項是 
    <code>cp1251_koi8</code>，但是你能容易通過編輯在<strong>MySQL</strong>原始碼版本<tt>的“sql/convert.cc”</tt>文件增加新的映射。預設映射能用<code>character_set_name</code>的<code>DEFAULT</code>值恢復。注意設置<code>CHARACTER 
    SET</code>選項的語法不同於設置其他選項目的語法。 </dd>
  <dt><code>PASSWORD = PASSWORD('some password')</code> </dt>
  <dd><a NAME="IDX581"></a>設置當前用戶的密碼。任何非匿名的用戶能改變他自己的密碼！ 
  </dd>
  <dt><code>PASSWORD FOR user = PASSWORD('some password')</code> </dt>
  <dd><a NAME="IDX582"></a>設置當前伺服器主機上的一個特定用戶的密碼。只有具備存取<code>mysql</code>資料庫的用戶可以這樣做。用戶應該以<code><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="6613150314260e09151208070b03">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></code>格式給出，這裡<code>user</code>和<code>hostname</code>完全與他們列在<code>mysql.user</code>表條目的<code>User</code>和<code>Host</code>列一樣。例如，如果你有一個條目其<code>User</code>和<code>Host</code>字段是<code>'bob'</code>和<code>'%.loc.gov'</code>，你將寫成： 
    <pre>mysql&gt; SET PASSWORD FOR bob@&quot;%.loc.gov&quot; = PASSWORD(&quot;newpass&quot;);

或

mysql&gt; UPDATE mysql.user SET password=PASSWORD(&quot;newpass&quot;) where user=&quot;bob' and host=&quot;%.loc.gov&quot;;
</pre>
  </dd>
  <dt><code>SQL_AUTO_IS_NULL = 0 | 1</code> </dt>
  <dd>如果設置為<code>1</code>（預設 )，那麼對於一個具有一個自動加1的行的表，用下列構件能找出最後插入的行：<code>WHERE 
    auto_increment_column IS NULL</code>。這被一些 ODBC 程式入Access使用。 </dd>
  <dt><code>SQL_BIG_TABLES = 0 | 1</code> </dt>
  <dd><a NAME="IDX583"></a>如果設置為<code>1</code>，所有臨時表存在在磁碟上而非內存中。這將更慢一些，但是對需要大的臨時表的大<code>SELECT</code>操作，你將不會得到<code>The 
    table tbl_name is full</code>的錯誤。對於一個新連接的預設值是<code>0</code>（即，使用內存中的臨時表)。 
  </dd>
  <dt><code>SQL_BIG_SELECTS = 0 | 1</code> </dt>
  <dd>如果設置為<code>0</code>，如果一個<code>SELECT</code>嘗試可能花很長的時間，<strong>MySQL</strong>將放棄。這在一個不妥當的<code>WHERE</code>語句發出時是有用的。一個大的查詢被定義為一個將可能必須檢驗多於<code>max_join_size</code>行的<code>SELECT</code>。對一個新連接的預設值是<code>1</code>（它將允許所有<code>SELECT</code>語句)。 
  </dd>
  <dt><code>SQL_LOW_PRIORITY_UPDATES = 0 | 1</code> </dt>
  <dd>如果設置為<code>1</code>，所有<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>和<code>LOCK 
    TABLE WRITE</code>語句等待，直到在受影響的表上沒有未解決的<code>SELECT</code>或<code>LOCK 
    TABLE READ</code>。 </dd>
  <dt><code>SQL_SELECT_LIMIT = value | DEFAULT</code> </dt>
  <dd>從<code>SELECT</code>語句返回的記錄的最大數量。如果一個<code>SELECT</code>有一個<code>LIMIT</code>子句，<code>LIMIT</code>優先與<code>SQL_SELECT_LIMIT</code>值。對一個新連接的預設值是“無限”的。如果你改變了限制，預設值能用<code>SQL_SELECT_LIMIT</code>的一個<code>DEFAULT</code>值恢復。 
  </dd>
  <dt><code>SQL_LOG_OFF = 0 | 1</code> </dt>
  <dd>如果設置為<code>1</code>，如果客戶有<strong>process</strong>權限，對該客戶沒有日誌記載到標準的日誌文件中。這不影響更新日誌記錄！ 
  </dd>
  <dt><code>SQL_LOG_UPDATE = 0 | 1</code> </dt>
  <dd>如果設置為<code>0</code>, 如果客戶有<strong>process</strong>權限，對該客戶沒有日誌記載到更新日誌中。這不影響標準日誌文件！ 
  </dd>
  <dt><code>TIMESTAMP = timestamp_value | DEFAULT</code> </dt>
  <dd>為該客戶設置時間。如果你使用更新日誌恢復行，這被用來得到原來的時間標記。 
  </dd>
  <dt><code>LAST_INSERT_ID = #</code> </dt>
  <dd>設置從<code>LAST_INSERT_ID()</code>返回的值。當你在更新一個表的命令中使用<code>LAST_INSERT_ID()</code>時，它儲存在更新日誌中。 
  </dd>
  <dt><code>INSERT_ID = #</code> </dt>
  <dd>設置當插入一個<code>AUTO_INCREMENT</code>值時，由<code>INSERT</code>命令使用的值。這主要與更新日誌一起使用。 
  </dd>
</dl>

<p><a NAME="IDX584"></a></p>

<h2><a NAME="GRANT" HREF="manual_toc.html#GRANT">7.26<code> GRANT</code>和<code>REVOKE</code>句法</a></h2>

<pre>GRANT priv_type [(column_list)] [, priv_type [(column_list)] ...]
    ON {tbl_name | * | *.* | db_name.*}
    TO user_name [IDENTIFIED BY 'password']
        [, user_name [IDENTIFIED BY 'password'] ...]
    [WITH GRANT OPTION]

REVOKE priv_type [(column_list)] [, priv_type [(column_list)] ...]
    ON {tbl_name | * | *.* | db_name.*}
    FROM user_name [, user_name ...]
</pre>

<p><code>GRANT</code>在<strong>MySQL</strong> 3.22.11或以後版本中實現。對於更早<strong>MySQL</strong>版本，<code>GRANT</code>語句不做任何事情。 
</p>

<p><code>GRANT</code>和<code>REVOKE</code>命令允許系統主管在4個權限級別上授權和撤回賦予<strong>MySQL</strong>用戶的權利： 

<dl COMPACT="GRANT">
  <dt><strong>全局級別</strong> </dt>
  <dd>全局權限作用於一個給定伺服器上的所有資料庫。這些權限儲存在<code>mysql.user</code>表中。 
  </dd>
  <dt><strong>資料庫級別</strong> </dt>
  <dd>資料庫權限作用於一個給定資料庫的所有表。這些權限儲存在<code>mysql.db</code>和<code>mysql.host</code>表中。 
  </dd>
  <dt><strong>表級別</strong> </dt>
  <dd>表權限作用於一個給定表的所有列。這些權限儲存在<code>mysql.tables_priv</code>表中。 
  </dd>
  <dt><strong>列級別</strong> </dt>
  <dd>列權限作用於在一個給定表的單個列。這些權限儲存在<code>mysql.columns_priv</code>表中。 
  </dd>
</dl>

<p>對於<code>GRANT</code>如何工作的例子，見<a HREF="manual_Privilege_system.html#Adding_users">6.11 為MySQL增加新的用戶權限</a>。</p>

<p>對於<code>GRANT</code>和<code>REVOKE</code>語句，<code>priv_type</code>可以指定下列的任何一個： 
</p>

<pre>ALL PRIVILEGES      FILE                RELOAD
ALTER               INDEX               SELECT
CREATE              INSERT              SHUTDOWN
DELETE              PROCESS             UPDATE
DROP                REFERENCES          USAGE
</pre>

<p><code>ALL</code>是<code>ALL PRIVILEGES</code>的一個同義詞，<code>REFERENCES</code>還沒被實現，<code>USAGE</code>當前是“沒有權限”的一個同義詞。它能用在你想要創建一個沒有權限用戶的時候。 
</p>

<p>為了從一個用戶撤回<strong>grant</strong>的權限，使用<code>GRANT OPTION</code>的一個<code>priv_type</code>值： 
</p>

<pre>REVOKE GRANT OPTION ON ... FROM ...;
</pre>

<p>對於表，你能指定的唯一<code>priv_type</code>值是<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>CREATE</code>、<code>DROP</code>、<code>GRANT</code>、<code>INDEX</code>和<code>ALTER</code>。 
</p>

<p>對於列，你能指定的唯一<code>priv_type</code>值是(即，當你使用一個<code>column_list</code>子句時)是<code>SELECT</code>、<code>INSERT</code>和<code>UPDATE</code>。 
</p>

<p>你能通過使用<code>ON *.*</code>語法設置全局權限，你能通過使用<code>ON 
db_name.*</code>語法設置資料庫權限。如果你指定<code>ON *</code>並且你有一個當前資料庫，你將為該資料庫設置權限。(<strong>警告：</strong>如果你指定<code>ON 
*</code>而你<em>沒</em>有一個當前資料庫，你將影響全局權限！）</p>

<p>為了容納對任意主機的用戶授予的權利，<strong>MySQL</strong>支援以<code><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="f184829483b1999e8285">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></code>格式指定<code>user_name</code>值。如果你想要指定一個特殊字符的一個<code>user</code>字符串(例如<samp>“-”</samp>)，或一個包含特殊字符或通配符的<code>host</code>字符串(例如<samp>“%”</samp>)，你可以用括號括起能用戶或主機名字 
(例如，<code>'test-user'@'test-hostname'</code>)。 </p>

<p>你能在主機名中指定通配符。例如，<code>user@&quot;%.loc.gov&quot;</code>適用於在<code>loc.gov</code>域刈酚何主機的<code>user</code>，並且<code>user@&quot;144.155.166.%&quot;</code>適用於在<code>144.155.166</code>類 
C 子網刈酚何主機的<code>user</code>。 </p>

<p>簡單形式的<code>user</code>是<code>user@&quot;%&quot;</code>的一個同義詞。<strong>注意：</strong>如果你允許匿名用戶連接<strong>MySQL</strong>伺服器(它是預設的)，你也應該增加所有本地用戶如<code><a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="9beee8fee9dbf7f4f8faf7f3f4e8ef">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></code>，因為否則，當用戶試圖從本地機器上登錄到<strong>MySQL</strong>伺服器時，對於<code>mysql.user</code>表中的本地主機的匿名用戶條目將被使用！匿名用戶通過插入有<code>User=''</code>的條目到<code>mysql.user</code>表中來定義。通過執行這個查詢，你可以檢驗它是否作用於你： 
</p>

<pre>mysql&gt; SELECT Host,User FROM mysql.user WHERE User='';
</pre>

<p>目前，<code>GRANT</code>僅支援最長60個字符的主機、表、資料庫和列名。一個用戶名字能最多到16個字符。 
</p>

<p>對與一個表或列的權限是由4個權限級別的邏輯或形成的。例如，如果<code>mysql.user</code>表指定一個用戶有一個全局<strong>select</strong>權限，它不能被資料庫、表或列的一個條目否認。 
</p>

<p>對於一個列的權限能如下計算： </p>

<pre>global privileges
OR (database privileges AND host privileges)
OR table privileges
OR column privileges
</pre>

<p>在大多數情況下，你只授予用戶一個權限級別上的權限，因此現實通常不像上面所說的那樣複雜。:) 
權限檢查程序的細節在<a HREF="manual_Privilege_system.html#Privilege_system">6 
MySQL 存取權限系統</a>中給出。 </p>

<p>如果你為一個在<code>mysql.user</code>表中不存在的用戶/主機名組合授權，一個條目被增加並且保留直到用一個<code>DELETE</code>命令刪除。換句話說，<code>GRANT</code>可以創建<code>user</code>表的條目，但是<code>REVOKE</code>將不刪除﹔你必須明確地使用<code>DELETE</code>刪除. 
</p>

<p><a NAME="IDX586"></a>在<strong>MySQL</strong> 3.22.12或以後，如果創建一個新用戶或如果你有全局授予權限，用戶的密碼將被設置為由<code>IDENTIFIED 
BY</code>子句指定的密碼，如果給出一個。如果用戶已經有了一個密碼，它被一個新的代替。 
</p>

<p><strong>警告：</strong>如果你創造一個新用戶但是不指定一個<code>IDENTIFIED 
BY</code>子句，用戶沒有密碼。這是不安全的。 </p>

<p>密碼也能用<code>SET PASSWORD</code>命令設置。見<a HREF="manual_Reference.html#SET_OPTION">7.25<code> SET OPTION</code>句法</a>。 </p>

<p>如果你為一個資料庫授權，如果需要在<code>mysql.db</code>表中創建一個條目。當所有為資料庫的授權用<code>REVOKE</code>刪除時，這個條目被刪除。 
</p>

<p>如果一個用戶沒有在一個表上的任何權限，當用戶請求一系列表時，表不被顯示(例如，用一個<code>SHOW 
TABLES</code>語句)。 </p>

<p><code>WITH GRANT OPTION</code>子句給與用戶有授予其他用戶在指定的權限水平上的任何權限的能力。你應該謹慎對待你授予他<strong>grant</strong>權限的用戶，因為具有不同權限的兩個用戶也許能合並權限！ 
</p>

<p>你不能授予其他用戶你自己不具備的權限﹔ <strong>agree</strong>權限允許你放棄你僅僅擁有的那些權限。 
</p>

<p>要知道，當你將一個特定權限級別上的<strong>grant</strong>授予其他用戶，用戶已經擁有(或在未來被授予！)的在該級別上的任何權限也可由該用戶授權。假定你授權一個用戶在一個資料庫上的<strong>insert</strong>權限，那麼如果你授權在資料庫上<strong>select</strong>權限並且指定<code>WITH 
GRANT OPTION</code>，用戶能不僅放棄<strong>select</strong>權限，還有<strong>insert</strong>。如果你授權用戶在資料庫上的<strong>update</strong>權限，用戶能放棄<strong>insert</strong>、<strong>select</strong>和<strong>update</strong>。 
</p>

<p>你不應該將<strong>alter</strong>權限授予一個一般用戶。如果你這樣做，用戶可以通過重命名表試圖顛覆權限系統！</p>

<p>注意，如果你正在使用即使一個用戶的表或列的權限，伺服器要檢查所有用戶的表和列權限並且這將使<strong>MySQL</strong>慢下來一點。 
</p>

<p>當<code>mysqld</code>啟動時，所有的權限被讀入儲存器。資料庫、表和列權限馬上生效，而用戶級權限在下一次用戶連接時生效。你用<code>GRANT</code>或<code>REVOKE</code>對受權表執行的更改立即被伺服器知曉。如果你手工修改授權表(使用<code>INSERT</code>、UPDATE等等)，你應該執行一個<code>FLUSH 
PRIVILEGES</code>語句或運行<code>mysqladmin flush-privileges</code>告訴伺服器再次裝載授權表。見<a HREF="manual_Privilege_system.html#Privilege_changes">6.9 權限變化何時生效</a>。 </p>

<p><a NAME="IDX587"></a>ANSI SQL版本的<code>GRANT</code>與<strong>MySQL</strong>版本之間的最大差別： 

<ul>
  <li>ANSI SQL 沒有全局或資料庫級別權限，並且 ANSI SQL 不支援所有<strong>MySQL</strong>支援的權限。 
  </li>
  <li>當你在 ANSI SQL 拋棄一張表時，表的所有權限均被撤消。如果你在 
    ANSI SQL 撤銷權限，所有基於該權限的授權也被也被撤消。在<strong>MySQL</strong>中，權限只能用明確的<code>REVOKE</code>命令或操作<strong>MySQL</strong>授權表拋棄。 
  </li>
</ul>

<p>　</p>

<h2><a NAME="CREATE_INDEX" HREF="manual_toc.html#CREATE_INDEX">7.27<code>　CREATE INDEX</code>句法</a></h2>

<pre>CREATE [UNIQUE] INDEX index_name ON tbl_name (col_name[(length)],... )
</pre>

<p><code>CREATE INDEX</code>語句在<strong>MySQL</strong>版本 3.22 
以前不做任何事情。在 3.22 或以後版本中，<code>CREATE INDEX</code>被映射到一個<code>ALTER 
TABLE</code>語句來創建索引。見<a HREF="manual_Reference.html#ALTER_TABLE">7.8<code> 
ALTER TABLE</code>句法</a>。</p>

<p>通常，你在用<code>CREATE TABLE</code>創建表本身時創建表的所有索引。見<a HREF="manual_Reference.html#CREATE_TABLE">7.7<code> CREATE TABLE</code>句法</a>。<code>CREATE 
INDEX</code>允許你把索引加到現有表中。 </p>

<p>一個<code>(col1,col2,...)</code>形式的列表創造一個多列索引。索引值有給定列的值串聯而成。 
</p>

<p>對於<code>CHAR</code>和<code>VARCHAR</code>列，索引可以只用一個列的部分來創建，使用<code>col_name(length)</code>句法。（在<code>BLOB</code>和<code>TEXT</code>列上需要長度)。下面顯示的語句使用<code>name</code>列的頭10個字符創建一個索引： 
</p>

<pre>mysql&gt; CREATE INDEX part_of_name ON customer (name(10));
</pre>

<pre>因為大多數名字通常在頭10個字符不同，這個索引應該不比從整個<code>name</code>列的創建的索引慢多少。另外，在索引使用部分的列能使這個索引成為更小的文件大部分, 它能保存很多磁碟空格並且可能也加快<code>INSERT</code>操作！ </pre>

<p>注意，如果你正在使用<strong>MySQL</strong>版本 3.23.2 
或更新並且正在使用<code>MyISAM</code>桌子類型，你只能在可以有<code>NULL</code>值的列或一個<code>BLOB</code>/<code>TEXT</code>列上增加一個索引，</p>

<p>關於<strong>MySQL</strong>如何使用索引的更多資訊，見<a HREF="manual_Performance.html#MySQL_indexes">10.4 MySQL索引的使用</a>。 </p>

<p>　</p>

<h2><a NAME="DROP_INDEX" HREF="manual_toc.html#DROP_INDEX">7.28<code> DROP INDEX</code>句法</a></h2>

<pre>DROP INDEX index_name ON tbl_name
</pre>

<p><code>DROP INDEX</code>從<code>tbl_name</code>表拋棄名為<code>index_name</code>的索引。<code>DROP 
INDEX</code>在<strong>MySQL</strong> 3.22 以前的版本中不做任何事情。在 3.22 
或以後，<code>DROP INDEX</code>被映射到一個<code>ALTER TABLE</code>語句來拋棄索引。見<a HREF="manual_Reference.html#ALTER_TABLE">7.8<code> ALTER TABLE</code>句法</a>。</p>

<p><a NAME="IDX593"></a> </p>

<h2><a NAME="Comments" HREF="manual_toc.html#Comments">7.29 注釋句法</a></h2>

<p><strong>MySQL</strong>伺服器支援<code># to end of line</code>、<code>-- to end of 
line</code>和<code>/* in-line or multiple-line */</code>注釋風格： </p>

<pre>mysql&gt; select 1+1;     # This comment continues to the end of line
mysql&gt; select 1+1;     -- This comment continues to the end of line 
mysql&gt; select 1 /* this is an in-line comment */ + 1;
mysql&gt; select 1+
/*
this is a
multiple-line comment
*/
1;
</pre>

<p>注意<code>--</code>注釋風格要求你在<code>--</code>以後至少有一個空格！ 
</p>

<p>盡管服務者理解剛才描述的注釋句法，<code>mysql</code>客戶分析<code>/* 
... */</code>注釋的方式上有一些限制： 

<ul>
  <li>單引號和雙引號字符被用來標誌一個括起來的字符串的開始，即使在一篇注釋內。如果引號在主室內沒被第2個引號匹配，分析器不知道注釋已經結束。如果你正在交互式運行<code>mysql</code>，你能告知有些混亂，因為提示符從<code>mysql&gt;</code>變為<code>'&gt;</code>或<code>&quot;&gt;</code>。 
  </li>
  <li>一個分號被用來指出當前的SQL語句結束並且跟隨它的任何東西表示下一行的開始。 
  </li>
</ul>

<p>當你交互式運行<code>mysql</code>時和當你把命令放在一個文件中並用<code>mysql 
&lt; some-file</code>告訴<code>mysql</code>從那個文件讀它的輸入時，這些限制都適用。</p>

<p><strong>MySQL</strong>不支援<samp>‘--’</samp>的ANSI SQL注釋風格。見<a HREF="manual_Compatibility.html#Missing_comments">5.4.7<samp> ‘--’</samp>作為一篇注釋的開始</a>。 
</p>

<p>　</p>

<h2><a NAME="CREATE_FUNCTION" HREF="manual_toc.html#CREATE_FUNCTION">7.30<code> CREATE 
FUNCTION/DROP FUNCTION</code>句法</a></h2>

<pre>CREATE [AGGREGATE] FUNCTION function_name RETURNS {STRING|REAL|INTEGER}
       SONAME shared_library_name

DROP FUNCTION function_name
</pre>

<p>一個用戶可定義函數(UDF)是用一個像<strong>MySQL</strong>的原生（內置）函數如<code>ABS()</code>和<code>CONCAT()</code>的新函數來擴展<strong>MySQL</strong>的方法。 
</p>

<p><code>AGGREGATE</code>是<strong>MySQL</strong> 3.23的一個新選項。一個<code>AGGREGATE</code>函數功能就像一個原生<strong>MySQL</strong> 
<code>GROUP</code>函數如<code>SUM</code>或<code>COUNT()</code>。 </p>

<p><code>CREATE FUNCTION</code>在<code>mysql.func</code>系統表中保存函數名、類型和共享庫名。你必須對<code>mysql</code>資料庫有<strong>insert</strong>和<strong>delete</strong>權限以創建和拋棄函數。 
</p>

<p>所有活躍的函數在每次伺服器啟動時被重新裝載，除非你使用<code>--skip-grant-tables</code>選項啟動<code>mysqld</code>，在這種情況下，UDF初始化被跳過並且UDF是無法獲得的。（一個活躍函數是一個已經用<code>CREATE 
FUNCTION</code>裝載並且沒用<code>DROP FUNCTION</code>刪除的函數。) </p>

<p>關於編寫用戶可定義函數的指令，見<a HREF="manual_Adding_functions.html#Adding_functions">14 為MySQL增加新函數</a>。對於UDF的工作機制，函數必須用 
C 或 C++ 
編寫，你的作業系統必須支援動態裝載並且你必須動態編譯了<code>mysqld</code>(不是靜態)。 
</p>

<p>　</p>

<h2><a NAME="Reserved_words" HREF="manual_toc.html#Reserved_words">7.31 MySQL對保留詞很挑剔嗎？</a></h2>

<p>一個常見的問題源自於試圖使用<strong>MySQL</strong>內置的數據類型或函數名同名的列來創建資料庫表，例如<code>TIMESTAMP</code>或<code>GROUP</code>。你允許這樣做(例如，<code>ABS</code>是一個允許的列名)，但是當使用其名字也是列名的函數時，在一個函數名和<samp>“ 
( ”</samp>之間不允許白空。</p>

<p>下列詞明確地在<strong>MySQL</strong>中被保留。他們的大多數被 ANSI 
SQL92 禁止作為列或表名(例如，<code>group</code>)。一些被保留因為<strong>MySQL</strong>需要他們並且正在(當前)使用一個<code>yacc</code>分析器： 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><code>action</code> </td>
    <td><code>add</code> </td>
    <td><code>aggregate</code> </td>
    <td><code>all</code> </td>
  </tr>
  <tr>
    <td><code>alter</code> </td>
    <td><code>after</code> </td>
    <td><code>and</code> </td>
    <td><code>as</code> </td>
  </tr>
  <tr>
    <td><code>asc</code> </td>
    <td><code>avg</code> </td>
    <td><code>avg_row_length</code> </td>
    <td><code>auto_increment</code> </td>
  </tr>
  <tr>
    <td><code>between</code> </td>
    <td><code>bigint</code> </td>
    <td><code>bit</code> </td>
    <td><code>binary</code> </td>
  </tr>
  <tr>
    <td><code>blob</code> </td>
    <td><code>bool</code> </td>
    <td><code>both</code> </td>
    <td><code>by</code> </td>
  </tr>
  <tr>
    <td><code>cascade</code> </td>
    <td><code>case</code> </td>
    <td><code>char</code> </td>
    <td><code>character</code> </td>
  </tr>
  <tr>
    <td><code>change</code> </td>
    <td><code>check</code> </td>
    <td><code>checksum</code> </td>
    <td><code>column</code> </td>
  </tr>
  <tr>
    <td><code>columns</code> </td>
    <td><code>comment</code> </td>
    <td><code>constraint</code> </td>
    <td><code>create</code> </td>
  </tr>
  <tr>
    <td><code>cross</code> </td>
    <td><code>current_date</code> </td>
    <td><code>current_time</code> </td>
    <td><code>current_timestamp</code> </td>
  </tr>
  <tr>
    <td><code>data</code> </td>
    <td><code>database</code> </td>
    <td><code>databases</code> </td>
    <td><code>date</code> </td>
  </tr>
  <tr>
    <td><code>datetime</code> </td>
    <td><code>day</code> </td>
    <td><code>day_hour</code> </td>
    <td><code>day_minute</code> </td>
  </tr>
  <tr>
    <td><code>day_second</code> </td>
    <td><code>dayofmonth</code> </td>
    <td><code>dayofweek</code> </td>
    <td><code>dayofyear</code> </td>
  </tr>
  <tr>
    <td><code>dec</code> </td>
    <td><code>decimal</code> </td>
    <td><code>default</code> </td>
    <td><code>delayed</code> </td>
  </tr>
  <tr>
    <td><code>delay_key_write</code> </td>
    <td><code>delete</code> </td>
    <td><code>desc</code> </td>
    <td><code>describe</code> </td>
  </tr>
  <tr>
    <td><code>distinct</code> </td>
    <td><code>distinctrow</code> </td>
    <td><code>double</code> </td>
    <td><code>drop</code> </td>
  </tr>
  <tr>
    <td><code>end</code> </td>
    <td><code>else</code> </td>
    <td><code>escape</code> </td>
    <td><code>escaped</code> </td>
  </tr>
  <tr>
    <td><code>enclosed</code> </td>
    <td><code>enum</code> </td>
    <td><code>explain</code> </td>
    <td><code>exists</code> </td>
  </tr>
  <tr>
    <td><code>fields</code> </td>
    <td><code>file</code> </td>
    <td><code>first</code> </td>
    <td><code>float</code> </td>
  </tr>
  <tr>
    <td><code>float4</code> </td>
    <td><code>float8</code> </td>
    <td><code>flush</code> </td>
    <td><code>foreign</code> </td>
  </tr>
  <tr>
    <td><code>from</code> </td>
    <td><code>for</code> </td>
    <td><code>full</code> </td>
    <td><code>function</code> </td>
  </tr>
  <tr>
    <td><code>global</code> </td>
    <td><code>grant</code> </td>
    <td><code>grants</code> </td>
    <td><code>group</code> </td>
  </tr>
  <tr>
    <td><code>having</code> </td>
    <td><code>heap</code> </td>
    <td><code>high_priority</code> </td>
    <td><code>hour</code> </td>
  </tr>
  <tr>
    <td><code>hour_minute</code> </td>
    <td><code>hour_second</code> </td>
    <td><code>hosts</code> </td>
    <td><code>identified</code> </td>
  </tr>
  <tr>
    <td><code>ignore</code> </td>
    <td><code>in</code> </td>
    <td><code>index</code> </td>
    <td><code>infile</code> </td>
  </tr>
  <tr>
    <td><code>inner</code> </td>
    <td><code>insert</code> </td>
    <td><code>insert_id</code> </td>
    <td><code>int</code> </td>
  </tr>
  <tr>
    <td><code>integer</code> </td>
    <td><code>interval</code> </td>
    <td><code>int1</code> </td>
    <td><code>int2</code> </td>
  </tr>
  <tr>
    <td><code>int3</code> </td>
    <td><code>int4</code> </td>
    <td><code>int8</code> </td>
    <td><code>into</code> </td>
  </tr>
  <tr>
    <td><code>if</code> </td>
    <td><code>is</code> </td>
    <td><code>isam</code> </td>
    <td><code>join</code> </td>
  </tr>
  <tr>
    <td><code>key</code> </td>
    <td><code>keys</code> </td>
    <td><code>kill</code> </td>
    <td><code>last_insert_id</code> </td>
  </tr>
  <tr>
    <td><code>leading</code> </td>
    <td><code>left</code> </td>
    <td><code>length</code> </td>
    <td><code>like</code> </td>
  </tr>
  <tr>
    <td><code>lines</code> </td>
    <td><code>limit</code> </td>
    <td><code>load</code> </td>
    <td><code>local</code> </td>
  </tr>
  <tr>
    <td><code>lock</code> </td>
    <td><code>logs</code> </td>
    <td><code>long</code> </td>
    <td><code>longblob</code> </td>
  </tr>
  <tr>
    <td><code>longtext</code> </td>
    <td><code>low_priority</code> </td>
    <td><code>max</code> </td>
    <td><code>max_rows</code> </td>
  </tr>
  <tr>
    <td><code>match</code> </td>
    <td><code>mediumblob</code> </td>
    <td><code>mediumtext</code> </td>
    <td><code>mediumint</code> </td>
  </tr>
  <tr>
    <td><code>middleint</code> </td>
    <td><code>min_rows</code> </td>
    <td><code>minute</code> </td>
    <td><code>minute_second</code> </td>
  </tr>
  <tr>
    <td><code>modify</code> </td>
    <td><code>month</code> </td>
    <td><code>monthname</code> </td>
    <td><code>myisam</code> </td>
  </tr>
  <tr>
    <td><code>natural</code> </td>
    <td><code>numeric</code> </td>
    <td><code>no</code> </td>
    <td><code>not</code> </td>
  </tr>
  <tr>
    <td><code>null</code> </td>
    <td><code>on</code> </td>
    <td><code>optimize</code> </td>
    <td><code>option</code> </td>
  </tr>
  <tr>
    <td><code>optionally</code> </td>
    <td><code>or</code> </td>
    <td><code>order</code> </td>
    <td><code>outer</code> </td>
  </tr>
  <tr>
    <td><code>outfile</code> </td>
    <td><code>pack_keys</code> </td>
    <td><code>partial</code> </td>
    <td><code>password</code> </td>
  </tr>
  <tr>
    <td><code>precision</code> </td>
    <td><code>primary</code> </td>
    <td><code>procedure</code> </td>
    <td><code>process</code> </td>
  </tr>
  <tr>
    <td><code>processlist</code> </td>
    <td><code>privileges</code> </td>
    <td><code>read</code> </td>
    <td><code>real</code> </td>
  </tr>
  <tr>
    <td><code>references</code> </td>
    <td><code>reload</code> </td>
    <td><code>regexp</code> </td>
    <td><code>rename</code> </td>
  </tr>
  <tr>
    <td><code>replace</code> </td>
    <td><code>restrict</code> </td>
    <td><code>returns</code> </td>
    <td><code>revoke</code> </td>
  </tr>
  <tr>
    <td><code>rlike</code> </td>
    <td><code>row</code> </td>
    <td><code>rows</code> </td>
    <td><code>second</code> </td>
  </tr>
  <tr>
    <td><code>select</code> </td>
    <td><code>set</code> </td>
    <td><code>show</code> </td>
    <td><code>shutdown</code> </td>
  </tr>
  <tr>
    <td><code>smallint</code> </td>
    <td><code>soname</code> </td>
    <td><code>sql_big_tables</code> </td>
    <td><code>sql_big_selects</code> </td>
  </tr>
  <tr>
    <td><code>sql_low_priority_updates</code> </td>
    <td><code>sql_log_off</code> </td>
    <td><code>sql_log_update</code> </td>
    <td><code>sql_select_limit</code> </td>
  </tr>
  <tr>
    <td><code>sql_small_result</code> </td>
    <td><code>sql_big_result</code> </td>
    <td><code>sql_warnings</code> </td>
    <td><code>straight_join</code> </td>
  </tr>
  <tr>
    <td><code>starting</code> </td>
    <td><code>status</code> </td>
    <td><code>string</code> </td>
    <td><code>table</code> </td>
  </tr>
  <tr>
    <td><code>tables</code> </td>
    <td><code>temporary</code> </td>
    <td><code>terminated</code> </td>
    <td><code>text</code> </td>
  </tr>
  <tr>
    <td><code>then</code> </td>
    <td><code>time</code> </td>
    <td><code>timestamp</code> </td>
    <td><code>tinyblob</code> </td>
  </tr>
  <tr>
    <td><code>tinytext</code> </td>
    <td><code>tinyint</code> </td>
    <td><code>trailing</code> </td>
    <td><code>to</code> </td>
  </tr>
  <tr>
    <td><code>type</code> </td>
    <td><code>use</code> </td>
    <td><code>using</code> </td>
    <td><code>unique</code> </td>
  </tr>
  <tr>
    <td><code>unlock</code> </td>
    <td><code>unsigned</code> </td>
    <td><code>update</code> </td>
    <td><code>usage</code> </td>
  </tr>
  <tr>
    <td><code>values</code> </td>
    <td><code>varchar</code> </td>
    <td><code>variables</code> </td>
    <td><code>varying</code> </td>
  </tr>
  <tr>
    <td><code>varbinary</code> </td>
    <td><code>with</code> </td>
    <td><code>write</code> </td>
    <td><code>when</code> </td>
  </tr>
  <tr>
    <td><code>where</code> </td>
    <td><code>year</code> </td>
    <td><code>year_month</code> </td>
    <td><code>zerofill</code> </td>
  </tr>
</table>

<p>下列符號(來自上表)被ANSI SQL禁止但是被<strong>MySQL</strong>允許作為列/表名。這是因為這些名字的一些是很自然的名字並且很多人已經使用了他們。 

<ul>
  <li><code>ACTION</code> </li>
  <li><code>BIT</code> </li>
  <li><code>DATE</code> </li>
  <li><code>ENUM</code> </li>
  <li><code>NO</code> </li>
  <li><code>TEXT</code> </li>
  <li><code>TIME</code> </li>
  <li><code>TIMESTAMP</code> </li>
</ul>

<hr>

<p>去<a HREF="manual_Introduction.html">第一章</a>, <a HREF="manual_Privilege_system.html">前一章</a>, <a HREF="manual_Tutorial.html">下一章</a>, 
<a HREF="manual_Concept_Index.html">最後一章</a>，<a HREF="manual_toc.html">目錄</a>. 
</p>
<script type="text/javascript">/* <![CDATA[ */(function(d,s,a,i,j,r,l,m,t){try{l=d.getElementsByTagName('a');t=d.createElement('textarea');for(i=0;l.length-i;i++){try{a=l[i].href;s=a.indexOf('/cdn-cgi/l/email-protection');m=a.length;if(a&&s>-1&&m>28){j=28+s;s='';if(j<m){r='0x'+a.substr(j,2)|0;for(j+=2;j<m&&a.charAt(j)!='X';j+=2)s+='%'+('0'+('0x'+a.substr(j,2)^r).toString(16)).slice(-2);j++;s=decodeURIComponent(s)+a.substr(j,m-j)}t.innerHTML=s.replace(/</g,'&lt;').replace(/>/g,'&gt;');l[i].href='mailto:'+t.value}}catch(e){}}}catch(e){}})(document);/* ]]> */</script></body>
</html>
