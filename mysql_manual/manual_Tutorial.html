<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=big5">
<title>MySQL 中文參考手冊- 8 MySQL 教學課程</title>
<script type="text/javascript">
//<![CDATA[
try{if (!window.CloudFlare) {var CloudFlare=[{verbose:0,p:0,byc:0,owlid:"cf",bag2:1,mirage2:0,oracle:0,paths:{cloudflare:"/cdn-cgi/nexp/dok3v=1613a3a185/"},atok:"2db29842af5756bf509b2c75a2721481",petok:"ad0d0694aca2b059c76965f910843fba5f417218-1479574767-1800",zone:"twpug.net",rocket:"0",apps:{"ga_key":{"ua":"UA-11633811-1","ga_bs":"2"}}}];!function(a,b){a=document.createElement("script"),b=document.getElementsByTagName("script")[0],a.async=!0,a.src="//ajax.cloudflare.com/cdn-cgi/nexp/dok3v=088620b277/cloudflare.min.js",b.parentNode.insertBefore(a,b)}()}}catch(e){};
//]]>
</script>
<style type="text/css">
<!--
.p3{font-size:14.8px;font-family:宋體;}
.p14{font-size:14.8px;font-family:宋體;line-height:14pt;}
.bc{ background-color: rgb(255,255,132) ;font-size:9pt;font-family:宋體;line-height:14pt;}
.pt{font-size:14.8px;font-family:宋體;line-height:14pt; background-color: rgb(255,255,132) }
a:hover{color:red;}
a.t1:visited{color:red;}
-->
</style>
<script type="text/javascript">
/* <![CDATA[ */
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-11633811-1']);
_gaq.push(['_trackPageview']);

(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

(function(b){(function(a){"__CF"in b&&"DJS"in b.__CF?b.__CF.DJS.push(a):"addEventListener"in b?b.addEventListener("load",a,!1):b.attachEvent("onload",a)})(function(){"FB"in b&&"Event"in FB&&"subscribe"in FB.Event&&(FB.Event.subscribe("edge.create",function(a){_gaq.push(["_trackSocial","facebook","like",a])}),FB.Event.subscribe("edge.remove",function(a){_gaq.push(["_trackSocial","facebook","unlike",a])}),FB.Event.subscribe("message.send",function(a){_gaq.push(["_trackSocial","facebook","send",a])}));"twttr"in b&&"events"in twttr&&"bind"in twttr.events&&twttr.events.bind("tweet",function(a){if(a){var b;if(a.target&&a.target.nodeName=="IFRAME")a:{if(a=a.target.src){a=a.split("#")[0].match(/[^?=&]+=([^&]*)?/g);b=0;for(var c;c=a[b];++b)if(c.indexOf("url")===0){b=unescape(c.split("=")[1]);break a}}b=void 0}_gaq.push(["_trackSocial","twitter","tweet",b])}})})})(window);
/* ]]> */
</script>
</head>

<body BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#101090" VLINK="#7030B0" class="p4">

<h1><img src="Img/mysql-logo.gif" alt="mysql-logo.gif (3082 bytes)" WIDTH="127" HEIGHT="60"><font color="#FF0000">MySQL中文參考手冊</font></h1>

<p>譯者：晏子 <a href="/cdn-cgi/l/email-protection#aa82c9c6d3cbc4ead9c5c2df84c9c5c7">(<span class="__cf_email__" data-cfemail="7a1916031b143a0915120f54191517">[email&#160;protected]</span><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></a>）<br>
GB 碼主頁：<a href="http://linuxdb.yeah.net">http://linuxdb.yeah.net</a></p>

<p>Big5 轉碼者：statue <a href="/cdn-cgi/l/email-protection#631017021716064d010110230101104d1a19164d0607164d1714">
(<span class="__cf_email__" data-cfemail="b5c6c1d4c1c0d0f5d7d7c69bcccfc09bd0d1c09bc1c2">[email&#160;protected]</span><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></a>） <br>
詞彙轉換：彭武興 (<a href="/cdn-cgi/l/email-protection#34435d58475b5a7459555d58565b4c1a575b591a4043"><span class="__cf_email__" data-cfemail="0f7866637c60614f626e66636d6077216c6062217b78">[email&#160;protected]</span><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script></a>)<br>
Big5 碼主頁：
<a href="http://cnpa.yzu.edu.tw/~cfc/docs/mysqldoc_big5/manual_toc.html">
http://cnpa.yzu.edu.tw/~cfc/docs/mysqldoc_big5/manual_toc.html</a><br>
Big5 碼分站：
<a href="http://php.wilson.gs/mysqldoc/big5/manual_toc.html">
http://php.wilson.gs/mysqldoc/big5/manual_toc.html
</p>

<hr>

<p><a HREF="manual_Introduction.html">第一章</a>, <a HREF="manual_Reference.html">前一章</a>, 
<a HREF="manual_Server.html">下一章</a>, <a HREF="manual_Concept_Index.html">最後一章</a>，<a HREF="manual_toc.html">目錄</a>. </p>

<hr>

<h1><a NAME="Tutorial" HREF="manual_toc.html#Tutorial">8 MySQL教學課程</a></h1>

<p>本章通過演示如何使用<code>mysql</code>客戶程式創造和使用一個簡單的資料庫，提供一個<strong>MySQL</strong>的入門教學課程。<code>mysql</code>（有時稱為“終端監視器”或只是“監視”)是一個交互式程式，允許你連接一個<strong>MySQL</strong>伺服器，運行查詢並察看結果。<code>mysql</code>可以用於批模式：你預先把查詢放在一個文件中，然後告訴<code>mysql</code>執行文件的內容。使用<code>mysql</code>的兩個方法都在這裡涉及。 
</p>

<p>為了看清由<code>mysql</code>提供的一個選擇項目表了，用<code>--help</code>選項調用它： 
</p>

<pre>shell&gt; mysql --help
</pre>

<p>本章假定<code>mysql</code>已經被安裝在你的機器上，並且有一個<strong>MySQL</strong>伺服器你可以連接。如果這不是真的，聯絡你的<strong>MySQL</strong>管理員。（如果<em>你</em>是管理員，你將需要請教這本手冊的其他章節。）</p>

<p>本章描述建立和使用一個資料庫的全程序。如果你僅僅對存取一個已經存在資料庫感興趣，你可能想要跳過描述怎樣創建資料庫及它所包含的表的章節。 
</p>

<p>既然本章本質上是一個教學課程，許多細節有必要被省略。對於這裡所涉及的話題的更多資訊，咨詢本手冊的相關章節。 
</p>

<h2><a NAME="Connecting-disconnecting" HREF="manual_toc.html#Connecting-disconnecting">8.1 
連接與斷開服務者</a></h2>

<p>為了連接伺服器，當你調用<code>mysql</code>時，你通常將需要提供一個<strong>MySQL</strong>用戶名和很可能，一個密碼。如果伺服器運行在不是你登錄的一台機器上，你也將需要指定主機名。聯繫你的管理員以找出你應該使用什麼連接參數進行連接(即，那個主機，用戶名字和使用的密碼)。一旦你知道正確的參數，你應該能像這樣連接： 
</p>

<pre>shell&gt; mysql -h host -u user -p
Enter password: ********
</pre>

<p><code>********</code>代表你的密碼﹔當<code>mysql</code>顯示<code>Enter 
password:</code>提示時輸入它。 </p>

<p>如果能工作，你應該看見<code>mysql&gt;</code>提示後的一些介紹資訊： 
</p>

<pre>shell&gt; mysql -h host -u user -p
Enter password: ********
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 459 to server version: 3.22.20a-log

Type 'help' for help.

mysql&gt; 
</pre>

<p>提示符告訴你<code>mysql</code>準備為你輸入命令。 </p>

<p>一些<strong>MySQL</strong>安裝允許用戶以“anoymous”(匿名)用戶連接在本地主機上運行的伺服器。如果在你的機器是這種情況，你應該能通過沒有任何選項地調用<code>mysql</code>與該伺服器連接： 
</p>

<pre>shell&gt; mysql 
</pre>

<pre>在你成功地連接後，你可以在<code>mysql&gt;</code>提示下打入<code>QUIT</code>隨時斷開： </pre>

<pre>mysql&gt; QUIT
Bye
</pre>

<p>你也可以鍵入control-D斷開。 </p>

<p>在下列章節的大多數例子都假設你連接到伺服器。由<code>mysql&gt;</code>提示指明他們。 
</p>

<h2><a NAME="Entering_queries" HREF="manual_toc.html#Entering_queries">8.2 輸入查詢</a></h2>

<p>確保你連接上了伺服器，如在先前的章節討論的。這樣做本身將不選擇任何資料庫來工作，但是那很好。從這點講，知道關於如何出詢問的一點知識，比馬上跳至創建表、給他們裝載數據並且從他們檢索數據要來的重要寫。本節描述輸入命令的基本原則，使用幾個查詢，你能嘗試讓自己<code>mysql</code>是如何工作的。 
</p>

<p>這是一個簡單的命令，要求伺服器告訴你它的版本號和當前日期。在<code>mysql&gt;</code>提示打入如下命令並按回車鍵： 
</p>

<pre>mysql&gt; SELECT VERSION(), CURRENT_DATE;
+--------------+--------------+
| version()    | CURRENT_DATE |
+--------------+--------------+
| 3.22.20a-log | 1999-03-19   |
+--------------+--------------+
1 row in set (0.01 sec)
mysql&gt;
</pre>

<p>這詢問說明關於<code>mysql</code>幾件事: 

<ul>
  <li>一個命令通常由SQL語句組成，隨後有一個分號。（有一些例外不需要一個分號。早先提到的<code>QUIT</code>是他們之一。我們將以後看到其它。）</li>
  <li>當你發出一個命令時，<code>mysql</code>發送它給伺服器並顯示結果，然後打出另外一個<code>mysql&gt;</code>顯示它準備好接受另外的命令。 
  </li>
  <li><code>mysql</code>以一張表格(行和列)顯示查詢輸出。第一行包含列的標簽，隨後的行是詢問結果。通常， 
    列標簽是你取自資料庫表的列的名字。如果你正在檢索一個表達式而非表列的值(如剛才的例子)，<code>mysql</code>用表達式本身標記列。 
  </li>
  <li><code>mysql</code>顯示多少行被返回，和查詢花了多長執行，它給你提供伺服器性能的一個大致概念。因為他們表示時鐘時間(不是 
    CPU 或機器時間)，並且因為他們受到諸如伺服器負載和網路延時的影響，因此這些值是不精確的。（為了簡潔，在本章剩下的例子中不再顯示“集合中的行”。）</li>
</ul>

<p>關鍵詞可以以任何大小寫字符被輸入。下列詢問是等價的： </p>

<pre>mysql&gt; SELECT VERSION(), CURRENT_DATE;
mysql&gt; select version(), current_date;
mysql&gt; SeLeCt vErSiOn(), current_DATE;
</pre>

<pre>這裡有另外一個查詢，它說明你能將<code>mysql</code>用作一個簡單的計算器： </pre>

<pre>mysql&gt; SELECT SIN(PI()/4), (4+1)*5;
+-------------+---------+
| SIN(PI()/4) | (4+1)*5 |
+-------------+---------+
|    0.707107 |      25 |
+-------------+---------+
</pre>

<p>至今顯示的命令是相當短的，單行語句。你甚至能在單行上輸入多條語句，只是以一個分號結束每一條： 
</p>

<pre>mysql&gt; SELECT VERSION(); SELECT NOW();
+--------------+
| version()    |
+--------------+
| 3.22.20a-log |
+--------------+

+---------------------+
| NOW()               |
+---------------------+
| 1999-03-19 00:15:33 |
+---------------------+
</pre>

<p>一個命令不必全在一個單獨行給出，所以需要多行的較長命令不是一個問題。<code>mysql</code>通過尋找終止的分號而不是尋找輸入行的結束來決定你的語句在哪兒結束。（換句話說，<code>mysql</code>接受自由格式輸入：它收集輸入行但執行他們直到它看見分號。）</p>

<p>這裡是一個簡單的多行語句的例子： </p>

<pre>mysql&gt; SELECT
    -&gt; USER()
    -&gt; ,
    -&gt; CURRENT_DATE;
+--------------------+--------------+
| USER()             | CURRENT_DATE |
+--------------------+--------------+
| <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="1973767c6a74706d715975767a787571766a6d">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script> | 1999-03-18   |
+--------------------+--------------+</pre>

<p>在這個例子中，在你輸入一個多行查詢的第一行後，要注意提示符如何從<code>mysql&gt;</code>變為<code>-&gt;</code>，這正是<code>mysql</code>如何指出它沒見到完整的語句並且正在等待剩餘的部分。提示符是你的朋友，因為它提供有價值的反饋，如果你使用該反饋，你將總是知道<code>mysql</code>正在等待什麼。 
</p>

<p>如果你決定，你不想要執行你在輸入程序中輸入的一個命令，打入<code>\c</code>取消它： 
</p>

<pre>mysql&gt; SELECT
    -&gt; USER()
    -&gt; \c
mysql&gt;
</pre>

<p>這裡也要注意提示符，在你打入<code>\c</code>以後，它切換回到<code>mysql&gt;</code>，提供反饋以表明<code>mysql</code>準備接受一個新命令。 
</p>

<p>下表顯示出你可以看見的各個提示符並總結他們意味著<code>mysql</code>在什麼狀態下： 
</p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" class="p4">
  <tr>
    <td><strong>提示符</strong></td>
    <td><strong>意思</strong> </td>
  </tr>
  <tr>
    <td><code>mysql&gt;</code> </td>
    <td>準備好接受新命令</td>
  </tr>
  <tr>
    <td><code>-&gt;</code> </td>
    <td>等待多行命令的下一行</td>
  </tr>
  <tr>
    <td><code>'&gt;</code> </td>
    <td>等待下一行，收集以單引號(“'”)開始的字符串 </td>
  </tr>
  <tr>
    <td><code>&quot;&gt;</code> </td>
    <td>等待下一行，收集以雙引號(“&quot;”)開始的字符串</td>
  </tr>
</table>

<p>當你打算在一個單行上發出一個命令時，多行語句通常“偶然”出現，但是忘記終止的分號。在這種情況中，<code>mysql</code>等待進一步輸入： 
</p>

<pre>mysql&gt; SELECT USER()
    -&gt;
</pre>

<p>如果這發生在你身上(你認為你輸完了語句但是唯一的反應是一個<code>-&gt;</code>提示符)，很可能<code>mysql</code>正在等待分號。如果你沒有注意到提示符正在告訴你什麼，在認識到你需要做什麼之前，你可能花一會兒時間呆坐在那兒。進入一個分號完成語句，並且<code>mysql</code>將執行它： 
</p>

<pre>mysql&gt; SELECT USER()
    -&gt; ;
+--------------------+
| USER()             |
+--------------------+
| <a class="__cf_email__" href="/cdn-cgi/l/email-protection" data-cfemail="670d0802140a0e130f270b0804060b0f081413">[email&#160;protected]</a><script data-cfhash='f9e31' type="text/javascript">/* <![CDATA[ */!function(t,e,r,n,c,a,p){try{t=document.currentScript||function(){for(t=document.getElementsByTagName('script'),e=t.length;e--;)if(t[e].getAttribute('data-cfhash'))return t[e]}();if(t&&(c=t.previousSibling)){p=t.parentNode;if(a=c.getAttribute('data-cfemail')){for(e='',r='0x'+a.substr(0,2)|0,n=2;a.length-n;n+=2)e+='%'+('0'+('0x'+a.substr(n,2)^r).toString(16)).slice(-2);p.replaceChild(document.createTextNode(decodeURIComponent(e)),c)}p.removeChild(t)}}catch(u){}}()/* ]]> */</script> |
+--------------------+
</pre>

<p><code>'&gt;</code>和<code>&quot;&gt;</code>提示符出現在在字符串收集期間。在<strong>MySQL</strong>中，你可以寫由<samp>“'”</samp>或<samp>“&quot;”字符括起來的</samp>字符串 
(例如，<code>'hello'</code>或<code>&quot;goodbye&quot;</code>)，並且<code>mysql</code>讓你進入跨越多行的字符串。當你看到一個<code>'&gt;</code>或<code>&quot;&gt;</code>提示符時，這意味著你已經輸入了包含以<samp>“'”</samp>或<samp>“&quot;”</samp>括號字符開始的字符串的一行，但是還沒有輸入終止字符串的匹配引號。如果你確實正在輸入一個多行字符串，很好，但是果真如此嗎？不盡然。更常見的，<code>'&gt;</code>和<code>&quot;&gt;</code>提示符顯示你粗心地省掉了一個引號字符。例如： 
</p>

<pre>mysql&gt; SELECT * FROM my_table WHERE name = &quot;Smith AND age &lt; 30;
    &quot;&gt;
</pre>

<pre>如果你輸入該<code>SELECT</code>語句，然後按回車鍵並等待結果，什麼都沒有出現。不要驚訝，“為什麼該查詢這麼長呢？”，注意<code>&quot;&gt;</code>提示符提供的線索。它告訴你<code>mysql</code>期望見到一個未終止字符串的餘下部分。（你在語句中看見錯誤嗎？字符串<code>&quot;Smith</code>正好丟失第二個引號。）</pre>

<p>走到這一步，你該做什麼？最簡單的是取消命令。然而，在這種情況下，你不能只是打入<code>\c</code>，因為<code>mysql</code>作為它正在收集的字符串的一部分來解釋它！相反，輸入關閉的引號字符(這樣<code>mysql</code>知道你完成了字符串)，然後打入<code>\c</code>：</p>

<pre>mysql&gt; SELECT * FROM my_table WHERE name = &quot;Smith AND age &lt; 30;
    &quot;&gt; &quot;\c
mysql&gt;
</pre>

<p>提示符回到<code>mysql&gt;</code>，顯示<code>mysql</code>準備好接受一個新命令了。 
</p>

<p>知道<code>'&gt;</code>和<code>&quot;&gt;</code>提示符意味著什麼是很重要的，因為如果你錯誤地輸入一個未終止的字符串，任何比你下一步輸入的行好像將要被<code>mysql</code>忽略--包括包含<code>QUIT</code>的行！這可能相當含糊，特別是在你能取消當前命令前，如果你不知道你需要提出終止引號。 
</p>

<h2><a NAME="Examples" HREF="manual_toc.html#Examples">8.3 常用查詢的例子</a></h2>

<p>下面是一些學習如何用<strong>MySQL</strong>解決一些常見問題的例子。</p>

<p>一些例子使用資料庫表“shop”，包含某個商人的每篇文章(物品號)的價格。假定每個商人的每篇文章有一個單獨的固定價格，那麼(物品，商人)是記錄的主鍵。 
</p>

<p>你能這樣創建例子資料庫表： </p>

<pre>CREATE TABLE shop (
 article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
 dealer  CHAR(20)                 DEFAULT ''     NOT NULL,
 price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL,
 PRIMARY KEY(article, dealer));

INSERT INTO shop VALUES
(1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),(3,'C',1.69),
(3,'D',1.25),(4,'D',19.95);
</pre>

<p>好了，例子數據是這樣的： </p>

<pre>SELECT * FROM shop

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | A      |  3.45 |
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | B      |  1.45 |
|    0003 | C      |  1.69 |
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</pre>

<h3><a NAME="example-Maximum-column" HREF="manual_toc.html#example-Maximum-column">8.3.1 
列的最大值</a></h3>

<p>“最大的物品號是什麼？” </p>

<pre>SELECT MAX(article) AS article FROM shop

+---------+
| article |
+---------+
|       4 |
+---------+
</pre>

<h3><a NAME="example-Maximum-row" HREF="manual_toc.html#example-Maximum-row">8.3.2 
擁有某個列的最大值的行</a></h3>

<p>“找出最貴的文章的編號、商人和價格”</p>

<p>在ANSI-SQL中這很容易用一個子查詢做到： </p>

<pre>SELECT article, dealer, price
FROM   shop
WHERE  price=(SELECT MAX(price) FROM shop)
</pre>

<p>在<strong>MySQL</strong>中（還沒有子查詢)就用2步做到： 

<ol>
  <li>用一個<code>SELECT</code>語句從表中得到最大值。 </li>
  <li>使用該值編出實際的查詢： <pre>SELECT article, dealer, price
FROM   shop
WHERE  price=19.95
</pre>
  </li>
</ol>

<p>另一個解決方案是按價格降序排序所有行並用<strong>MySQL</strong>特定<code>LIMIT</code>子句只得到的第一行： 
</p>

<pre>SELECT article, dealer, price
FROM   shop
ORDER BY price DESC
LIMIT 1
</pre>

<p><strong>注意</strong>:如果有多個最貴的文章( 例如每個19.95)<code>，LIMIT</code>解決方案僅僅顯示他們之一！ 
</p>

<h3><a NAME="example-Maximum-column-group" HREF="manual_toc.html#example-Maximum-column-group">8.3.3 
列的最大值：按組：只有值</a></h3>

<p>“每篇文章的最高的價格是什麼？” </p>

<pre>SELECT article, MAX(price) AS price
FROM   shop
GROUP BY article

+---------+-------+
| article | price |
+---------+-------+
|    0001 |  3.99 |
|    0002 | 10.99 |
|    0003 |  1.69 |
|    0004 | 19.95 |
+---------+-------+
</pre>

<h3><a NAME="example-Maximum-column-group-row" HREF="manual_toc.html#example-Maximum-column-group-row">8.3.4 
擁有某個字段的組間最大值的行</a></h3>

<p>“對每篇文章，找出有最貴的價格的交易者。” </p>

<p>在<code>ANSI SQL</code>中，我可以用這樣一個子查詢做到： </p>

<pre>SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article)
</pre>

<p>在<strong>MySQL</strong>中，最好是分幾步做到： 

<ol>
  <li>得到一個表(文章，maxprice)。見<a HREF="manual_Tutorial.html#example-Maximum-column-group-row">8.3.4 
    擁有某個域的組間最大值的行</a>。 </li>
  <li>對每篇文章，得到對應於儲存最大價格的行。 </li>
</ol>

<p>這可以很容易用一個臨時表做到： </p>

<pre>CREATE TEMPORARY TABLE tmp (
        article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
        price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL);

LOCK TABLES article read;

INSERT INTO tmp SELECT article, MAX(price) FROM shop GROUP BY article;

SELECT article, dealer, price FROM shop, tmp
WHERE shop.article=tmp.articel AND shop.price=tmp.price;

UNLOCK TABLES;

DROP TABLE tmp;
</pre>

<p>如果你不使用一個<code>TEMPORARY</code>表，你也必須鎖定“tmp”表。 </p>

<p>“它能一個單個查詢做到嗎？” </p>

<p>是的，但是只有使用我稱之為“MAX-CONCAT詭計”的一個相當低效的詭計： 
</p>

<pre>SELECT article,
       SUBSTRING( MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 7) AS dealer,
  0.00+LEFT(      MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 6) AS price
FROM   shop
GROUP BY article;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | C      |  1.69 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</pre>

<p>最後例子當然能通過在客戶程式中分割連結的列使它更有效一點。 
</p>

<h3><a NAME="example-Foreign_keys" HREF="manual_toc.html#example-Foreign_keys">8.3.5 
使用外鍵</a></h3>

<p>不需要外鍵聯結2個表。 </p>

<p><code>MySQL</code>唯一不做的事情是<code>CHECK</code>以保証你使用的鍵確實在你正在引用表中存在，並且它不自動從有一個外鍵定義的表中刪除行。如果你像平常那樣使用你的鍵值，它將工作得很好！ 
</p>

<pre>CREATE TABLE persons (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT, 
    name CHAR(60) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE shirts (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL REFERENCES persons,
    PRIMARY KEY (id)
);

INSERT INTO persons VALUES (NULL, 'Antonio Paz');

INSERT INTO shirts VALUES
(NULL, 'polo', 'blue', LAST_INSERT_ID()),
(NULL, 'dress', 'white', LAST_INSERT_ID()),
(NULL, 't-shirt', 'blue', LAST_INSERT_ID());

INSERT INTO persons VALUES (NULL, 'Lilliana Angelovska');

INSERT INTO shirts VALUES
(NULL, 'dress', 'orange', LAST_INSERT_ID()),
(NULL, 'polo', 'red', LAST_INSERT_ID()),
(NULL, 'dress', 'blue', LAST_INSERT_ID()),
(NULL, 't-shirt', 'white', LAST_INSERT_ID());

SELECT * FROM persons;
+----+---------------------+
| id | name                |
+----+---------------------+
|  1 | Antonio Paz         |
|  2 | Lilliana Angelovska |
+----+---------------------+

SELECT * FROM shirts;
+----+---------+--------+-------+
| id | style   | color  | owner |
+----+---------+--------+-------+
|  1 | polo    | blue   |     1 |
|  2 | dress   | white  |     1 |
|  3 | t-shirt | blue   |     1 |
|  4 | dress   | orange |     2 |
|  5 | polo    | red    |     2 |
|  6 | dress   | blue   |     2 |
|  7 | t-shirt | white  |     2 |
+----+---------+--------+-------+

SELECT s.* FROM persons p, shirts s
 WHERE p.name LIKE 'Lilliana%'
   AND s.owner = p.id
   AND s.color &amp;lt;&amp;gt; 'white';

+----+-------+--------+-------+
| id | style | color  | owner |
+----+-------+--------+-------+
|  4 | dress | orange |     2 |
|  5 | polo  | red    |     2 |
|  6 | dress | blue   |     2 |
+----+-------+--------+-------+
</pre>

<h2><a NAME="Database_use" HREF="manual_toc.html#Database_use">8.4 
創造並使用一個資料庫</a></h2>

<p>既然你知道怎樣輸入命令，現在是存取一個資料庫的時候了。 </p>

<p>假定在你的家(你的“動物園”)中有很多寵物，並且你想追蹤關於他們各種各樣類型的資訊。你可以通過創建表來保存你的數據並根據所需要的資訊裝載他們做到，然後你可以通過從表中檢索數據來回答關於你的動物不同種類的問題。本節顯示如何做到所有這些事情： 

<ul>
  <li>怎樣創建一個資料庫</li>
  <li>怎樣創建一個資料庫表</li>
  <li>怎樣裝載數據到資料庫表</li>
  <li>怎樣以各種方法從表中檢索數據</li>
  <li>怎樣使用多個表</li>
</ul>

<p>動物園資料庫將會是簡單的(故意的)，但是不難把它想像成可能用到相似類型資料庫的真實世界情況。例如，這樣的一個資料庫能被一個農夫用來追蹤家畜，或由一個獸醫追蹤病畜記錄。 
</p>

<p>使用<code>SHOW</code>語句找出在伺服器上當前存在什麼資料庫： </p>

<pre>mysql&gt; SHOW DATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
</pre>

<p>資料庫列表可能在你的機器上是不同的，但是<code>mysql</code>和<code>test</code>資料庫很可能的在其間。<code>mysql</code>是必需的，因為它描述用戶存取權限，<code>test</code>資料庫經常作為一個工作區提供給用戶試試身手。 
</p>

<p>如果<code>test</code>資料庫存在，嘗試存取它： </p>

<pre>mysql&gt; USE test
Database changed
</pre>

<p>注意，<code>USE</code>，類似<code>QUIT</code>，不需要一個分號。（如果你喜歡，你可以用一個分號終止這樣的語句﹔這無礙)<code>USE</code>語句在使用上也有另外一個特殊的地方：它必須在一個單行上給出。 
</p>

<p>你可列在後面的例子中使用<code>test</code>資料庫(如果你能訪問它)，但是你在該資料庫創建的任何東西可以被與訪問它的其他人刪除，為了這個原因，你可能應該詢問你的<strong>MySQL</strong>管理員許可你自己使用的一個資料庫。假定你想要調用你的<code>menagerie</code>，管理員需要執行一個這樣的命令： 
</p>

<pre>mysql&gt; GRANT ALL ON menagerie.* TO your_mysql_name;
</pre>

<p>這裡<code>your_mysql_name</code>是分配給你的<strong>MySQL</strong>用戶名。 </p>

<h3><a NAME="Creating_database" HREF="manual_toc.html#Creating_database">8.4.1 
創建並選用一個資料庫</a></h3>

<p>如果在設置你的權限時，管理員為你創建了資料庫，你可以開始使用它。否則，你需要自己創建它： 
</p>

<pre>mysql&gt; CREATE DATABASE menagerie;
</pre>

<p>在Unix下，資料庫名字是區分大小寫的(不像SQL關鍵詞)，因此你必須總是以<code>menagerie</code>引用你的資料庫，不是<code>Menagerie</code>、<code>MENAGERIE</code>或一些其他變種。對表名也是這樣的。（在Windows下，該限制不適用，盡管你必須在一個給定的查詢中使用同樣的大小寫來引用資料庫和表。）</p>

<p>創建了一個資料庫並不選定以使用它，你必須明確地做這件事。為了使<code>menagerie</code>稱為當前的資料庫，使用這個命令： 
</p>

<pre>mysql&gt; USE menagerie
Database changed
</pre>

<p>你的資料庫只需要創建一次，但是你必須在每次啟動一個<code>mysql</code>會話時為使用而選擇它。你可以由發出上面一個<code>USE</code>語句做到。另外，當你調用時<code>mysql</code>，你可在命令行上選擇資料庫，就在你可能需要提供的任何連接參數之後指定其名字。例如： 
</p>

<pre>shell&gt; mysql -h host -u user -p menagerie
Enter password: ********
</pre>

<p>注意，<code>menagerie</code>不是你在剛才所示命令的密碼。如果你想要在命令行上在<code>-p</code>選項後提供你的密碼，你必須做到沒有多餘的空格(例如，如<code>-pmypassword</code>，不是<code>-p 
mypassword</code>)。然而，不建議把你的密碼放在命令行上，因為這樣做把它暴露出來，能被在你的機器上登錄的其他用戶窺探到。 
</p>

<h3><a NAME="Creating_tables" HREF="manual_toc.html#Creating_tables">8.4.2 
創建一個資料庫表</a></h3>

<p>創建資料庫是容易的部分，但是在這時它是空的，正如<code>SHOW 
TABLES</code>將告訴你： </p>

<pre>mysql&gt; SHOW TABLES;
Empty set (0.00 sec)
</pre>

<p>較難的部分是決定你的資料庫結構應該是什麼：你將需要什麼資料庫表，和在他們中有什麼樣的列。 
</p>

<p>你將需要一個包含你每個寵物的記錄的表。它可稱為<code>pet</code>表，並且它應該包含，最少，每個動物的名字。因為名字本身不是很有趣，表應該包含另外的資訊。例如，如果在你豢養寵物的家庭有超過一個人，你可能想要列出每個動物的主人。你可能也想要記錄例如種類和性別的一些基本的描述資訊。 
</p>

<p>年齡呢？那可能有趣，但是在一個資料庫中儲存不是一件好事情。年齡隨著時間流逝而變化，這意味著你將要不斷地更新你的記錄。相反, 
儲存一個固定值例如生日比較好，那麼，無論何時你需要年齡，你可以以當前日期和出生日期之間的差別來計算它。<strong>MySQL</strong>為日期運算提供了函數，因此這並不困難。儲存出生日期而非年齡也有其他優點： 

<ul>
  <li>你可以將資料庫用於這樣的任務例如產生即將到來的寵物生日的提示。（如果你認為這類查詢是點蠢，注意，這與在一個商務資料庫來標示你不久要給它發出生日祝賀的客戶的環境中是同一個問題，因為計算機幫助私人聯絡。）</li>
  <li>你可以相對於日期而不止是當前日期來計算年齡。例如，如果你在資料庫儲存死亡日期，你能容易計算一只寵物是何時多大死的。 
  </li>
</ul>

<p>你可能想到<code>pet</code>表中其他有用的其他類型資訊，但是到目前為止這些現在是足夠了：名字、主人、種類，性別、出生和死亡日期。 
</p>

<p>使用一個<code>CREATE TABLE</code>語句指定你的資料庫表的布局： </p>

<pre>mysql&gt; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
    -&gt; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
</pre>

<p><code>VARCHAR</code>對<code>name</code>、<code>owner</code>和<code>species</code>列是個好的選擇，因為列值將會是變長的。這些列的長度都不必是相同的，而且不必是<code>20</code>。你可以挑選從<code>1</code>到<code>255</code>的任何長度，無論哪個對你來說好像最合理。（如果你做了較差的選擇，以後會變得你需要一個更長的字段，<strong>MySQL</strong>提供一個<code>ALTER 
TABLE</code>語句。）</p>

<p>動物性表可以用許多方法表示，例如，<code>&quot;m&quot;</code>和<code>&quot;f&quot;</code>，或也許<code>&quot;male&quot;</code>和<code>&quot;female&quot;</code>。使用單個字符<code>&quot;m&quot;</code>和<code>&quot;f&quot;</code>是最簡單的。 
</p>

<p>為<code>birth</code>和<code>death</code>列使用<code>DATE</code>數據類型是相當明顯的選擇。 
</p>

<p>既然你創建了一個表，<code>SHOW TABLES</code>應該產生一些輸出： </p>

<pre>mysql&gt; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
</pre>

<p>為了驗証你的表是按你期望的方式被創建，使用一個<code>DESCRIBE</code>語句： 
</p>

<pre>mysql&gt; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</pre>

<p>你能隨時<code>DESCRIBE</code>，例如，如果你忘記在你表中的列的名字或他們是什麼類型。 
</p>

<h3><a NAME="Loading_tables" HREF="manual_toc.html#Loading_tables">8.4.3 
將數據裝入一個資料庫表</a></h3>

<p>在你創建表後，你需要充實它。<code>LOAD DATA</code>和<code>INSERT</code>語句用於此。 
</p>

<p>假定你的寵物紀錄描述如下。（觀察到<strong>MySQL</strong>期望日期時以<code>YYYY-MM-DD</code>格式﹔這可能與你習慣的不同。）</p>

<table border="1" width="100%" NOSAVE class="p4">
<tbody>
  <tr>
    <td><strong>name</strong> </td>
    <td><strong>owner</strong> </td>
    <td><strong>species</strong> </td>
    <td><strong>sex</strong> </td>
    <td><strong>birth</strong> </td>
    <td><strong>death</strong> </td>
  </tr>
  <tr>
    <td>Fluffy </td>
    <td>Harold </td>
    <td>cat </td>
    <td>f </td>
    <td>1993-02-04 </td>
    <td>　</td>
  </tr>
  <tr>
    <td>Claws </td>
    <td>Gwen </td>
    <td>cat </td>
    <td>m </td>
    <td>1994-03-17 </td>
    <td>　</td>
  </tr>
  <tr>
    <td>Buffy </td>
    <td>Harold </td>
    <td>dog </td>
    <td>f </td>
    <td>1989-05-13 </td>
    <td>　</td>
  </tr>
  <tr>
    <td>Fang </td>
    <td>Benny </td>
    <td>dog </td>
    <td>m </td>
    <td>1990-08-27 </td>
    <td>　</td>
  </tr>
  <tr>
    <td>Bowser </td>
    <td>Diane </td>
    <td>dog </td>
    <td>m </td>
    <td>1998-08-31 </td>
    <td>1995-07-29 </td>
  </tr>
  <tr>
    <td>Chirpy </td>
    <td>Gwen </td>
    <td>bird </td>
    <td>f </td>
    <td>1998-09-11 </td>
    <td>　</td>
  </tr>
  <tr>
    <td>Whistler </td>
    <td>Gwen </td>
    <td>bird </td>
    <td>　</td>
    <td>1997-12-09 </td>
    <td>　</td>
  </tr>
  <tr>
    <td>Slim </td>
    <td>Benny </td>
    <td>snake </td>
    <td>m </td>
    <td>1996-04-29 </td>
    <td>　</td>
  </tr>
</tbody>
</table>

<p>因為你是從一張空表開始的，充實它的一個容易方法是創建包含為你的動物各一行一個文本文件，然後用一個單個語句裝載文件的內容到表中。 
</p>

<p>你可以創建一個文本文件<tt>“pet.txt”</tt>，每行包含一個記錄，用定位符(tab)把值分開，並且以在<code>CREATE 
TABLE</code>語句中列出的列次序給出。對於丟失的值(例如未知的性別，或仍然活著的動物的死亡日期)，你可以使用<code>NULL</code>值。為了在你的文本文件表示這些，使用<code>\N</code>。例如，對Whistler鳥的記錄看起來像這樣的(這裡在值之間的空白是一個單個的定位字符)：</p>

<table border="1" width="100%" NOSAVE class="p4">
<tbody>
  <tr>
    <td><code>Whistler</code> </td>
    <td><code>Gwen</code> </td>
    <td><code>bird</code> </td>
    <td><code>\N</code> </td>
    <td><code>1997-12-09</code> </td>
    <td><code>\N</code> </td>
  </tr>
</tbody>
</table>

<p>為了裝載文本文件<tt>“pet.txt”</tt>到<code>pet</code>表中，使用這個命令： 
</p>

<pre>mysql&gt; LOAD DATA LOCAL INFILE &quot;pet.txt&quot; INTO TABLE pet;
</pre>

<p>如果你願意，你能明確地在<code>LOAD DATA</code>語句中指出列值的分隔符和行尾標記，但是預設是定位符和換行符。這些對爭取讀入文件<tt>“pet.txt”</tt>的語句是足夠的。 
</p>

<p>當你想要一次增加一個新記錄時，<code>INSERT</code>語句是有用的。在它最簡單的形式，你為每一列提供值，以列在<code>CREATE 
TABLE</code>語句被列出的順序。假定Diane把一只新倉鼠命名為Puffball，你可以使用一個這樣<code>INSERT</code>語句增加一條新記錄： 
</p>

<pre>mysql&gt; INSERT INTO pet
    -&gt; VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
</pre>

<p>注意，這裡字符串和日期值被指定為引號擴起來的字符串。另外，用<code>INSERT</code>，你能直接插入<code>NULL</code>代表不存在的值。你不能使用<code>\N</code>，就像你用<code>LOAD 
DATA</code>做的那樣。 </p>

<p>從這個例子，你應該能看到涉及很多的鍵入用多個<code>INSERT</code>語句而非單個<code>LOAD 
DATA</code>語句裝載你的初始記錄。 </p>

<h3><a NAME="Retrieving_data" HREF="manual_toc.html#Retrieving_data">8.4.4 
從一個資料庫表檢索資訊</a></h3>

<p><code>SELECT</code>語句被用來從一張桌子拉出資訊。語句的一般格式是： 
</p>

<pre>SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy
</pre>
<code>

<p>what_to_select</code>指出你想要看到的，這可以是列的一張表，或<code>*</code>表明“所有的列”。<code>which_table</code>指出你想要從其檢索數據的表。<code>WHERE</code>子句是可選的，如果它在，<code>conditions_to_satisfy</code>指定行必須滿足的檢索條件。 
</p>

<h4><a NAME="Selecting_all" HREF="manual_toc.html#Selecting_all">8.4.4.1 
選擇所有數據</a></h4>

<p><code>SELECT</code>最簡單的形式是從一張表中檢索每樣東西： </p>

<pre>mysql&gt; SELECT * FROM pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1998-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
</pre>

<p>如果你想要考察整個表，這種形式的<code>SELECT</code>是很有用的。例如，在你剛剛給它裝載了你的初始數據集裝以後。當它發生時，剛才顯示的輸出揭示了在你的數據文件的一個錯誤：在Bowser死了以後，它好像要出生了！請教你原來的家譜，你發現正確的出生年是1989，而不是1998。 
</p>

<p>至少有一些修正它的方法： 

<ul>
  <li>編輯文件<tt>“pet.txt”</tt>改正錯誤，然後使用<code>DELETE</code>和<code>LOAD 
    DATA</code>弄空表並且再次裝載它: <pre>mysql&gt; DELETE FROM pet;
mysql&gt; LOAD DATA LOCAL INFILE &quot;pet.txt&quot; INTO TABLE pet;
</pre>
    <p>然而, 如果你這樣做，你必須重新輸入Puffball記錄。 </p>
  </li>
  <li>用一個<code>UPDATE</code>語句僅修正錯誤記錄： <pre>mysql&gt; UPDATE pet SET birth = &quot;1989-08-31&quot; WHERE name = &quot;Bowser&quot;;
</pre>
  </li>
</ul>

<p>如上所示，檢索整個表是容易的，但是一般你不想那樣做，特別地當表變得很大時。相反，你通常對回答一個特別的問題更感興趣，在這種情況下你在你想要的資訊上指定一些限制。讓我們看一些他們回答有關你寵物的問題的選擇查詢。 
</p>

<h4><a NAME="Selecting_rows" HREF="manual_toc.html#Selecting_rows">8.4.4.2 選擇特定行</a></h4>

<p>你能從你的表刈荿選擇特定的行。例如，如果你想要驗証你對Bowser的出生日期所做的改變，像這樣選取Bowser的記錄： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE name = &quot;Bowser&quot;;
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
</pre>

<p>輸出証實年份現在正確記錄為1989，而不是1998。 </p>

<p>字符串比較通常是大小些無關的，因此你可以指定名字為<code>&quot;bowser&quot;</code>、&quot;BOWSER&quot;等等，查詢結果將是相同的。 
</p>

<p>你能在任何列上指定條件，不只是<code>name</code>。例如，如果你想要知道哪個動物在1998以後出生的，測試<code>birth</code>列： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE birth &gt;= &quot;1998-1-1&quot;;
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
</pre>

<p>你能組合條件，例如，找出雌性的狗： </p>

<pre>mysql&gt; SELECT * FROM pet WHERE species = &quot;dog&quot; AND sex = &quot;f&quot;;
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>

<p>上面的查詢使用<code>AND</code>邏輯操作符，也有一個<code>OR</code>操作符： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE species = &quot;snake&quot; OR species = &quot;bird&quot;;
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
</pre>

<p><code>AND</code>和<code>OR</code>可以混用。如果你這樣做，使用括號指明條件應該如何被分組是一個好主意： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE (species = &quot;cat&quot; AND sex = &quot;m&quot;)
    -&gt; OR (species = &quot;dog&quot; AND sex = &quot;f&quot;);
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>

<h4><a NAME="Selecting_columns" HREF="manual_toc.html#Selecting_columns">8.4.4.3 
選擇特定列</a></h4>

<p>如果你不想要看到你的表的整個行，就命名你感興趣的列，用逗號分開。例如，如果你想要知道你的動物什麼時候出生的，選取<code>name</code>和<code>birth</code>列： 
</p>

<pre>mysql&gt; SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
</pre>

<p>找出誰擁有寵物，使用這個查詢： </p>

<pre>mysql&gt; SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
</pre>

<p><a NAME="IDX602"></a>然而，注意到查詢簡單地檢索每個記錄的<code>owner</code>字段，並且他們中的一些出現多次。為了使輸出減到最少，通過增加關鍵詞<code>DISTINCT</code>檢索出每個唯一的輸出記錄： 
</p>

<pre>mysql&gt; SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
</pre>

<p>你能使用一個<code>WHERE</code>子句把行選擇與列選擇相結合。例如，為了只得到狗和貓的出生日期，使用這個查詢： 
</p>

<pre>mysql&gt; SELECT name, species, birth FROM pet
    -&gt; WHERE species = &quot;dog&quot; OR species = &quot;cat&quot;;
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+</pre>

<h4><a NAME="Sorting_rows" HREF="manual_toc.html#Sorting_rows">8.4.4.4 排序行</a></h4>

<p>你可能已經注意到前面的例子中結果行沒有以特定的次序被顯示。然而，當行以某個有意義的方式排序，檢驗查詢輸出通常是更容易的。為了排序結果，使用一個<code>ORDER 
BY</code>子句。 </p>

<p>這裡是動物生日，按日期排序： </p>

<pre>mysql&gt; SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
</pre>

<p>為了以逆序排序，增加<code>DESC</code>（下降 )關鍵字到你正在排序的列名上： 
</p>

<pre>mysql&gt; SELECT name, birth FROM pet ORDER BY birth DESC;
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
</pre>

<p>你能在多個列上排序。例如，按動物的種類排序，然後按生日，首先是動物種類中最年輕的動物，使用下列查詢： 
</p>

<pre>mysql&gt; SELECT name, species, birth FROM pet ORDER BY species, birth DESC;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Puffball | hamster | 1999-03-30 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+
</pre>

<p>注意<code>DESC</code>關鍵詞僅適用於緊跟在它之前的列名字(<code>birth</code>)﹔<code>species</code>值仍然以升序被排序。 
</p>

<h4><a NAME="Date_calculations" HREF="manual_toc.html#Date_calculations">8.4.4.5 
日期計算</a></h4>

<p><strong>MySQL</strong>提供幾個函數，你能用來執行在日期上的計算，例如，計算年齡或提取日期的部分。 
</p>

<p>為了決定你的每個寵物有多大，用出生日期和當前日期之間的差別計算年齡。通過變換2個日期到天數，取差值，並且用365除(在一年裡的天數)： 
</p>

<pre>mysql&gt; SELECT name, (TO_DAYS(NOW())-TO_DAYS(birth))/365 FROM pet;
+----------+-------------------------------------+
| name     | (TO_DAYS(NOW())-TO_DAYS(birth))/365 |
+----------+-------------------------------------+
| Fluffy   |                                6.15 |
| Claws    |                                5.04 |
| Buffy    |                                9.88 |
| Fang     |                                8.59 |
| Bowser   |                                9.58 |
| Chirpy   |                                0.55 |
| Whistler |                                1.30 |
| Slim     |                                2.92 |
| Puffball |                                0.00 |
+----------+-------------------------------------+
</pre>

<p>盡管查詢可行，關於它還有能被改進的一些事情。首先，如果行以某個次序表示，其結果能更容易被掃描。第二，年齡列的標題不是很有意義的。 
</p>

<p>第一個問題通過增加一個<code>ORDER BY name</code>子句按名字排序輸出來解決。為了處理列標題，為列提供一個名字以便一個不同的標簽出現在輸出中(這被稱為一個列別名)： 
</p>

<pre>mysql&gt; SELECT name, (TO_DAYS(NOW())-TO_DAYS(birth))/365 AS age
    -&gt; FROM pet ORDER BY name;
+----------+------+
| name     | age  |
+----------+------+
| Bowser   | 9.58 |
| Buffy    | 9.88 |
| Chirpy   | 0.55 |
| Claws    | 5.04 |
| Fang     | 8.59 |
| Fluffy   | 6.15 |
| Puffball | 0.00 |
| Slim     | 2.92 |
| Whistler | 1.30 |
+----------+------+
</pre>

<p>為了按<code>age</code>而非<code>name</code>排序輸出，只要使用一個不同<code>ORDER 
BY</code>子句： </p>

<pre>mysql&gt;  SELECT name, (TO_DAYS(NOW())-TO_DAYS(birth))/365 AS age
    -&gt;  FROM pet ORDER BY age;
+----------+------+
| name     | age  |
+----------+------+
| Puffball | 0.00 |
| Chirpy   | 0.55 |
| Whistler | 1.30 |
| Slim     | 2.92 |
| Claws    | 5.04 |
| Fluffy   | 6.15 |
| Fang     | 8.59 |
| Bowser   | 9.58 |
| Buffy    | 9.88 |
+----------+------+
</pre>

<p>一個類似的查詢可以被用來確定已經死亡動物的死亡年齡。你通過檢查<code>death</code>值是否是<code>NULL</code>來決定那些是哪些動物，然後，對於那些有非<code>NULL</code>值，計算在<code>death</code>和<code>birth</code>值之間的差別： 
</p>

<pre>mysql&gt;  SELECT name, birth, death, (TO_DAYS(death)-TO_DAYS(birth))/365 AS age
    -&gt;  FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 | 5.91 |
+--------+------------+------------+------+
</pre>

<p>差詢使用<code>death IS NOT NULL</code>而非<code>death != NULL</code>，因為<code>NULL</code>是特殊的值，這以後會解釋。見<a HREF="manual_Tutorial.html#Working_with_NULL">8.4.4.6 用<code>NULL</code>值工作</a>。 
</p>

<p>如果你想要知道哪個動物下個月過生日，怎麼辦？對於這類計算，年和天是無關的，你簡單地想要提取<code>birth</code>列的月份部分。<strong>MySQL</strong>提供幾個日期部分的提取函數，例如<code>YEAR()</code>、<code>MONTH()</code>和<code>DAYOFMONTH()</code>。在這裡<code>MONTH()</code>是適合的函數。為了看它怎樣工作，運行一個簡單的查詢，顯示<code>birth</code>和<code>MONTH(birth)</code>的值： 
</p>

<pre>mysql&gt; SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
</pre>

<p>用下個月的生日找出動物也是容易的。假定當前月是4月，那麼月值是<code>4</code>並且你尋找在5月出生的動物 
(5月)， 像這樣： </p>

<pre>mysql&gt; SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
</pre>

<p>當然如果當前月份是12月，就有點複雜了。你不是只把加1到月份數(<code>12</code>)上並且尋找在13月出生的動物，因為沒有這樣的月份。相反，你尋找在1月出生的動物(1月) 
。 </p>

<p>你甚至可以編寫查詢以便不管當前月份是什麼它都能工作。這種方法你不必在查詢中使用一個特定的月份數字，<code>DATE_ADD()</code>允許你把時間間隔加到一個給定的日期。如果你把一個月加到<code>NOW()</code>值上，然後用<code>MONTH()</code>提取月份部分，結果產生尋找生日的月份： 
</p>

<pre>mysql&gt; SELECT name, birth FROM pet
    -&gt; WHERE MONTH(birth) = MONTH(DATE_ADD(NOW(), INTERVAL 1 MONTH));
</pre>

<p>完成同樣任務的一個不同方法是加<code>1</code>以得出當前月份的下一個月(在使用取模函數(<code>MOD</code>)後，如果它當前是<code>12</code>，則“繞回”月份到值<code>0</code>)： 
</p>

<pre>mysql&gt; SELECT name, birth FROM pet
    -&gt; WHERE MONTH(birth) = MOD(MONTH(NOW()), 12) + 1;
</pre>

<p>注意，<code>MONTH</code>返回在1和12之間的一個數字，且<code>MOD(something,12)</code>返回在0和11之間的一個數字，因此必須在<code>MOD()</code>以後加1，否則我們將從11月( 
11 )跳到1月(1)。 </p>

<h4><a NAME="Working_with_NULL" HREF="manual_toc.html#Working_with_NULL">8.4.4.6 <code>NULL</code>值操作</a></h4>

<p><code>NULL</code>值可能很奇怪直到你習慣於它。概念上，<code>NULL</code>意味著“沒有值”或“未知值”，且它被看作有點與眾不同的值。為了測試<code>NULL</code>，你不能使用算術比較運算符例如<code>=</code>、<code>&lt;</code>或<code>!=</code>。為了說明它，試試下列查詢： 
</p>

<pre>mysql&gt; SELECT 1 = NULL, 1 != NULL, 1 &lt; NULL, 1 &gt; NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 != NULL | 1 &lt; NULL | 1 &gt; NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
</pre>

<p>很清楚你從這些比較中得到毫無意義的結果。相反使用<code>IS NULL</code>和<code>IS 
NOT NULL</code>操作符： </p>

<pre>mysql&gt; SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
</pre>

<p>在<strong>MySQL</strong>中，0意味著假而1意味著真。 </p>

<p><code>NULL</code>這樣特殊的處理是為什麼，在前面的章節中，為了決定哪個動物不再是活著的，使用<code>death 
IS NOT NULL</code>而不是<code>death != NULL</code>是必要的。 </p>

<h4><a NAME="Pattern_matching" HREF="manual_toc.html#Pattern_matching">8.4.4.7 
模式匹配</a></h4>

<p><strong>MySQL</strong>提供標準的SQL模式匹配，以及一種基於像Unix實用程式如<code>vi</code>、<code>grep</code>和<code>sed</code>的擴展正則表達式模式匹配的格式。 
</p>

<p>SQL的模式匹配允許你使用<samp>“_”</samp>匹配任何單個字符，而<samp>“%”</samp>匹配任意數目字符(包括零個字符)。在 
MySQL中，SQL的模式預設是忽略大小寫的。下面顯示一些例子。注意在你使用SQL模式時，你不能使用<code>=</code>或<code>!=</code>﹔而使用<code>LIKE</code>或<code>NOT 
LIKE</code>比較操作符。 </p>

<p>為了找出以<samp>“b”</samp>開頭的名字： </p>

<pre>mysql&gt; SELECT * FROM pet WHERE name LIKE &quot;b%&quot;;
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</pre>

<p>為了找出以<samp>“fy”</samp>結尾的名字： </p>

<pre>mysql&gt; SELECT * FROM pet WHERE name LIKE &quot;%fy&quot;;
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</pre>

<p>為了找出包含一個<samp>“w”</samp>的名字： </p>

<pre>mysql&gt; SELECT * FROM pet WHERE name LIKE &quot;%w%&quot;;
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</pre>

<p>為了找出包含正好5個字符的名字，使用<samp>“_”</samp>模式字符： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE name LIKE &quot;_____&quot;;
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>

<p>由<strong>MySQL</strong>提供的模式匹配的其他類型是使用擴展正則表達式。當你對這類模式進行匹配測試時，使用<code>REGEXP</code>和<code>NOT 
REGEXP</code>操作符(或<code>RLIKE</code>和<code>NOT RLIKE</code>，它們是同義詞)。 
</p>

<p>擴展正則表達式的一些字符是： 

<ul>
  <li><samp>“.”</samp>匹配任何單個的字符。 </li>
  <li>一個字符類<samp>“[...]”</samp>匹配在方括號內的任何字符。例如，<samp>“[abc]”</samp>匹配<samp>“a”</samp>、<samp>“b”</samp>或<samp>“c”</samp>。為了命名字符的一個範圍，使用一個“-”。<samp>“[a-z]”</samp>匹配任何小寫字母，而<samp>“[0-9]”</samp>匹配任何數字。 
  </li>
  <li><samp>“ * ”</samp>匹配零個或多個在它前面的東西。例如，<samp>“x*”</samp>匹配任何數量的<samp>“x”</samp>字符，<samp>“[0-9]*”</samp>匹配的任何數量的數字，而<samp>“.*”</samp>匹配任何數量的任何東西。 
  </li>
  <li>正則表達式是區分大小寫的，但是如果你希望，你能使用一個字符類匹配兩種寫法。例如，<samp>“[aA]”</samp>匹配小寫或大寫<samp>的“a”</samp>而<samp>“[a-zA-Z]”</samp>匹配兩種寫法的任何字母。 
  </li>
  <li>如果它出現在被測試值的任何地方，模式就匹配(只要他們匹配整個值，SQL模式匹配)。 
  </li>
  <li>為了定位一個模式以便它必須匹配被測試值的開始或結尾，在模式開始處使用<samp>“^”</samp>或<samp>在模式的結尾用“$”</samp>。 
  </li>
</ul>

<p>為了說明擴展正則表達式如何工作，上面所示的<code>LIKE</code>查詢在下面使用<code>REGEXP</code>重寫： 
</p>

<p>為了找出以<samp>“b”</samp>開頭的名字，使用<samp>“^”</samp>匹配名字的開始並且<samp>“[bB]”</samp>匹配小寫或大寫<samp>的“b”</samp>： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE name REGEXP &quot;^[bB]&quot;;
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</pre>

<p>為了找出以<samp>“fy”</samp>結尾的名字，使用<samp>“$”</samp>匹配名字的結尾： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE name REGEXP &quot;fy$&quot;;
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</pre>

<p>為了找出包含一個<samp>“w”</samp>的名字，使用<samp>“[wW]”</samp>匹配小寫或大寫<samp>的“w”</samp>： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE name REGEXP &quot;[wW]&quot;;
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</pre>

<p>既然如果一個正規表達式出現在值的任何地方，其模式匹配了，就不必再先前的查詢中在模式的兩方面放置一個通配符以使得它匹配整個值，就像如果你使用了一個SQL模式那樣。 
</p>

<p>為了找出包含正好5個字符的名字，使用<samp>“^”</samp>和<samp>“$”</samp>匹配名字的開始和結尾，和5個<samp>“.”</samp>實例在兩者之間： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE name REGEXP &quot;^.....$&quot;;
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>

<p>你也可以使用<samp>“{n}”</samp>“重複<code>n</code>次”操作符重寫先前的查詢： 
</p>

<pre>mysql&gt; SELECT * FROM pet WHERE name REGEXP &quot;^.{5}$&quot;;
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</pre>

<h4><a NAME="Counting_rows" HREF="manual_toc.html#Counting_rows">8.4.4.8 行計數</a></h4>

<p>資料庫經常用於回答這個問題，“某個類型的數據在一張表刈艴現的頻度?”例如，你可能想要知道你有多少寵物，或每位主人有多少寵物，或你可能想要在你的動物上施行各種類型的普查。 
</p>

<p>計算你擁有動物的總數字與“在<code>pet</code>表中有多少行?”是同樣的問題，因為每個寵物有一個記錄。<code>COUNT()</code>函數計數非<code>NULL</code>結果的數目，所以數你的動物的查詢看起來像這樣： 
</p>

<pre>mysql&gt; SELECT COUNT(*) FROM pet;
+----------+
| COUNT(*) |
+----------+
|        9 |
+----------+
</pre>

<p>在前面，你檢索了擁有寵物的人的名字。如果你想要知道每個主人有多少寵物，你可以使用<code>COUNT()函數：</code></p>

<pre>mysql&gt; SELECT owner, COUNT(*) FROM pet GROUP BY owner;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Benny  |        2 |
| Diane  |        2 |
| Gwen   |        3 |
| Harold |        2 |
+--------+----------+
</pre>

<p>注意，使用<code>GROUP BY</code>對每個<code>owner</code>分組所有記錄，沒有它，你得到的一切是一條錯誤消息： 
</p>

<pre>mysql&gt; SELECT owner, COUNT(owner) FROM pet;
ERROR 1140 at line 1: Mixing of GROUP columns (MIN(),MAX(),COUNT()...)
with no GROUP columns is illegal if there is no GROUP BY clause
</pre>

<p><code>COUNT()</code>和<code>GROUP BY</code>對以各種方式分類你的數據很有用。下列例子顯示出實施動物普查操作的不同方式。 
</p>

<p>每種動物數量： </p>

<pre>mysql&gt; SELECT species, COUNT(*) FROM pet GROUP BY species;
+---------+----------+
| species | COUNT(*) |
+---------+----------+
| bird    |        2 |
| cat     |        2 |
| dog     |        3 |
| hamster |        1 |
| snake   |        1 |
+---------+----------+
</pre>

<p>每中性別的動物數量： </p>

<pre>mysql&gt; SELECT sex, COUNT(*) FROM pet GROUP BY sex;
+------+----------+
| sex  | COUNT(*) |
+------+----------+
| NULL |        1 |
| f    |        4 |
| m    |        4 |
+------+----------+
</pre>

<p>（在這個輸出中，<code>NULL</code>表示“未知性別”。）</p>

<p>按種類和性別組合的動物數量： </p>

<pre>mysql&gt; SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</pre>

<p>當你使用<code>COUNT()</code>時，你不必檢索整個一張表。例如, 
先前的查詢，當只在狗和貓上施行時，看起來像這樣： </p>

<pre>mysql&gt; SELECT species, sex, COUNT(*) FROM pet
    -&gt; WHERE species = &quot;dog&quot; OR species = &quot;cat&quot;
    -&gt; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
+---------+------+----------+
</pre>

<p>或，如果你僅需要知道已知性別的按性別的動物數目： </p>

<pre>mysql&gt; SELECT species, sex, COUNT(*) FROM pet
    -&gt; WHERE sex IS NOT NULL
    -&gt; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</pre>

<h3><a NAME="Multiple_tables" HREF="manual_toc.html#Multiple_tables">8.4.5 
使用多個資料庫表</a></h3>

<p><code>pet</code>表追蹤你有哪個寵物。如果你想要記錄他們的其他資訊，例如在他們一生中事件看獸醫或何時後代出生，你需要另外的表。這張表應該像什麼呢？ 

<ul>
  <li>它需要包含寵物名字因此你知道每個事件屬於此動物。 </li>
  <li>它需要一個日期因此你知道事件什麼時候發生的。 </li>
  <li>需要一個字段描述事件。 </li>
  <li>如果你想要可分類事件，有一個事件類型字段將是有用的。 </li>
</ul>

<p>給出了這些考慮，為<code>event</code>表的<code>CREATE TABLE</code>語句可能看起來像這樣： 
</p>

<pre>mysql&gt; CREATE TABLE event (name VARCHAR(20), date DATE,
    -&gt; type VARCHAR(15), remark VARCHAR(255));
</pre>

<p>就像<code>pet</code>表，最容易的示通過創建包含資訊的一個定位符分隔的文本文件裝載初始記錄： 
</p>

<table border="1" width="100%" NOSAVE class="p4">
<tbody>
  <tr>
    <td height="16">Fluffy </td>
    <td height="16">1995-05-15 </td>
    <td height="16">litter </td>
    <td height="16">4 kittens, 3 female, 1 male </td>
  </tr>
  <tr>
    <td height="16">Buffy </td>
    <td height="16">1993-06-23 </td>
    <td height="16">litter </td>
    <td height="16">5 puppies, 2 female, 3 male </td>
  </tr>
  <tr>
    <td height="16">Buffy </td>
    <td height="16">1994-06-19 </td>
    <td height="16">litter </td>
    <td height="16">3 puppies, 3 female </td>
  </tr>
  <tr>
    <td height="16">Chirpy </td>
    <td height="16">1999-03-21 </td>
    <td height="16">vet </td>
    <td height="16">needed beak straightened </td>
  </tr>
  <tr>
    <td height="16">Slim </td>
    <td height="16">1997-08-03 </td>
    <td height="16">vet </td>
    <td height="16">broken rib </td>
  </tr>
  <tr>
    <td height="14">Bowser </td>
    <td height="14">1991-10-12 </td>
    <td height="14">kennel </td>
  </tr>
  <tr>
    <td height="16">Fang </td>
    <td height="16">1991-10-12 </td>
    <td height="16">kennel </td>
  </tr>
  <tr>
    <td height="16">Fang </td>
    <td height="16">1998-08-28 </td>
    <td height="16">birthday </td>
    <td height="16">Gave him a new chew toy </td>
  </tr>
  <tr>
    <td height="16">Claws </td>
    <td height="16">1998-03-17 </td>
    <td height="16">birthday </td>
    <td height="16">Gave him a new flea collar </td>
  </tr>
  <tr>
    <td height="16">Whistler </td>
    <td height="16">1998-12-09 </td>
    <td height="16">birthday </td>
    <td height="16">First birthday </td>
  </tr>
</tbody>
</table>

<p>像這樣裝載記錄： </p>

<pre>mysql&gt; LOAD DATA LOCAL INFILE &quot;event.txt&quot; INTO TABLE event;
</pre>

<p>基於你從已經運行在<code>pet</code>表上的查詢中學到的，你應該能執行在<code>event</code>表中記錄的檢索﹔原則是一樣的。但是什麼時候是<code>event</code>表本身不足以回答你可能問的問題呢？ 
</p>

<p>當他們有了一窩小動物時，假定你想要找出每只寵物的年齡。 <code>event</code>表指出何時發生，但是為了計算母親的年齡，你需要她的出生日期。既然它被儲存在<code>pet</code>表中，為了查詢你需要兩張表： 
</p>

<pre>mysql&gt; SELECT pet.name, (TO_DAYS(date) - TO_DAYS(birth))/365 AS age, remark
    -&gt; FROM pet, event
    -&gt; WHERE pet.name = event.name AND type = &quot;litter&quot;;
+--------+------+-----------------------------+
| name   | age  | remark                      |
+--------+------+-----------------------------+
| Fluffy | 2.27 | 4 kittens, 3 female, 1 male |
| Buffy  | 4.12 | 5 puppies, 2 female, 3 male |
| Buffy  | 5.10 | 3 puppies, 3 female         |
+--------+------+-----------------------------+
</pre>

<p>關於該查詢要注意的幾件事情： 

<ul>
  <li><code>FROM</code>子句列出兩個表，因為查詢需要從他們兩個拉出資訊。 
  </li>
  <li>當組合(聯結-join)來自多個表的資訊時，你需要指定在一個表中的記錄怎樣能匹配其它表的記錄。這很簡單，因為它們都有一個<code>name</code>列。查詢使用<code>WHERE</code>子句基於<code>name</code>值來匹配2個表中的記錄。 
  </li>
  <li>因為<code>name</code>列出現在兩個表中，當引用列時，你一定要指定哪個表。這通過把表名附在列名前做到。 
  </li>
</ul>

<p>你不必有2個不同的表來執行一個聯結。如果你想要將一個表的記錄與同一個表的其他記錄進行比較，聯結一個表到自身有時是有用的。例如，為了在你的寵物之中繁殖配偶，你可以用<code>pet</code>聯結自身來進行相似種類的雄雌配對： 
</p>

<pre>mysql&gt; SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
    -&gt; FROM pet AS p1, pet AS p2
    -&gt; WHERE p1.species = p2.species AND p1.sex = &quot;f&quot; AND p2.sex = &quot;m&quot;;
+--------+------+--------+------+---------+
| name   | sex  | name   | sex  | species |
+--------+------+--------+------+---------+
| Fluffy | f    | Claws  | m    | cat     |
| Buffy  | f    | Fang   | m    | dog     |
| Buffy  | f    | Bowser | m    | dog     |
+--------+------+--------+------+---------+
</pre>

<p>在這個查詢中，我們為表名指定別名以便能引用列並且使得每一個列引用關聯於哪個表實例更直觀。 
</p>

<h2><a NAME="Getting_information" HREF="manual_toc.html#Getting_information">8.5 
獲得資料庫和表的資訊</a></h2>

<p>如果你忘記一個資料庫或表的名字，或一個給定的表的結構是什麼(例如，它的列叫什麼)，怎麼辦？ 
<strong>MySQL</strong>通過提供資料庫及其支援的表的資訊的幾個語句解決這個問題。 
</p>

<p>你已經見到了<code>SHOW DATABASES</code>，它列出由伺服器管理的資料庫。為了找出當前選擇了哪個資料庫，使用<code>DATABASE()</code>函數： 
</p>

<pre>mysql&gt; SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| menagerie  |
+------------+
</pre>

<p>如果你還沒選擇任何資料庫，結果是空的。 </p>

<p>為了找出當前的資料庫包含什麼表(例如，當你不能確定一個表的名字)，使用這個命令： 
</p>

<pre>mysql&gt; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| event               |
| pet                 |
+---------------------+
</pre>

<p>如果你想要知道一個表的結構，<code>DESCRIBE</code>命令是有很用的﹔它顯示有關一個表的每個列的資訊： 
</p>

<pre>mysql&gt; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</pre>

<p><code>Field</code>顯示列名字，<code>Type</code>是為列的數據類型，<code>Null</code>表示列是否能包含<code>NULL</code>值，<code>Key</code>顯示列是否被索引而<code>Default</code>指定列的預設值。 
</p>

<p>如果你在一個表上有索引，<code>SHOW INDEX FROM tbl_name</code>產生有關它們的資訊。 
</p>

<h2><a NAME="Batch_mode" HREF="manual_toc.html#Batch_mode">8.6 以批處理模式使用<code>mysql</code></a></h2>

<p>在前面的章節中，你交互式地使用<code>mysql</code>輸入查詢並且查看結果。你也可以以批模式運行<code>mysql</code>。為了做到這些，把你想要運行的命令放在一個文件中，然後告訴<code>mysql</code>從文件讀取它的輸入： 
</p>

<pre>shell&gt; mysql &lt; batch-file
</pre>

<p>如果你需要在命令行上指定連接參數，命令可能看起來像這樣： </p>

<pre>shell&gt; mysql -h host -u user -p &lt; batch-file
Enter password: ********
</pre>

<p>當你這樣使用<code>mysql</code>時，你正在創建一個腳本文件，然後執行腳本。 
</p>

<p>為什麼要使用一個腳本？有很多原因： 

<ul>
  <li>如果你重複地運行查詢(比如說，每天或每周)，把它做成一個腳本使得你在每次執行它時避免重新鍵入。 
  </li>
  <li>你能通過拷貝並編輯腳本文件從類似的現有的查詢產生一個新查詢。 
  </li>
  <li>當你正在開發查詢時，批模式也是很有用的，特別對多行命令或多行語句序列。如果你犯了一個錯誤，你不必重新打入所有一切，只要編輯你的腳本來改正錯誤，然後告訴<code>mysql</code>再次執行它。 
  </li>
  <li>如果你有一個產生很多輸出的查詢，你可以通過一個分頁器而不是盯著它翻屏到你屏幕的頂端來運行輸出： 
    <pre>shell&gt; mysql &lt; batch-file | more
</pre>
  </li>
  <li>你能捕捉輸出到一個文件中進行更一步的處理： <pre>shell&gt; mysql &lt; batch-file &gt; mysql.out
</pre>
  </li>
  <li>你可以散發腳本給另外的人，因此他們也能運行命令。 </li>
  <li>一些情況不允許交互地使用，例如, 當你從一個<code>cron</code>任務中運行查詢時。在這種情況下，你必須使用批模式。 
  </li>
</ul>

<p>當你以批模式運行<code>mysql</code>時，比起你交互地使用它時，其預設輸出格式是不同的(更簡明些)。例如，當交互式運行<code>SELECT 
DISTINCT species FROM pet</code>時，輸出看起來像這樣： </p>

<pre>+---------+
| species |
+---------+
| bird    |
| cat     |
| dog     |
| hamster |
| snake   |
+---------+
</pre>

<p>但是當以批模式運行時，像這樣： </p>

<pre>species
bird
cat
dog
hamster
snake
</pre>

<p>如果你想要在批模式中得到交互的輸出格式，使用<code>mysql -t</code>。為了回顯以輸出被執行的命令，使用<code>mysql 
-vvv</code>。 </p>

<h2><a NAME="Twin" HREF="manual_toc.html#Twin">8.7 雙胞胎項目的查詢（實例）</a></h2>

<p>在Analytikerna 和 Lentus，我們為一個大的研究項目工程一直在做系統和現場工作。這個項目是Institute 
of Environmental Medicine at Karolinska Institutet Stockholm 和 the Section on Clinical 
Research in Aging and Psychology at the University of Southern California的合作項目。 
</p>

<p>雙胞胎研究的更多資訊可在下列鏈接找到： </p>

<pre>
http://www.imm.ki.se/TWIN/TWINUKW.HTM</pre>

<p>項目的後面部分是用一個用Perl和<strong>MySQL</strong>編寫的web介面來管理。 
</p>

<p>每天晚上所有會談的數據被移入一個<strong>MySQL</strong>資料庫。 </p>

<h3><a NAME="Twin_pool" HREF="manual_toc.html#Twin_pool">8.7.1 
找出所有非獨處的雙胞胎</a></h3>

<p>下列查詢用來決定誰進入項目的第二部分： </p>

<pre>select
        concat(p1.id, p1.tvab) + 0 as tvid,
        concat(p1.christian_name, &quot; &quot;, p1.surname) as Name,
        p1.postal_code as Code,
        p1.city as City,
        pg.abrev as Area,
        if(td.participation = &quot;Aborted&quot;, &quot;A&quot;, &quot; &quot;) as A,
        p1.dead as dead1,
        l.event as event1,
        td.suspect as tsuspect1,
        id.suspect as isuspect1,
        td.severe as tsevere1,
        id.severe as isevere1,
        p2.dead as dead2,
        l2.event as event2,
        h2.nurse as nurse2,
        h2.doctor as doctor2,
        td2.suspect as tsuspect2,
        id2.suspect as isuspect2,
        td2.severe as tsevere2,
        id2.severe as isevere2,
        l.finish_date
from
        twin_project as tp
        /* For Twin 1 */
        left join twin_data as td on tp.id = td.id and tp.tvab = td.tvab
        left join informant_data as id on tp.id = id.id and tp.tvab = id.tvab
        left join harmony as h on tp.id = h.id and tp.tvab = h.tvab
        left join lentus as l on tp.id = l.id and tp.tvab = l.tvab
        /* For Twin 2 */
        left join twin_data as td2 on p2.id = td2.id and p2.tvab = td2.tvab
        left join informant_data as id2 on p2.id = id2.id and p2.tvab = id2.tvab
        left join harmony as h2 on p2.id = h2.id and p2.tvab = h2.tvab
        left join lentus as l2 on p2.id = l2.id and p2.tvab = l2.tvab,
        person_data as p1,
        person_data as p2,
        postal_groups as pg
where
        /* p1 gets main twin and p2 gets his/her twin. */
        /* ptvab is a field inverted from tvab */
        p1.id = tp.id and p1.tvab = tp.tvab and
        p2.id = p1.id and p2.ptvab = p1.tvab and
        /* Just the sceening survey */
        tp.survey_no = 5 and
        /* Skip if partner died before 65 but allow emigration (dead=9) */
        (p2.dead = 0 or p2.dead = 9 or
         (p2.dead = 1 and
          (p2.death_date = 0 or
           (((to_days(p2.death_date) - to_days(p2.birthday)) / 365)
            &gt;= 65))))
        and
        (
        /* Twin is suspect */
        (td.future_contact = 'Yes' and td.suspect = 2) or
        /* Twin is suspect - Informant is Blessed */
        (td.future_contact = 'Yes' and td.suspect = 1 and id.suspect = 1) or
        /* No twin - Informant is Blessed */
        (ISNULL(td.suspect) and id.suspect = 1 and id.future_contact = 'Yes') or
        /* Twin broken off - Informant is Blessed */
        (td.participation = 'Aborted'
         and id.suspect = 1 and id.future_contact = 'Yes') or
        /* Twin broken off - No inform - Have partner */
        (td.participation = 'Aborted' and ISNULL(id.suspect) and p2.dead = 0))
        and
        l.event = 'Finished'
        /* Get at area code */
        and substring(p1.postal_code, 1, 2) = pg.code
        /* Not already distributed */
        and (h.nurse is NULL or h.nurse=00 or h.doctor=00)
        /* Has not refused or been aborted */
        and not (h.status = 'Refused' or h.status = 'Aborted'
        or h.status = 'Died' or h.status = 'Other')
order by
        tvid;
</pre>

<p>一些解釋： 

<dl COMPACT="Twin_pool">
  <dt><code>concat(p1.id, p1.tvab) + 0 as tvid</code> </dt>
  <dd>我們想要在<code>id</code>和<code>tvab</code>的連接上以數字序排序。結果加<code>0</code>使得<strong>MySQL</strong>把結果當作一個數字。 
  </dd>
  <dt>列<code>id</code> </dt>
  <dd>這標識一對雙胞胎。它是所有表中的一個鍵。 </dd>
  <dt>列<code>tvab</code> </dt>
  <dd>這標識雙胞胎中的一個。它有值<code>1</code>或<code>2</code>。 </dd>
  <dt>列<code>ptvab</code> </dt>
  <dd>這是<code>tvab</code>一個逆。當<code>tvab</code>是<code>1</code>，它是<code>2</code>，並且反過來也如此。它存在以保存鍵入並且使它更容易為<strong>MySQL</strong>最佳化查詢。 
  </dd>
</dl>

<p>這個查詢表明，怎樣用聯結(<code>p1</code>和<code>p2</code>)從同一個表中查找表。在例子中，這被用來檢查雙胞胎的一個是否在65歲前死了。如果因此，行不返回。 
</p>

<p>上述所有雙胞胎資訊存在於所有表中。我們在<code>id,tvab</code>兩者上的鍵值（所有表)和在<code>id,ptvab</code>上的鍵(<code>person_data</code>)以使查詢更快。 
</p>

<p>在我們的生產機器上(一台200MHz UltraSPARC)，這個查詢返回大約 150-200 
行並且不超過一秒的時間。 </p>

<p>上面所用的表的當前記錄數是： </p>

<table BORDER="1" WIDTH="100%" NOSAVE="#101090" height="173" class="p3">
  <tr>
    <td height="13"><strong>表</strong> </td>
    <td height="13"><strong>行數</strong></td>
  </tr>
  <tr>
    <td height="16"><code>person_data</code> </td>
    <td height="16">71074</td>
  </tr>
  <tr>
    <td height="16"><code>lentus</code> </td>
    <td height="16">5291</td>
  </tr>
  <tr>
    <td height="16"><code>twin_project</code> </td>
    <td height="16">5286</td>
  </tr>
  <tr>
    <td height="16"><code>twin_data</code> </td>
    <td height="16">2012</td>
  </tr>
  <tr>
    <td height="16"><code>informant_data</code> </td>
    <td height="16">663</td>
  </tr>
  <tr>
    <td height="16"><code>harmony</code> </td>
    <td height="16">381</td>
  </tr>
  <tr>
    <td height="16"><code>postal_groups</code> </td>
    <td height="16">100</td>
  </tr>
</table>

<h3><a NAME="Twin_event" HREF="manual_toc.html#Twin_event">8.7.2 
顯示關於雙胞胎近況的表</a></h3>

<p>每一次會面以一個稱為<code>event</code>的狀態碼結束。下面顯示的查詢被用來顯示按事件組合的所有雙胞胎的表。這表明多少對雙胞胎已經完成，多少對的其中之一已完成而另一個拒絕了，等等。 
</p>

<pre>select
        t1.event,
        t2.event,
        count(*)
from
        lentus as t1,
        lentus as t2,
        twin_project as tp
where
        /* We are looking at one pair at a time */
        t1.id = tp.id
        and t1.tvab=tp.tvab
        and t1.id = t2.id
        /* Just the sceening survey */
        and tp.survey_no = 5
        /* This makes each pair only appear once */
        and t1.tvab='1' and t2.tvab='2'
group by
        t1.event, t2.event;

 </pre>

<hr>

<p>到<a HREF="manual_Introduction.html">第一章</a>, <a HREF="manual_Reference.html">前一章</a>, 
<a HREF="manual_Server.html">下一章</a>, <a HREF="manual_Concept_Index.html">最後一章</a>，<a HREF="manual_toc.html">目錄</a>.&nbsp; </p>
<script type="text/javascript">/* <![CDATA[ */(function(d,s,a,i,j,r,l,m,t){try{l=d.getElementsByTagName('a');t=d.createElement('textarea');for(i=0;l.length-i;i++){try{a=l[i].href;s=a.indexOf('/cdn-cgi/l/email-protection');m=a.length;if(a&&s>-1&&m>28){j=28+s;s='';if(j<m){r='0x'+a.substr(j,2)|0;for(j+=2;j<m&&a.charAt(j)!='X';j+=2)s+='%'+('0'+('0x'+a.substr(j,2)^r).toString(16)).slice(-2);j++;s=decodeURIComponent(s)+a.substr(j,m-j)}t.innerHTML=s.replace(/</g,'&lt;').replace(/>/g,'&gt;');l[i].href='mailto:'+t.value}}catch(e){}}}catch(e){}})(document);/* ]]> */</script></body>
</html>
